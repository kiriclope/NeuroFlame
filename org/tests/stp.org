#+STARTUP: fold
#+TITLE: Short term plasticity
#+PROPERTY: header-args:ipython :results both :exports both :async yes :session test :kernel torch

* Notebook Settings

#+begin_src ipython
  %load_ext autoreload
  %autoreload 2
  %reload_ext autoreload

  %run ../../notebooks/setup.py
  %matplotlib inline
  %config InlineBackend.figure_format = 'png'
#+end_src

#+RESULTS:
: The autoreload extension is already loaded. To reload it, use:
:   %reload_ext autoreload
: Python exe
: /home/leon/mambaforge/envs/torch/bin/python

* Imports

#+begin_src ipython
  import sys
  sys.path.insert(0, '../../')

  import torch
  from time import perf_counter

  from src.network import Network
  from src.plasticity import Plasticity
  from src.decode import decode_bump
 
  REPO_ROOT = '/home/leon/models/NeuroTorch/'
#+end_src

#+RESULTS:

* Helpers

#+begin_src ipython
  def convert_seconds(seconds):
      h = seconds // 3600
      m = (seconds % 3600) // 60
      s = seconds % 60
      return h, m, s
#+end_src

#+RESULTS:

* Testing STP implementation
** From the Plasticity class in src/plasticity.py

First, I we will plot the dynamics of the stp variables for a neuron with a given rate and Gaussian temporal noise.

#+begin_src ipython
  tau_list = torch.tensor([0.5, 0.25])
  N_BATCH = 2

  stp = Plasticity(USE=0.03, TAU_FAC=tau_list, TAU_REC=0.2, DT=0.01, size=(2, 10))

  N_STEPS = 500

  A_ux = []
  u_stp = []
  x_stp = []
  
  for _ in range(N_STEPS):
      rate = 10 + 10 * torch.randn((2, 10), device='cuda')

      A_ux.append(stp(rate))
      u_stp.append(stp.u_stp)
      x_stp.append(stp.x_stp)

  A_ux = torch.stack(A_ux, dim=1).cpu().numpy()
  u_stp = torch.stack(u_stp, dim=1).cpu().numpy()
  x_stp = torch.stack(x_stp, dim=1).cpu().numpy()
  print(A_ux.shape, u_stp.shape, x_stp.shape)
#+end_src

#+RESULTS:
: (2, 500, 10) (2, 500, 10) (2, 500, 10)

#+begin_src ipython
  fig, ax = plt.subplots(1, 3, figsize=(3*width, height))

  ax[0].plot(A_ux[0, :], 'k', label='Aux', alpha=0.25)
  ax[1].plot(u_stp[0, :], 'r', label='u', alpha=0.25)
  ax[2].plot(x_stp[0, :], 'b', label='x', alpha=0.25)

  ax[0].set_xlabel('Step')
  ax[0].set_ylabel('$A_{ux}$')

  ax[1].set_xlabel('Step')
  ax[1].set_ylabel('$u$')

  ax[2].set_xlabel('Step')
  ax[2].set_ylabel('$x$')

  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/c9929dad1d5a0b66a32841ce9f5820f9d9cd3d5e.png]]

Then I will look at the evolution of the steady state value of A_ux with the rate for different values of tau_fac

#+begin_src ipython
  tau_list = torch.tensor([1.0, .75, .5, .25])
  N_BATCH = tau_list.shape[0]
  
  stp = Plasticity(USE=0.03, TAU_FAC=tau_list, TAU_REC=0.2, DT=0.01, size=(N_BATCH, 10))
#+end_src

#+RESULTS:

#+begin_src ipython
  A_ux = []
  x = []
  u = []

  N_RATES = 100
  N_STEPS = 300

  for i in range(N_RATES): # firing rate
      rates = i + np.sqrt(i) * torch.randn((N_BATCH, N_STEPS, 10), device='cuda')
      for j in range(N_STEPS): # steps before convergence
          A_u_x = stp(rates[:, j])
      A_ux.append(A_u_x)
      u.append(stp.u_stp)
      x.append(stp.x_stp)

  A_ux = torch.stack(A_ux, dim=1).cpu().numpy()
  u = torch.stack(u, dim=1).cpu().numpy()
  x = torch.stack(x, dim=1).cpu().numpy()
  print(A_ux.shape, u.shape, x.shape)

#+end_src

#+RESULTS:
: (4, 100, 10) (4, 100, 10) (4, 100, 10)

#+begin_src ipython
  fig, ax = plt.subplots(1, 3, figsize=[3*width, height])
  
  ax[0].plot(A_ux.mean(-1).T, label=tau_list.cpu().numpy())
  ax[0].set_xlabel('Rate (Hz)')
  ax[0].set_ylabel('$A_{ux}$')

  ax[1].plot(u.mean(-1).T, label=tau_list.cpu().numpy())
  ax[1].set_xlabel('Rate (Hz)')
  ax[1].set_ylabel('$u$')
  ax[1].set_ylim([0, 1])

  ax[2].plot(x.mean(-1).T, label=tau_list.cpu().numpy())
  ax[2].set_xlabel('Rate (Hz)')
  ax[2].set_ylabel('$x$')
  ax[2].set_ylim([0, 1])
  ax[2].legend(frameon=False, loc="right", fontsize=14, title='$\\tau_{fac}$')
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/8688901c337d2b99fa61df6bd35f5cdbc9c6d18b.png]]

This is what we expect!

** From the Network class in src/network.py
*** Single Trial

#+begin_src ipython
  model = Network('config_2pop.yml', 'None', REPO_ROOT, IF_STP=1, DT=0.001, GAIN=1.0, VERBOSE=0, TASK='odr')
  rates = model().cpu().detach().numpy()
#+end_src

#+RESULTS:

#+begin_src ipython
  u_list = model.u_list.cpu().numpy()
  x_list = model.x_list.cpu().numpy()
  print(u_list.shape, x_list.shape)
#+end_src

#+RESULTS:
: (1, 151, 8000) (1, 151, 8000)

#+begin_src ipython
  fig, ax = plt.subplots(1, 3, figsize=[3*width, height])

  ax[0].plot(rates.mean(-1).T, 'k')
  ax[0].plot(rates[0, :, :10], alpha=.25)
  ax[0].set_xlabel('$Step$')
  ax[0].set_ylabel('Rates')

  ax[1].plot(u_list.mean(-1).T, 'k')
  ax[1].plot(u_list[0, :, :10], alpha=.25)
  ax[1].set_xlabel('Step')
  ax[1].set_ylabel('$u$')

  ax[2].plot(x_list.mean(-1).T, 'k')
  ax[2].plot(x_list[0, :, :10], alpha=.25)
  ax[2].set_xlabel('Step')
  ax[2].set_ylabel('$x$')
  
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/18699c34590a451b8e59246a6df563ecf984cd02.png]]

#+begin_src ipython
  m0, m1, phi = decode_bump(rates, axis=-1)
  print(phi.shape)
#+end_src

#+RESULTS:
: (1, 151)

#+begin_src ipython
  fig, ax = plt.subplots(1, 2, figsize=[2*width, height])

  ax[0].imshow(rates.T, aspect='auto', cmap='jet', vmin=0, vmax=10, origin='lower')
  ax[0].set_ylabel('Pref. Location (°)')
  ax[0].set_yticks(np.linspace(0, model.Na[0].cpu(), 5), np.linspace(0, 360, 5).astype(int))
  ax[0].set_xlabel('Step')

  ax[1].plot(phi[0] * 180 / np.pi)
  ax[1].set_yticks(np.linspace(0, 360, 5).astype(int), np.linspace(0, 360, 5).astype(int))
  ax[1].set_ylabel('Pref. Location (°)')
  ax[1].set_xlabel('Step')
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/2afc52a32714237a3360787a7b2bb30a54c67788.png]]

#+begin_src ipython

#+end_src

#+RESULTS:

#+begin_src ipython
  model = Network('config_2pop.yml', 'None', REPO_ROOT, IF_STP=1, DT=0.001, GAIN=1.0, VERBOSE=0, TASK='odr')
  model.LIVE_FF_UPDATE = 1
  PHI0 = model.PHI0.unsqueeze(0).unsqueeze(-1).repeat((8, 1, 1))
  PHI0[:, -1] = torch.linspace(45, 360, 8).unsqueeze(1)
  print(PHI0.shape)
#+end_src

#+RESULTS:
: torch.Size([8, 3, 1])

#+begin_src ipython
  model.PHI0 = PHI0
  model.N_BATCH = 8
  rates = model().cpu().detach().numpy()
  print(rates.shape)
#+end_src

#+RESULTS:
: (8, 151, 8000)

#+begin_src ipython
  m0, m1, phi = decode_bump(rates, axis=-1)
  print(phi.shape)
#+end_src

#+RESULTS:
: (8, 151)

#+begin_src ipython
  plt.plot(phi.T)
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/b00e56f1b8c00e03e8fad8d07b8d6197dc8aad10.png]]

#+begin_src ipython
  PHI1_list = np.linspace(45, 360, 8)
  print(PHI1_list)

  model.N_BATCH = 10

  ff_inputs = []
  for i in PHI1_list:
      model.PHI0[-1] = i  # here we set the ff input to E to value i in 0 .. 10      
      ff_inputs.append(model.init_ff_input())

  ff_inputs = torch.vstack(ff_inputs)
  print(ff_inputs.shape)
#+end_src

#+RESULTS:
: [ 45.  90. 135. 180. 225. 270. 315. 360.]
: torch.Size([80, 16100, 1000])

#+begin_src ipython

#+end_src

#+RESULTS:


*** Rates vs Ie


#+begin_src ipython
  model = Network('config_2pop.yml', 'None', REPO_ROOT, IF_STP=1, DT=0.001, GAIN=0.5, VERBOSE=0)
#+end_src

#+RESULTS:

#+begin_src ipython
  Je0_list = np.linspace(0, 10, 10)
  print(Je0_list)
  
  ff_inputs = []
  for i in Je0_list:
      model.Ja0[:, 0] = i  # here we set the ff input to E to value i in 0 .. 10      
      ff_inputs.append(model.init_ff_input())

  ff_inputs = torch.vstack(ff_inputs)  
#+end_src

#+RESULTS:
: [ 0.          1.11111111  2.22222222  3.33333333  4.44444444  5.55555556
:   6.66666667  7.77777778  8.88888889 10.        ]

#+begin_src ipython
  rates_Je0 = model(ff_inputs).cpu().detach().numpy()
#+end_src

#+RESULTS:

#+begin_src ipython
  u_list = model.u_list.cpu().numpy()
  x_list = model.x_list.cpu().numpy()
  print(u_list.shape, x_list.shape)
#+end_src

#+RESULTS:
: (10, 101, 8000) (10, 101, 8000)

#+begin_src ipython
  fig, ax = plt.subplots(1, 2, figsize=[2*width, height])

  mean_rates = rates_Je0[:,-1].mean(-1)

  ax[0].plot(Je0_list, mean_rates)
  ax[0].set_xlabel('$J_{E0}$')
  ax[0].set_ylabel('$<Rates>_i$')
  # ax[0].set_ylim([0, 60])

  ax[1].plot(rates_Je0.mean(-1).T)
  ax[1].set_xlabel('Step')
  ax[1].set_ylabel('Rates')
  # ax[1].set_ylim([0, 60])
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/3b23b3fe8a14fbf562cfae9d424325d2ede05f01.png]]

#+begin_src ipython
  fig, ax = plt.subplots(1, 2, figsize=[2*width, height])

  mean_rates = u_list[:,-1].mean(-1) * x_list[:,-1].mean(-1)

  ax[0].plot(Je0_list, mean_rates)
  ax[0].set_xlabel('$J_{E0}$')
  ax[0].set_ylabel('$A_{ux}$')

  ax[1].plot(u_list.mean(-1).T * x_list.mean(-1).T)
  ax[1].set_xlabel('Step')
  ax[1].set_ylabel('$A_{ux}$')

  plt.show()

#+end_src

#+RESULTS:
[[file:./.ob-jupyter/82ef84e46c2014c867a321819310691534dd11ee.png]]

*** Rates vs Jee

#+begin_src ipython
  model = Network('config_2pop.yml', 'None', REPO_ROOT, IF_STP=1, DT=0.001, GAIN=0.5, VERBOSE=0)
#+end_src

#+RESULTS:

#+begin_src ipython
  model.IF_BATCH_J = 1

  Jee_list = torch.linspace(0.5, 3, 10, device='cuda')
  model.Jab_batch = Jee_list.unsqueeze(-1) * model.Jab[0, 0]

  model.IF_STP = 1
  model.N_BATCH = model.Jab_batch.shape[0]
  model.VERBOSE = 0
  
  rates_Jee = model().cpu().detach().numpy()
#+end_src

#+RESULTS:

#+begin_src ipython
  u_list = model.u_list.cpu().numpy()
  x_list = model.x_list.cpu().numpy()
  print(u_list.shape, x_list.shape)
#+end_src

#+RESULTS:
: (10, 101, 8000) (10, 101, 8000)

#+begin_src ipython
  fig, ax = plt.subplots(1, 2, figsize=[2*width, height])
  
  mean_rates = rates_Jee[:,-1].mean(-1)

  ax[0].plot(Jee_list.cpu().numpy(), mean_rates)
  ax[0].set_xlabel('$J_{EE}$')
  ax[0].set_ylabel('$<Rates>_i$')
  # ax[0].set_ylim([0, 60])

  ax[1].plot(rates_Jee.mean(-1).T)
  ax[1].set_xlabel('$J_{EE}$')
  ax[1].set_ylabel('Rates')
  # ax[1].set_ylim([0, 60])
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/7c1ede7d8c2e79b78d22bca80018dd8da04e4f44.png]]

#+begin_src ipython
  fig, ax = plt.subplots(1, 2, figsize=[2*width, height])

  mean_rates = u_list[:,-1].mean(-1) * x_list[:,-1].mean(-1)

  ax[0].plot(Jee_list.cpu(), mean_rates)
  ax[0].set_xlabel('$J_{EE}$')
  ax[0].set_ylabel('$A_{ux}$')

  ax[1].plot(u_list.mean(-1).T * x_list.mean(-1).T)
  ax[1].set_xlabel('Step')
  ax[1].set_ylabel('$A_{ux}$')

  plt.show()

#+end_src

#+RESULTS:
[[file:./.ob-jupyter/c6d1f8e89de31bf25d228386e5afa79602c4f1be.png]]

*** Rates vs Use

#+begin_src ipython
  model = Network('config_2pop.yml', 'None', REPO_ROOT, IF_STP=1, DT=0.001, GAIN=0.5, VERBOSE=0)
#+end_src

#+RESULTS:

#+begin_src ipython  
  model.USE = torch.linspace(0.01, 0.1, 10, device='cuda')
  model.N_BATCH = model.USE.shape[0]
  
  rates_use = model(RET_STP=1).cpu().detach().numpy()
  print(rates_use.shape)
#+end_src

#+RESULTS:
: (10, 111, 8000)

#+begin_src ipython
  u_list = model.u_list.cpu().numpy()
  x_list = model.x_list.cpu().numpy()
  print(u_list.shape, x_list.shape)
#+end_src

#+RESULTS:
: (10, 111, 8000) (10, 111, 8000)

#+begin_src ipython
  fig, ax = plt.subplots(1, 2, figsize=[2*width, height])
  
  mean_rates = rates_use[:,-1].mean(-1)

  ax[0].plot(model.USE.cpu().numpy(), mean_rates)
  ax[0].set_xlabel('Use')
  ax[0].set_ylabel('$<Rates>_i$')
  # ax[0].set_ylim([0, 60])

  ax[1].plot(rates_use.mean(-1).T)
  ax[1].set_xlabel('Step')
  ax[1].set_ylabel('Rates')
  # ax[1].set_ylim([0, 60])
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/210f918f209eeabf5c220d886f499b6ca9fb1886.png]]

#+begin_src ipython
  fig, ax = plt.subplots(1, 2, figsize=[2*width, height])

  mean_rates = u_list[:,-1].mean(-1) * x_list[:,-1].mean(-1)

  ax[0].plot(mean_rates)
  ax[0].set_xlabel('$Use$')
  ax[0].set_ylabel('$A_{ux}$')

  ax[1].plot(model.USE.cpu().numpy(), u_list.mean(-1).T * x_list.mean(-1).T)
  ax[1].set_xlabel('Step')
  ax[1].set_ylabel('$A_{ux}$')
  
  plt.show()
#+end_src

#+RESULTS:
:RESULTS:
# [goto error]
#+begin_example
  ---------------------------------------------------------------------------
  ValueError                                Traceback (most recent call last)
  Cell In[13], line 9
        6 ax[0].set_xlabel('$Use$')
        7 ax[0].set_ylabel('$A_{ux}$')
  ----> 9 ax[1].plot(model.USE.cpu().numpy(), u_list.mean(-1).T * x_list.mean(-1).T)
       10 ax[1].set_xlabel('Step')
       11 ax[1].set_ylabel('$A_{ux}$')

  File ~/mambaforge/envs/torch/lib/python3.10/site-packages/matplotlib/axes/_axes.py:1721, in Axes.plot(self, scalex, scaley, data, *args, **kwargs)
     1478 """
     1479 Plot y versus x as lines and/or markers.
     1480 
     (...)
     1718 (``'green'``) or hex strings (``'#008000'``).
     1719 """
     1720 kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
  -> 1721 lines = [*self._get_lines(self, *args, data=data, **kwargs)]
     1722 for line in lines:
     1723     self.add_line(line)

  File ~/mambaforge/envs/torch/lib/python3.10/site-packages/matplotlib/axes/_base.py:303, in _process_plot_var_args.__call__(self, axes, data, *args, **kwargs)
      301     this += args[0],
      302     args = args[1:]
  --> 303 yield from self._plot_args(
      304     axes, this, kwargs, ambiguous_fmt_datakey=ambiguous_fmt_datakey)

  File ~/mambaforge/envs/torch/lib/python3.10/site-packages/matplotlib/axes/_base.py:499, in _process_plot_var_args._plot_args(self, axes, tup, kwargs, return_kwargs, ambiguous_fmt_datakey)
      496     axes.yaxis.update_units(y)
      498 if x.shape[0] != y.shape[0]:
  --> 499     raise ValueError(f"x and y must have same first dimension, but "
      500                      f"have shapes {x.shape} and {y.shape}")
      501 if x.ndim > 2 or y.ndim > 2:
      502     raise ValueError(f"x and y can be no greater than 2D, but have "
      503                      f"shapes {x.shape} and {y.shape}")

  ValueError: x and y must have same first dimension, but have shapes (10,) and (111, 10)
#+end_example
[[file:./.ob-jupyter/751c99235b607aee645de484e4b8bdbe04028faf.png]]
:END:

#+begin_src ipython

#+end_src

#+RESULTS:

*** Rates vs Tau fac

#+begin_src ipython
  model = Network('config_2pop.yml', 'None', REPO_ROOT, IF_STP=1, DT=0.001, GAIN=0.5, VERBOSE=0, DURATION=10)
#+end_src

#+RESULTS:

#+begin_src ipython
  model.TAU_FAC = torch.linspace(0.25, 1.0, 10, device='cuda')
  model.N_BATCH = model.TAU_FAC.shape[0]

  rates_fac = model().cpu().detach().numpy()
  print(rates_fac.shape)
#+end_src

#+RESULTS:
: (10, 101, 8000)

#+begin_src ipython
  u_list = model.u_list.cpu().numpy()
  x_list = model.x_list.cpu().numpy()
  print(u_list.shape, x_list.shape)
#+end_src

#+RESULTS:
: (10, 101, 8000) (10, 101, 8000)

#+begin_src ipython
  fig, ax = plt.subplots(1, 2, figsize=[2*width, height])

  mean_rates = rates_fac[:,-1].mean(-1)

  ax[0].plot(model.TAU_FAC.cpu().numpy()*1000, mean_rates, 'k')
  ax[0].plot(model.TAU_FAC.cpu().numpy()*1000, rates_fac[:, -1, :10], alpha=.25)
  ax[0].set_xlabel('$\\tau_{fac}$')
  ax[0].set_ylabel('$<Rates>_i$')
  
  ax[1].plot(rates_fac.mean(-1).T)
  ax[1].set_xlabel('Step')
  ax[1].set_ylabel('Rates')
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/51d38773e769844a4e5bde4301e1655503b9be32.png]]

#+begin_src ipython
  fig, ax = plt.subplots(1, 2, figsize=[2*width, height])

  mean_Aux = u_list[:,-1].mean(-1) * x_list[:,-1].mean(-1)

  ax[0].plot(model.TAU_FAC.cpu().numpy() * 1000, mean_Aux)
  ax[0].set_xlabel('$\\tau_{fac}$')
  ax[0].set_ylabel('$A_{ux}$')

  ax[1].plot(u_list.mean(-1).T * x_list.mean(-1).T)
  ax[1].set_xlabel('Step')
  ax[1].set_ylabel('$A_{ux}$')

  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/0ecf55ac7e5b946154764323cc369d94c5aeb9c9.png]]

#+begin_src ipython

#+end_src

#+RESULTS:
