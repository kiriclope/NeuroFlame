#+STARTUP: fold
#+TITLE: RNN with pytorch
#+PROPERTY: header-args:ipython :results both :exports both :async yes :session test :kernel torch

* Notebook Settings

#+begin_src ipython
  %load_ext autoreload
  %autoreload 2
  %reload_ext autoreload

  %run ../notebooks/setup.py
  %matplotlib inline
  %config InlineBackend.figure_format = 'png'
#+end_src

#+RESULTS:
: The autoreload extension is already loaded. To reload it, use:
:   %reload_ext autoreload
: Python exe
: /home/leon/mambaforge/envs/torch/bin/python

* Imports

#+begin_src ipython
  import sys
  sys.path.insert(0, '../')

  import torch
  import pandas as pd
  from time import perf_counter

  from src.network import Network
  from src.lif_network import LIFNetwork
  from src.plot_utils import plot_con
  from src.decode import decode_bump
#+end_src

#+RESULTS:

* Helpers
** Connectivity

#+begin_src ipython
  def plot_eigen(W):
      # Compute eigenvalues
      eigenvalues = torch.linalg.eigvals(W).cpu().numpy()

      # Extract real and imaginary parts
      real_parts = eigenvalues.real
      imag_parts = eigenvalues.imag

      # Plotting
      plt.scatter(real_parts, imag_parts)
      plt.xlabel('Real Part')
      plt.ylabel('Imaginary Part')
      plt.axhline(y=0, color='k', linestyle='--')
      plt.axvline(x=0, color='k', linestyle='--')
      
      # plt.grid(True, which='both')
      plt.show()
#+end_src

#+RESULTS:

** Random

#+begin_src ipython
  def convert_seconds(seconds):
      h = seconds // 3600
      m = (seconds % 3600) // 60
      s = seconds % 60
      return h, m, s
#+end_src

#+RESULTS:

#+begin_src ipython
  def get_theta(a, b, GM=0, IF_NORM=0):

      if GM:
          b = b - np.dot(b, a) / np.dot(a, a) * a

      if IF_NORM:
          u = a / np.linalg.norm(a)
          v = b / np.linalg.norm(b)
      else:
          u=a
          v=b

      return np.arctan2(v, u)
#+end_src

#+RESULTS:

#+begin_src ipython
  def normalize(v):
      return v / np.linalg.norm(v)

  def project(x, u):
      return x * u
  # return np.dot(x, u) * u

  def sort_by_angle(x, u, v):
      u_hat = normalize(u)
      v_hat = normalize(v)

      x_proj_u = project(x, u_hat)
      x_proj_v = project(x, v_hat)
      # x_proj = x_proj_u + x_proj_v
      theta = np.arctan2(x_proj_v, x_proj_u) + np.pi

      # cos_theta = np.dot(x_proj, u_hat) / np.linalg.norm(x_proj) * u_hat
      # sin_theta = np.dot(x_proj, v_hat) / np.linalg.norm(x_proj) * v_hat
      # theta = np.arctan2(sin_theta, cos_theta)

      # Pair up each element of x with the corresponding angle
      # x_angle_pairs = list(zip(x, theta))

      # Sort based on the angle
      # x_angle_pairs.sort(key=lambda pair: pair[1])

      # Extract the sorted elements
      # sorted_x = [pair[0] for pair in x_angle_pairs]

      return theta
#+end_src

#+RESULTS:

#+begin_src ipython
  def get_idx(model):
      ksi = model.PHI0.cpu().detach().numpy()
      print(ksi.shape)

      idx = np.arange(0, len(ksi[0]))
      theta = get_theta(ksi[0], ksi[2], GM=0, IF_NORM=0)

      return theta.argsort()
#+end_src

#+RESULTS:

#+begin_src ipython
  def get_overlap(model, rates):
      ksi = model.PHI0.cpu().detach().numpy()
      return rates @ ksi.T / rates.shape[-1]

#+end_src

#+RESULTS:

* Connectivity
** Imports

#+begin_src ipython
  from src.connectivity import Connectivity
#+end_src

#+RESULTS:

** Balance

#+begin_src ipython
  Wij = Connectivity(1000, 1000, 100)('sparse', 'None', kappa=1.0, sigma=0, phase=0)
#+end_src

#+RESULTS:

#+begin_src ipython
  Cij = Wij.cpu().detach().numpy()
  print(Cij.shape)
#+end_src

#+RESULTS:
: (1000, 1000)

#+begin_src ipython
  plt.figure(figsize=(12, 5))  # Set the figure size (width, height) in inches

  ax1 = plt.subplot2grid((2, 3), (0, 0), rowspan=2)
  im = ax1.imshow(Cij, cmap='jet', aspect=1)
  ax1.set_xlabel("Presynaptic")
  ax1.set_ylabel("Postsynaptic")

  # Second column, first row
  ax2 = plt.subplot2grid((2, 3), (0, 1))
  Kj = np.sum(Cij, axis=0)  # sum over pres
  ax2.plot(Kj)
  # ax2.set_xticklabels([])
  ax2.set_ylabel("$K_j$")

  # # Second column, second row
  ax3 = plt.subplot2grid((2, 3), (1, 1))
  Ki = np.sum(Cij, axis=1)  # sum over pres
  ax3.plot(Kj)
  ax3.set_ylabel("$K_i$")

  ax4 = plt.subplot2grid((2, 3), (0, 2), rowspan=2)
  diags = []
  for i in range(int(Cij.shape[0] / 2)):
      diags.append(np.trace(Cij, offset=i) / Cij.shape[0])
  diags = np.array(diags)
  ax4.plot(diags)
  ax4.set_xlabel("Neuron #")
  ax4.set_ylabel("$P_{ij}$")

  plt.tight_layout()
  plt.show()

#+end_src

#+RESULTS:
[[file:./.ob-jupyter/33dfc5802d7e4bf339ebe28a17ca3c9d6161a9a9.png]]

#+begin_src ipython
  plot_eigen(1.0 * Wij)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/972353dede979f648dfea45b91c791cd94293f3e.png]]

#+begin_src ipython
  dominant_eigenvalue = eigenvalues[-1]
  dominant_eigenvector = eigenvectors[:, -1]

  # Assuming you want to reduce the dominant eigenvalue by a certain factor
  factor = 0.5  # Example factor to reduce the dominant eigenvalue
  adjustment = factor * dominant_eigenvalue

  # Construct the rank-one update matrix
  update_matrix = adjustment * torch.outer(dominant_eigenvector, dominant_eigenvector)
  
  # Subtract the update_matrix from A
  A_adjusted = A - update_matrix

#+end_src

#+RESULTS:
:RESULTS:
# [goto error]
: ---------------------------------------------------------------------------
: NameError                                 Traceback (most recent call last)
: Cell In[14], line 1
: ----> 1 dominant_eigenvalue = eigenvalues[-1]
:       2 dominant_eigenvector = eigenvectors[:, -1]
:       4 # Assuming you want to reduce the dominant eigenvalue by a certain factor
: 
: NameError: name 'eigenvalues' is not defined
:END:

** ODR

#+begin_src ipython
  Wij = Connectivity(1000, 1000, 100)('sparse', 'cosine', kappa=1.0, sigma=0, phase=0)
#+end_src

#+RESULTS:

#+begin_src ipython
  Cij = Wij.cpu().detach().numpy()
  print(Cij.shape)
#+end_src

#+RESULTS:
: (1000, 1000)

#+begin_src ipython
  plt.figure(figsize=(12, 5))  # Set the figure size (width, height) in inches

  ax1 = plt.subplot2grid((2, 3), (0, 0), rowspan=2)
  im = ax1.imshow(Cij, cmap='jet', aspect=1)
  ax1.set_xlabel("Presynaptic")
  ax1.set_ylabel("Postsynaptic")

  # Second column, first row
  ax2 = plt.subplot2grid((2, 3), (0, 1))
  Kj = np.sum(Cij, axis=0)  # sum over pres
  ax2.plot(Kj)
  # ax2.set_xticklabels([])
  ax2.set_ylabel("$K_j$")

  # # Second column, second row
  ax3 = plt.subplot2grid((2, 3), (1, 1))
  Ki = np.sum(Cij, axis=1)  # sum over pres
  ax3.plot(Kj)
  ax3.set_ylabel("$K_i$")

  ax4 = plt.subplot2grid((2, 3), (0, 2), rowspan=2)
  diags = []
  for i in range(int(Cij.shape[0] / 2)):
      diags.append(np.trace(Cij, offset=i) / Cij.shape[0])
  diags = np.array(diags)
  ax4.plot(diags)
  ax4.set_xlabel("Neuron #")
  ax4.set_ylabel("$P_{ij}$")

  plt.tight_layout()
  plt.show()

#+end_src

#+RESULTS:
[[file:./.ob-jupyter/d1532b66ff677858f15b6310d3fb045bea9cf6ac.png]]

#+begin_src ipython
  plot_eigen(1.0 * Wij)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/5eab8b9ca0caa99969f7e52658d965903d74025f.png]]

** Dual Task

#+begin_src ipython
  Con = Connectivity(1000, 1000, 100, verbose=1)
  Wij = Con('sparse', 'lr', kappa=5, lr_mean=[0, 0], lr_cov=[[1, 0], [0, 1]])
#+end_src

#+RESULTS:
: Generating low rank vectors
: ksi torch.Size([2, 1000])
: low rank probability
: Sparse random connectivity
: with weak low rank structure, KAPPA 5.00

#+begin_src ipython
  Pij = Con.Pij.cpu().numpy()
  print(Pij.shape)
#+end_src

#+RESULTS:
:RESULTS:
# [goto error]
: ---------------------------------------------------------------------------
: AttributeError                            Traceback (most recent call last)
: Cell In[20], line 1
: ----> 1 Pij = Con.Pij.cpu().numpy()
:       2 print(Pij.shape)
: 
: AttributeError: 'Connectivity' object has no attribute 'Pij'
:END:

#+begin_src ipython
  Pj = Pij.mean(axis=0)
  plt.plot(Pj)
  plt.show()
#+end_src

#+RESULTS:
:RESULTS:
# [goto error]
: ---------------------------------------------------------------------------
: NameError                                 Traceback (most recent call last)
: Cell In[21], line 1
: ----> 1 Pj = Pij.mean(axis=0)
:       2 plt.plot(Pj)
:       3 plt.show()
: 
: NameError: name 'Pij' is not defined
:END:

#+begin_src ipython
  Cij = Wij.cpu().detach().numpy()
  print(Cij.shape)
#+end_src

#+RESULTS:
: (1000, 1000)

#+begin_src ipython
  plt.figure(figsize=(12, 5))  # Set the figure size (width, height) in inches

  ax1 = plt.subplot2grid((2, 3), (0, 0), rowspan=2)
  im = ax1.imshow(Cij, cmap='jet', aspect=1)
  ax1.set_xlabel("Presynaptic")
  ax1.set_ylabel("Postsynaptic")

  # Second column, first row
  ax2 = plt.subplot2grid((2, 3), (0, 1))
  Kj = np.sum(Cij, axis=0)  # sum over pres
  ax2.plot(Kj)
  # ax2.set_xticklabels([])
  ax2.set_ylabel("$K_j$")

  # # Second column, second row
  ax3 = plt.subplot2grid((2, 3), (1, 1))
  Ki = np.sum(Cij, axis=1)  # sum over pres
  ax3.plot(Kj)
  ax3.set_ylabel("$K_i$")

  ax4 = plt.subplot2grid((2, 3), (0, 2), rowspan=2)
  diags = []
  for i in range(int(Cij.shape[0] / 2)):
      diags.append(np.trace(Cij, offset=i) / Cij.shape[0])
  diags = np.array(diags)
  ax4.plot(diags)
  ax4.set_xlabel("Neuron #")
  ax4.set_ylabel("$P_{ij}$")

  plt.tight_layout()
  plt.show()

#+end_src

#+RESULTS:
[[file:./.ob-jupyter/9ca2e0ea3a5fd991892e71eb0d1f9bebfa528c60.png]]

#+begin_src ipython
  plot_eigen(1.0 * Wij)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/c49ea092c7b6e6ceccf42884f1c2d5ed104c1794.png]]

#+begin_src ipython
  ksi = Con.ksi.cpu().detach().numpy()
  print('ksi', ksi.shape)
  idx = np.arange(0, len(ksi[0]))
  # print(theta.shape)
  theta = get_theta(ksi[0], ksi[1], GM=0, IF_NORM=1)
  theta = np.arctan2(ksi[1], ksi[0])
  index_order = theta.argsort()
  # print(index_order)
  Cij_ordered = Cij[:][index_order]
  print(Cij_ordered.shape)
#+end_src

#+RESULTS:
: ksi (2, 1000)
: (1000, 1000)

#+begin_src ipython
  plt.figure(figsize=(12, 5))  # Set the figure size (width, height) in inches

  ax1 = plt.subplot2grid((2, 3), (0, 0), rowspan=2)
  im = ax1.imshow(Cij_ordered, cmap='jet', aspect=1)
  ax1.set_xlabel("Presynaptic")
  ax1.set_ylabel("Postsynaptic")

  # Second column, first row
  ax2 = plt.subplot2grid((2, 3), (0, 1))
  Kj = np.sum(Cij_ordered, axis=0)  # sum over pres
  ax2.plot(Kj)
  # ax2.set_xticklabels([])
  ax2.set_ylabel("$K_j$")

  # # Second column, second row
  ax3 = plt.subplot2grid((2, 3), (1, 1))
  Ki = np.sum(Cij_ordered, axis=1)  # sum over pres
  ax3.plot(Kj)
  ax3.set_ylabel("$K_i$")

  ax4 = plt.subplot2grid((2, 3), (0, 2), rowspan=2)
  diags = []
  for i in range(int(Cij_ordered.shape[0] / 2)):
      diags.append(np.trace(Cij_ordered, offset=i) / Cij_ordered.shape[0])
  diags = np.array(diags)
  ax4.plot(diags)
  ax4.set_xlabel("Neuron #")
  ax4.set_ylabel("$P_{ij}$")

  plt.tight_layout()
  plt.show()

#+end_src

#+RESULTS:
[[file:./.ob-jupyter/9d0f14947fad15ffd4080efb5777766a1c032ef0.png]]

#+begin_src ipython

#+end_src

#+RESULTS:

** Sparse

#+begin_src ipython
    REPO_ROOT = "/home/leon/models/NeuroTorch"
    model = Network('config_EI.yml', 'test', REPO_ROOT, VERBOSE=1, DEVICE='cuda', TASK='odr',
                    PROBA_TYPE=['cosine', '', '',''], KAPPA=[1, 0, 0, 0])
#+end_src

#+RESULTS:
: Na tensor([8000, 2000], device='cuda:0', dtype=torch.int32) Ka tensor([1000., 1000.], device='cuda:0') csumNa tensor([    0,  8000, 10000], device='cuda:0')
: Jab [1.0, -1.5, 1, -1]
: Ja0 [0.0, 0.0]

#+begin_src ipython
  import torch

  # Simulate a large dense matrix
  # Example is small for demonstration purposes, adjust sizes accordingly
  # dense_matrix = torch.tensor([[0, 0, 3], [4, 0, 0], [0, 0, 5]], dtype=torch.float32)

  N = 10000
  K = 1000

  # dense_matrix = 1.0 * (torch.rand(N, N, device='cuda') <= (K / float(N)))
  dense_matrix = model.Wab_T.T

  # Define variables to store indices and values of non-zero elements
  nnz_indices = []
  nnz_values = []

  # Define chunk size (adjust based on your memory constraints)
  chunk_size = 4  # Here, a chunk consists of 1 row for simplicity

  # Loop through chunks of the matrix
  for i in range(0, dense_matrix.size(0), chunk_size):
      # Get the current chunk
      chunk = dense_matrix[i:i+chunk_size, :]

      # Find non-zero elements in the chunk
      chunk_nnz_indices = torch.nonzero(chunk, as_tuple=False).t()  # Transpose to match COO format
      chunk_nnz_values = chunk[chunk_nnz_indices[0], chunk_nnz_indices[1]]

      # Adjust chunk indices to global indices
      chunk_nnz_indices[0] += i  # Adjust row indices for chunks beyond the first

      # Append current chunk's non-zero elements to the lists
      nnz_indices.append(chunk_nnz_indices)
      nnz_values.append(chunk_nnz_values)

  # Concatenate all non-zero indices and values
  nnz_indices = torch.cat(nnz_indices, dim=1)  # Concatenate along columns
  nnz_values = torch.cat(nnz_values)

  # Create sparse tensor
  sparse_matrix = torch.sparse_coo_tensor(nnz_indices, nnz_values, dense_matrix.size())

  print(sparse_matrix)
#+end_src

#+RESULTS:
: tensor(indices=tensor([[   0,    0,    0,  ..., 9999, 9999, 9999],
:                        [   3,    4,   16,  ..., 9995, 9996, 9998]]),
:        values=tensor([ 0.0316,  0.0316,  0.0316,  ..., -0.0316, -0.0316,
:                       -0.0316]),
:        device='cuda:0', size=(10000, 10000), nnz=19997007,
:        layout=torch.sparse_coo)

#+begin_src ipython
  plot_con(sparse_matrix.to_dense().cpu().detach().numpy().T)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/6363b377319641faa39ce199f413c71ee2c5ff40.png]]

** Von Mises

#+begin_src ipython
  Cij = Connectivity(1000, 1000, 1.0)('all2all', 'von_mises', kappa=1.0, sigma=0, phase=0)
#+end_src

#+RESULTS:

#+begin_src ipython
  Cij = Cij.cpu().detach().numpy()
  print(Cij.shape)
#+end_src

#+RESULTS:
: (1000, 1000)

#+begin_src ipython
  plt.figure(figsize=(12, 5))  # Set the figure size (width, height) in inches

  ax1 = plt.subplot2grid((2, 3), (0, 0), rowspan=2)
  im = ax1.imshow(Cij, cmap='jet', aspect=1)
  ax1.set_xlabel("Presynaptic")
  ax1.set_ylabel("Postsynaptic")

  # Second column, first row
  ax2 = plt.subplot2grid((2, 3), (0, 1))
  Kj = np.sum(Cij, axis=0)  # sum over pres
  ax2.plot(Kj)
  # ax2.set_xticklabels([])
  ax2.set_ylabel("$K_j$")

  # # Second column, second row
  ax3 = plt.subplot2grid((2, 3), (1, 1))
  Ki = np.sum(Cij, axis=1)  # sum over pres
  ax3.plot(Kj)
  ax3.set_ylabel("$K_i$")

  ax4 = plt.subplot2grid((2, 3), (0, 2), rowspan=2)
  diags = []
  for i in range(int(Cij.shape[0] / 2)):
      diags.append(np.trace(Cij, offset=i) / Cij.shape[0])
  diags = np.array(diags)
  ax4.plot(diags)
  ax4.set_xlabel("Neuron #")
  ax4.set_ylabel("$P_{ij}$")

  plt.tight_layout()
  plt.show()

#+end_src

#+RESULTS:
[[file:./.ob-jupyter/3035e87f407ba0146c03212c75b6bf0447e550ab.png]]

** Manifold

#+begin_src ipython
  
  theta_list = torch.linspace(0, 2.0 * torch.pi, 1000 + 1)[:-1]

  Wfb = torch.stack((torch.cos(theta_list), torch.sin(theta_list))).T
  print(Wfb.shape)

#+end_src

#+RESULTS:
: torch.Size([1000, 2])

* Stimuli
** Imports

#+begin_src ipython
  from src.stimuli import Stimuli
#+end_src

#+RESULTS:

** ODR

#+begin_src ipython
  ff_input = Stimuli(task='odr', size=(10, 1000))(1, 1, 0, rnd_phase=1).cpu().detach().numpy()
  print(ff_input.shape)
  plt.plot(ff_input.T[:, :5])
  
  plt.xlabel('Neuron #')
  plt.ylabel('Input Strength')
  plt.title('ODR')
  plt.show()
#+end_src

#+RESULTS:
:RESULTS:
: (10, 1000)
[[file:./.ob-jupyter/08175596293c776cd9e07f9fc4d95fcf56466f22.png]]
:END:

** Dual Task

#+begin_src ipython
  xi = torch.randn((2, 1000), device='cuda')
  ff_input = Stimuli(task='dual', size=(10, 1000))(1, 1, xi[0]).cpu().detach().numpy()

  print(ff_input.shape)

  theta = get_theta(xi[0].cpu().numpy(), xi[1].cpu().numpy(), GM=0, IF_NORM=0)
  theta = np.arctan2(xi[1].cpu().numpy(), xi[0].cpu().numpy())
  index_order = theta.argsort()
  
  ff_input = ff_input[index_order]
  plt.plot(ff_input)
  plt.xlabel('Neuron #')
  plt.ylabel('Input Strength')
  plt.title('Dual Task')
  plt.show()
#+end_src

#+RESULTS:
:RESULTS:
: (1000,)
[[file:./.ob-jupyter/9f5c22022cbc510b0011e92bef07d19018d436b0.png]]
:END:

* FF Inputs
** ODR

#+begin_src ipython
    REPO_ROOT = "/home/leon/models/NeuroTorch"
    model = Network('config_EI.yml', 'test', REPO_ROOT, VERBOSE=1, DEVICE='cuda', TASK='odr',
                    PROBA_TYPE=['cosine', '', '',''])
#+end_src

#+RESULTS:
: Na tensor([8000, 2000], device='cuda:0', dtype=torch.int32) Ka tensor([1000., 1000.], device='cuda:0') csumNa tensor([    0,  8000, 10000], device='cuda:0')
: Jab [1.0, -1.5, 1, -1]
: Ja0 [2.0, 1.0]

#+begin_src ipython
  ff_input = model.init_ff_input().cpu().detach().numpy()
  print(ff_input.shape)
#+end_src

#+RESULTS:
: (1, 4600, 10000)

#+begin_src ipython
  plt.plot(ff_input[0, :, :5])
  plt.plot(ff_input[0, :, -5:])
  plt.xlabel('Step')
  plt.ylabel('FF Input')
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/f6535c0e4e8c9d8307ee7b55dd21d59143db683a.png]]

#+begin_src ipython
  plt.imshow(ff_input[0].T, cmap='jet', vmin=0, aspect='auto')
  plt.xlabel('Step')
  plt.ylabel('Neuron #')
  plt.ylim([0, 7500])
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/161f3e3c0b3c33c82f34d47c4b9962b0e98c742d.png]]

** Dual Task

#+begin_src ipython
    REPO_ROOT = "/home/leon/models/NeuroTorch"
    model = Network('config_EI.yml', 'test', REPO_ROOT, VERBOSE=0, DEVICE='cuda', TASK='dual_rand',
                    PROBA_TYPE=['lr', '', '',''], LIVE_FF_UPDATE=0)
#+end_src

#+RESULTS:

#+begin_src ipython
  ff_input = model.init_ff_input().cpu().detach().numpy()
  print(ff_input.shape)
#+end_src

#+RESULTS:
: (1, 11100, 10000)

#+begin_src ipython 
  plt.plot(ff_input[0, :, :10])
  plt.plot(ff_input[0, :, -10:])
  plt.xlabel('Step')
  plt.ylabel('FF Input')
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/c86dc3c7e1c0bc295c692a8c724e52faaf161ba2.png]]

#+begin_src ipython
  plt.imshow(ff_input[0].T, cmap='jet', vmin=100, aspect='auto')
  plt.xlabel('Step')
  plt.ylabel('Neuron #')
  plt.ylim([0, 8000])
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/7d243642e4a26e8e783eba4ee9df82313361c1a1.png]]

#+begin_src ipython
  ksi = model.PHI0.cpu().detach().numpy()
  theta = get_theta(ksi[0], ksi[2], GM=0, IF_NORM=0)
  index_order = theta.argsort()
  ff_ordered = ff_input[..., index_order]
#+end_src

#+RESULTS:

#+begin_src ipython
  plt.imshow(ff_ordered[0].T, cmap='jet', vmin=0, aspect='auto')
  plt.xlabel('Step')
  plt.ylabel('Pref Loc. (°)')
  plt.yticks(np.linspace(0, 8000, 5), np.linspace(0, 360, 5).astype(int))
  # plt.ylim([0, 10])
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/8e0ecb44fc0d9f68fcf007e76aef192ef0d0c672.png]]

* STP
** from class
#+begin_src ipython
  from src.plasticity import Plasticity
#+end_src

#+RESULTS:

#+begin_src ipython
  stp = Plasticity(0.03, 0.65, 0.25, 0.01, (1,1000))

  A_u_x = []
  for i in range(300):
      rates = torch.randn((2, 1000), device='cuda')
      A_u_x.append( stp(rates)[0].cpu().detach().numpy())

  A_u_x = np.array(A_u_x)
#+end_src

#+RESULTS:

#+begin_src ipython
  plt.plot(A_u_x.mean(1))
  plt.xlabel('Step')
  plt.ylabel('$A_{ux}$')
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/5bc5582682d7afd17924d618bdbeb6cb8545427f.png]]

#+begin_src ipython
  stp = Plasticity(0.03, 0.65, 0.25, 0.01, (1,1000))

  A_u_x = []
  for i in range(100):
      rates = i + torch.randn((2, 1000), device='cuda')
      A_u_x.append(stp(rates)[0].cpu().detach().numpy())

  A_u_x = np.array(A_u_x)
  print(A_u_x.shape)
#+end_src

#+RESULTS:
: (100, 1000)

#+begin_src ipython
  plt.plot(A_u_x.mean(1))
  plt.xlabel('Rate (Hz)')
  plt.ylabel('$A_{ux}$')
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/478dddcbb71fa79e20c3a05f6253383890756054.png]]

** from model

#+begin_src ipython
  REPO_ROOT = "/home/leon/models/NeuroTorch"
  model = Network('config_EI.yml', 'odr', REPO_ROOT, VERBOSE=0, DEVICE='cuda', IF_STP=1, LR_TRAIN=0, N_BATCH=1, DT=0.005)
  rates = model(REC_LAST_ONLY=0).cpu().detach().numpy()
#+end_src

#+RESULTS:
: [[1.0, 0.9, 0.0, 0.0], [0.9, 1.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.9], [0.0, 0.0, 0.9, 1.0]]

#+begin_src ipython
  print(rates.shape)
  r_max = 2 # * np.max(rates[-1, :15000])
  plt.imshow(rates[0].T, aspect='auto', cmap='jet', vmin=0, vmax=r_max, origin='lower')
  plt.ylabel('Neuron #')
  plt.xlabel('Step')
  plt.colorbar()
  plt.show()
#+end_src

#+RESULTS:
:RESULTS:
: (1, 41, 8000)
[[file:./.ob-jupyter/f6ccd9cb0d5e156e9e3bc0846dc258b48634f3d1.png]]
:END:

* Single Trial
** Model

#+begin_src ipython
  REPO_ROOT = "/home/leon/models/NeuroTorch"
  model = Network('config_EI.yml', 'test', REPO_ROOT, VERBOSE=0, DEVICE='cuda', TASK='dual', LIVE_FF_UPDATE=1)
#+end_src

#+RESULTS:

** Dynamics

#+begin_src ipython
  rates = model().cpu().detach().numpy()[0]
  print(rates.shape)
#+end_src

#+RESULTS:
: (51, 8000)

#+begin_src ipython
  ff_input = model.ff_input.cpu().numpy()
  print(ff_input.shape)
#+end_src

#+RESULTS:
: (1, 51, 8000)

#+begin_src ipython
  print(np.max(ff_input))
  print(np.mean(ff_input==0))
#+end_src

#+RESULTS:
: 3655.667
: 0.0

#+begin_src ipython
  fig, ax = plt.subplots(1, 2, figsize=[2*width, height])

  ax[0].plot(ff_input[0, :, 0])
  ax[0].plot(ff_input[0, :, 0])

  ax[0].set_xlabel('Step')
  ax[0].set_ylabel('FF Input')

  ax[1].imshow(ff_input[0].T, aspect='auto', origin='lower', cmap='jet', vmin=0, vmax=2000)
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/2bcc2a4021bcc141b6edc76d0790ca6696e83869.png]]

#+begin_src ipython
  import matplotlib.colors
  # Color for False and True
  cmap = matplotlib.colors.ListedColormap(['blue', 'yellow'])

  r_max = 20

  fig, ax = plt.subplots(1, 2, figsize=[2*width, height])

  ax[0].plot(rates[:, :20])
  ax[0].plot(rates[:, -20:])

  ax[0].set_xlabel('Step')
  ax[0].set_ylabel('Rates')

  ax[1].imshow(rates.T, aspect='auto', origin='lower', cmap='jet')

  # plt.colorbar()
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/bab4ce7e62d8f4e915223c038c56ffebff514e80.png]]

#+RESULTS:

** Connectivity

#+begin_src ipython
  Cij = model.Wab_T.cpu().detach().numpy()
  print(Cij.shape)

  plt.figure(figsize=(12, 5))  # Set the figure size (width, height) in inches

  ax1 = plt.subplot2grid((2, 3), (0, 0), rowspan=2)
  im = ax1.imshow(Cij, cmap='jet', aspect=1)
  ax1.set_xlabel("Presynaptic")
  ax1.set_ylabel("Postsynaptic")

  # Second column, first row
  ax2 = plt.subplot2grid((2, 3), (0, 1))
  Kj = np.sum(Cij, axis=0)  # sum over pres
  ax2.set_title('$<K_j>= %d$' % np.mean(Kj))
  ax2.plot(Kj)
  # ax2.set_xticklabels([])
  ax2.set_ylabel("$K_j$")

  # # Second column, second row
  ax3 = plt.subplot2grid((2, 3), (1, 1))
  Ki = np.sum(Cij, axis=1)  # sum over pres
  ax3.set_title('$<K_i>= %d$' % np.mean(Ki))
  ax3.plot(Kj)
  ax3.set_ylabel("$K_i$")

  ax4 = plt.subplot2grid((2, 3), (0, 2), rowspan=2)
  diags = []
  for i in range(int(Cij.shape[0] / 2)):
      diags.append(np.trace(Cij, offset=i) / Cij.shape[0])
  diags = np.array(diags)
  ax4.plot(diags)
  ax4.set_xlabel("Neuron #")
  ax4.set_ylabel("$P_{ij}$")

  plt.tight_layout()
  plt.show()
#+end_src

#+RESULTS:
:RESULTS:
: (10000, 10000)
[[file:./.ob-jupyter/17165e4bcc9a52b24637125363f1562c9ede43c7.png]]
:END:

** FF Inputs

#+begin_src ipython
  ff_input = model.ff_input.cpu().detach().numpy()
  print(ff_input.shape)

  fig, ax = plt.subplots(1, 2)

  ax[0].plot(ff_input[0, :, :5])
  ax[0].plot(ff_input[0, :, -5:])
  ax[0].set_xlabel('Step')
  ax[0].set_ylabel('FF Input')

  ax[1].imshow(ff_input[0].T, cmap='jet', vmin=0, aspect='auto')
  ax[1].set_xlabel('Step')
  ax[1].set_ylabel('Neuron #')
  ax[1].set_ylim([0, 10000])
  plt.show()
#+end_src

#+RESULTS:
:RESULTS:
: (1, 51, 8000)
[[file:./.ob-jupyter/bb1a77e0bf9212fbd726195f11f62016548bcc60.png]]
:END:

* Balance

#+begin_src ipython
  REPO_ROOT = "/home/leon/models/NeuroTorch"
  K_list = [500, 1000, 1500, 2000, 2500, 3000]
  rates_list = []

  for K in K_list:
      model = LIFNetwork('config_2pop.yml', 'balance', REPO_ROOT, VERBOSE=0, DEVICE='cuda', K=K)
      rates = model.forward()
      rates_list.append(rates[0].cpu().detach().numpy())

#+end_src

#+RESULTS:

#+begin_src ipython
  rates = np.array(rates_list)
  print(rates.shape)

  plt.plot(np.sqrt(K_list), np.mean(rates[..., 8000]) * np.sqrt(K_list), '-o')
  plt.xlabel('$\sqrt{K}$')
  plt.ylabel('$\sqrt{K}$ Rates')
  plt.show()
#+end_src

#+RESULTS:
:RESULTS:
: (6, 41, 10000)
[[file:./.ob-jupyter/d3f09a8c678cca33a2797e5df9664a637068a3dc.png]]
:END:

#+begin_src ipython

#+end_src

#+RESULTS:
