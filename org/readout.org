#+STARTUP: fold
#+TITLE: RNN with pytorch
#+PROPERTY: header-args:ipython :results both :exports both :async yes :session readout :kernel torch

* Notebook Settings

#+begin_src ipython
  %load_ext autoreload
  %autoreload 2
  %reload_ext autoreload

  %run ../notebooks/setup.py
  %matplotlib inline
  %config InlineBackend.figure_format = 'png'
#+end_src

#+RESULTS:
: The autoreload extension is already loaded. To reload it, use:
:   %reload_ext autoreload
: Python exe
: /home/leon/mambaforge/envs/torch/bin/python

* Imports

#+begin_src ipython
  import sys
  sys.path.insert(0, '../')

  import torch
  import gc
  import pandas as pd
  from time import perf_counter

  from src.network import Network
  from src.plot_utils import plot_con
  from src.decode import decode_bump
  from src.utils import clear_cache
#+end_src

#+RESULTS:
* Helpers

#+begin_src ipython
  def convert_seconds(seconds):
      h = seconds // 3600
      m = (seconds % 3600) // 60
      s = seconds % 60
      return h, m, s
#+end_src

#+RESULTS:

#+begin_src ipython 
  import numpy as np
  def get_theta(a, b, GM=0, IF_NORM=0):

      u, v = a, b

      if GM:
          v = b - np.dot(b, a) / np.dot(a, a) * a

      if IF_NORM:
          u = a / np.linalg.norm(a)
          v = b / np.linalg.norm(b)

      return np.arctan2(v, u)
#+end_src

#+RESULTS:

#+begin_src ipython 
  def get_idx(model):
      ksi = model.PHI0.cpu().detach().numpy()
      print(ksi.shape)

      theta = get_theta(ksi[0], ksi[2], GM=0, IF_NORM=0)
      return theta.argsort()
#+end_src

#+RESULTS:

#+begin_src ipython 
  def get_overlap(model, rates):
      ksi = model.PHI0.cpu().detach().numpy()
      return rates @ ksi.T / rates.shape[-1]

#+end_src

#+RESULTS:


#+RESULTS:

* Dual task with rotating readout
** Parameters

#+begin_src ipython
  REPO_ROOT = "/home/leon/models/NeuroTorch"
  conf_name = "config_EI.yml"
  name = "low_rank_ini"
  seed = np.random.randint(100)
  # 34, 53
  print(seed)
#+end_src

#+RESULTS:
: 71

** Simulation

#+begin_src ipython
  LR_COV = [[1.0, 0.8, 0.0, 0.0],
            [0.8, 1.0, 0.0, 0.0],
            [0.0, 0.0, 1.0, 0.8],
            [0.0, 0.0, 0.8, 1.0]]

  start = perf_counter()
  model = Network(conf_name, name, REPO_ROOT, VERBOSE=0, DEVICE='cuda:1',
                  N_BATCH=200, SEED=seed, LR_COV=LR_COV,
                  TASK='dual_rand', LIVE_FF_UPDATE=1, DURATION=10)

  rates = model(REC_LAST_ONLY=1).detach().cpu().numpy()
  end = perf_counter()
  
  print("Elapsed (with compilation) = %dh %dm %ds" % convert_seconds(end - start))
  print('rates', rates.shape)
#+end_src

#+RESULTS:
: 9461fb91-d601-4d02-b252-7a0ea887bce1

** Readout

#+begin_src ipython
  Ne = model.Na[0].detach().cpu().numpy()
  N = model.N_NEURON
#+end_src

#+RESULTS:
: 5a3367c2-2a47-4292-a68f-0cda1e05f59b

#+begin_src ipython
  idx = get_idx(model)
  rates_ordered = rates[..., idx]
  print(rates_ordered.shape)
#+end_src

#+RESULTS:
: a2eab3e4-7c26-420e-9824-b959253e7c38

#+begin_src ipython
  m0, m1, phi = decode_bump(rates_ordered, axis=-1)
  print(m0.shape)
#+end_src

#+RESULTS:
: d8987ae8-8941-4945-80fa-0d0986fa842d

#+begin_src ipython
  from scipy.stats import circmean
  n_ini = 100
  # mean_phi = np.mean(phi[:n_ini]) * 180 / np.pi / 2
  mean_phi = circmean(phi[:n_ini]) * 180 / np.pi / 2
  print(mean_phi)

  # mean_phi += np.mean(phi[n_ini:]) * 180 / np.pi / 2
  mean_phi += circmean(phi[n_ini:]) * 180 / np.pi / 2
  print(mean_phi)

  # mean_phi = circmean(phi) * 180 / np.pi
  print('readout angle', mean_phi/2)
#+end_src

#+RESULTS:
: 44fbbce5-384e-49a4-bbb0-4d3101a56693

#+begin_src ipython
  fig, ax = plt.subplots(figsize=(height, height))
  x = m1 / m0 * np.cos(phi)
  y = m1 / m0 * np.sin(phi)

  ax.plot(x, y, 'ob', alpha=.1)

  x = m1 / m0 * np.cos(phi - mean_phi * np.pi / 180)
  y = m1 / m0 * np.sin(phi - mean_phi * np.pi / 180)

  ax.plot(x, y, 'sr', alpha=.1)
  
  ax.set_xlim([-2, 2])
  ax.set_ylim([-2, 2])
  plt.show()
#+end_src

#+RESULTS:
: a67a58ac-bd24-45e5-99c6-43e51cea2e1a

#+begin_src ipython

#+end_src

#+RESULTS:
: a1395367-f50d-467b-9fc0-504a0cb38790

** Naive

#+begin_src ipython
  model.TASK = 'dual'
  model.DURATION = 10
  model.N_STEPS = int(model.DURATION / model.DT) + model.N_STEADY + model.N_WINDOW
  model.I0 = [0.5, 0.5]
#+end_src

#+RESULTS:
: 113d9e83-c12a-4f46-afdf-2bf9f3fee5d6

#+begin_src ipython
  rates = model().detach().cpu().numpy()
#+end_src

#+RESULTS:
: 71b60924-91f2-430a-acf7-6c1573bb7c31

#+begin_src ipython
  print(rates.shape)
#+end_src

#+RESULTS:
: 47bdf8d8-52c3-4135-af82-6ad547c20618

#+begin_src ipython
  idx = get_idx(model)
  rates_ordered = rates[..., idx]
  print(rates_ordered.shape)
#+end_src

#+RESULTS:
: 1ae7d51c-26e9-485b-8a32-ebb4e2e3bac1

#+begin_src ipython
  overlap = get_overlap(model, rates)
  print(overlap.T.shape)
#+end_src

#+RESULTS:
: bd893983-22a2-41b1-b827-df2a35608854

#+begin_src ipython
  fig, ax = plt.subplots(1, 3, figsize=[2*width, height])

  ax[0].plot(overlap.T[0])
  ax[0].set_ylabel('Overlap on $m_S$ (Hz)')
  ax[0].set_xlabel('Step')

  ax[1].plot(overlap.T[1])
  ax[1].set_ylabel('Overlap on $n_S$ (Hz)')
  ax[1].set_xlabel('Step')

  ax[2].plot(overlap.T[2])
  ax[2].set_ylabel('Overlap on $m_D$ (Hz)')
  ax[2].set_xlabel('Step')

  plt.show()
#+end_src

#+RESULTS:
: 90e531b7-9dfd-4fc6-b578-47513e45e0da

#+begin_src ipython
  m0, m1, phi = decode_bump(rates_ordered, axis=-1)
  print(m0.shape)
#+end_src

#+RESULTS:
: b335870b-a8a9-4c48-bd69-5e3c734ce0d0

#+begin_src ipython
  fig, ax = plt.subplots(1, 3, figsize=[2*width, height])

  ax[0].plot(m0.T)
  #ax[0].set_ylim([0, 360])
  #ax[0].set_yticks([0, 90, 180, 270, 360])
  ax[0].set_ylabel('$\mathcal{F}_0$ (Hz)')
  ax[0].set_xlabel('Step')

  ax[1].plot(m1.T)
  # ax[1].set_ylim([0, 360])
  # ax[1].set_yticks([0, 90, 180, 270, 360])
  ax[1].set_ylabel('$\mathcal{F}_1$ (Hz)')
  ax[1].set_xlabel('Step')

  ax[2].plot(phi.T * 180 / np.pi)
  ax[2].set_ylim([0, 360])
  ax[2].set_yticks([0, 90, 180, 270, 360])
  ax[2].set_ylabel('Phase (°)')
  ax[2].set_xlabel('Step')

  plt.show()
#+end_src

#+RESULTS:
: 4425398f-198f-47bd-a2c6-9547251379c1

#+begin_src ipython
  n_ini=100
  readoutA = overlap[:n_ini, -5:, 0]
  readoutB = overlap[n_ini:, -5:, 0]

  readout = np.stack((readoutA, readoutB))
  print(readout.shape)
#+end_src

#+RESULTS:
: aa6bd245-5530-4585-ae45-795035dc785a

#+begin_src ipython
  perf = (readout[0]>0).mean((0, 1))
  perf += (readout[1]<0).mean((0,1))

  print('performance', perf/2)
#+end_src

#+RESULTS:
: afd0dd7e-a5fe-4e76-b1eb-5ac5b5f6a64e

** Trained

#+begin_src ipython
  model.PHI1 = torch.tensor([mean_phi, 90+mean_phi], device='cuda:1')
  model.TASK = 'dual_odr'
  model.DURATION = 10
  model.N_STEPS = int(model.DURATION / model.DT) + model.N_STEADY + model.N_WINDOW
#+end_src

#+RESULTS:
: 89049ac3-eee0-4d7d-b7f5-f0cd2a0fe114

#+begin_src ipython
  rates = model().detach().cpu().numpy()
#+end_src

#+RESULTS:
: dccf22a0-f50f-4bc8-918a-7a3dd85f80f2

#+begin_src ipython
  print(rates.shape)
#+end_src

#+RESULTS:
: e464014a-59a9-46f4-90f5-ca361a7b6190

#+begin_src ipython
  idx = get_idx(model)
  rates_ordered = rates[..., idx]
  print(rates_ordered.shape)
#+end_src

#+RESULTS:
: df53cc30-4129-4465-afcd-8f65d4050aad

#+begin_src ipython
  overlap = get_overlap(model, rates)
  print(overlap.T.shape)
#+end_src

#+RESULTS:
: a3f918e1-1527-4158-95c5-e2a64401d693

#+begin_src ipython
  fig, ax = plt.subplots(1, 3, figsize=[2*width, height])

  ax[0].plot(overlap.T[0])
  ax[0].set_ylabel('Overlap on $m_S$ (Hz)')
  ax[0].set_xlabel('Step')

  ax[1].plot(overlap.T[1])
  ax[1].set_ylabel('Overlap on $n_S$ (Hz)')
  ax[1].set_xlabel('Step')

  ax[2].plot(overlap.T[2])
  ax[2].set_ylabel('Overlap on $m_D$ (Hz)')
  ax[2].set_xlabel('Step')

  plt.show()
#+end_src

#+RESULTS:
: c1661edb-7863-4fe4-90c6-f4b60fcb0a2a

#+begin_src ipython
  m0, m1, phi = decode_bump(rates_ordered, axis=-1)
  print(m0.shape)
#+end_src

#+RESULTS:
: 03e9d937-5311-410c-baf8-c6906d5892c9

#+begin_src ipython
  fig, ax = plt.subplots(1, 3, figsize=[2*width, height])

  ax[0].plot(m0.T)
  #ax[0].set_ylim([0, 360])
  #ax[0].set_yticks([0, 90, 180, 270, 360])
  ax[0].set_ylabel('$\mathcal{F}_0$ (Hz)')
  ax[0].set_xlabel('Step')

  ax[1].plot(m1.T)
  # ax[1].set_ylim([0, 360])
  # ax[1].set_yticks([0, 90, 180, 270, 360])
  ax[1].set_ylabel('$\mathcal{F}_1$ (Hz)')
  ax[1].set_xlabel('Step')

  ax[2].plot(phi.T * 180 / np.pi)
  ax[2].set_ylim([0, 360])
  ax[2].set_yticks([0, 90, 180, 270, 360])
  ax[2].set_ylabel('Phase (°)')
  ax[2].set_xlabel('Step')

  plt.show()
#+end_src

#+RESULTS:
: 79bcc70a-314d-4ccb-9add-f9efb8a9fb5d

#+begin_src ipython
  print(overlap.shape)
#+end_src

#+RESULTS:
: 7d0ed39e-86ef-4b9a-916f-ad973299c69f

#+begin_src ipython
  n_ini=100
  readoutA = overlap[:n_ini, -5:, 0]
  readoutB = overlap[n_ini:, -5:, 0]

  readout = np.stack((readoutA, readoutB))
  print(readout.shape)
#+end_src

#+RESULTS:
: b684e45b-68e8-4cbc-a81c-7a09f64d9538

#+begin_src ipython
  perf = (readout[0]>0).mean((0, 1))
  perf += (readout[1]<0).mean((0,1))

  print(perf/2 * 100)
#+end_src

#+RESULTS:
: 77e2091c-9bea-496f-8c5b-bcd045094dfc

#+begin_src ipython
  def get_perf(rates, n_ini=50):
      m0, m1, phi = decode_bump(rates, axis=-1)
      x = m1[..., -1] / m0[..., -1] * np.cos(phi[..., -1] - mean_phi * np.pi / 180)
      performance = (x[:n_ini] < 0).mean() * 100
      performance += (x[n_ini:] > 0).mean() * 100
      
      return performance / 2
#+end_src

#+RESULTS:
: 08f9aff7-4810-4731-b301-4c4fd7d3689d

#+RESULTS:
: (100, 101, 8000)

#+begin_src ipython
  print(mean_phi)
#+end_src

#+RESULTS:
: cd6e5bcd-1c33-451b-9a42-53816696a25f

#+begin_src ipython
  get_perf(rates_ordered)
#+end_src

#+RESULTS:
: d95aed61-68a2-4d08-9825-41c3fe9782ed




