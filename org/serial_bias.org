#+STARTUP: fold
#+TITLE: Serial Bias
#+PROPERTY: header-args:ipython :results both :exports both :async yes :session sbias :kernel torch

* Notebook Settings

#+begin_src ipython
  %load_ext autoreload
  %autoreload 2
  %reload_ext autoreload

  %run ../notebooks/setup.py
  %matplotlib inline
  %config InlineBackend.figure_format = 'png'
#+end_src

#+RESULTS:
:RESULTS:
: The autoreload extension is already loaded. To reload it, use:
:   %reload_ext autoreload
: Python exe
: /home/leon/mambaforge/envs/torch/bin/python
: <Figure size 600x370.82 with 0 Axes>
:END:

* Imports

#+begin_src ipython
  import sys
  sys.path.insert(0, '../')

  import torch
  from time import perf_counter

  from src.network import Network
  from src.plasticity import Plasticity
  from src.decode import decode_bump
 
  REPO_ROOT = '/home/leon/models/NeuroTorch/'
#+end_src

#+RESULTS:

* Helpers

#+begin_src ipython
  def convert_seconds(seconds):
      h = seconds // 3600
      m = (seconds % 3600) // 60
      s = seconds % 60
      return h, m, s
#+end_src

#+RESULTS:

* Single Trial

#+begin_src ipython
  model = Network('config_2pop.yml', 'None', REPO_ROOT, IF_STP=1, DT=0.001, GAIN=1.0, VERBOSE=0, TASK='odr', LIVE_FF_UPDATE=1)
  rates = model(RET_STP=1).cpu().detach().numpy()
#+end_src

#+RESULTS:

#+begin_src ipython
  print(model.PHI0.shape)
#+end_src

#+RESULTS:
: torch.Size([1, 3])

#+begin_src ipython
  u_list = model.u_list.cpu().numpy()
  x_list = model.x_list.cpu().numpy()
  print(u_list.shape, x_list.shape)
#+end_src

#+RESULTS:
: (1, 111, 8000) (1, 111, 8000)

#+begin_src ipython
  fig, ax = plt.subplots(1, 3, figsize=[3*width, height])

  ax[0].plot(rates.mean(-1).T, 'k')
  ax[0].plot(rates[0, :, :10], alpha=.25)
  ax[0].set_xlabel('$Step$')
  ax[0].set_ylabel('Rates')

  ax[1].plot(u_list.mean(-1).T, 'k')
  ax[1].plot(u_list[0, :, :10], alpha=.25)
  ax[1].set_xlabel('Step')
  ax[1].set_ylabel('$u$')

  ax[2].plot(x_list.mean(-1).T, 'k')
  ax[2].plot(x_list[0, :, :10], alpha=.25)
  ax[2].set_xlabel('Step')
  ax[2].set_ylabel('$x$')
  
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/acba724f68f1b7ed4ba9e514812c2648329a4287.png]]

#+begin_src ipython
  m0, m1, phi = decode_bump(rates, axis=-1)
  print(phi.shape)
#+end_src

#+RESULTS:
: (1, 111)

#+begin_src ipython
  fig, ax = plt.subplots(1, 2, figsize=[2*width, height])

  ax[0].imshow(rates.T, aspect='auto', cmap='jet', vmin=0, vmax=10, origin='lower')
  ax[0].set_ylabel('Pref. Location (°)')
  ax[0].set_yticks(np.linspace(0, model.Na[0].cpu(), 5), np.linspace(0, 360, 5).astype(int))
  ax[0].set_xlabel('Step')

  ax[1].plot(phi[0] * 180 / np.pi)
  ax[1].set_yticks(np.linspace(0, 360, 5).astype(int), np.linspace(0, 360, 5).astype(int))
  ax[1].set_ylabel('Pref. Location (°)')
  ax[1].set_xlabel('Step')
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/82ea2c258b206b6ac926b117001f0c67427dfad8.png]]

#+begin_src ipython

#+end_src

#+RESULTS:

* Serial Bias
** Batching Inputs Sequences

#+begin_src ipython

  N_PHASE = 2
  PHI0_list = np.linspace(180, 360, N_PHASE)

  model.N_BATCH = N_PHASE
  model = Network('config_2pop.yml', 'None', REPO_ROOT, IF_STP=1, DT=0.001, GAIN=1.0, VERBOSE=0, TASK='odr', seed=1)

  ff_input = []
  for i in PHI0_list:
      model.PHI0[:, -1] = i  # here we set the ff input to E to value i in 0 .. 10
      ff_input.append(model.init_ff_input())
  
  ff_input = torch.vstack(ff_input)
  print('ff_inputs', ff_input.shape)
#+end_src

#+RESULTS:
: ff_inputs torch.Size([2, 12100, 10000])

#+begin_src ipython
  rates = model(ff_input=ff_input, RET_FF=1).cpu().detach().numpy()
  print(rates.shape)
#+end_src

#+RESULTS:
: (2, 111, 8000)

#+begin_src ipython
  ff_input = model.ff_input.cpu().numpy()
  print(ff_input.shape)
#+end_src

#+RESULTS:
: (2, 12100, 8000)

#+begin_src ipython
  fig, ax = plt.subplots(1, 2, figsize=[2*width, height])

  ax[0].imshow(ff_input[0].T, aspect='auto', cmap='jet', vmin=0, origin='lower')
  ax[0].set_ylabel('Pref. Location (°)')
  ax[0].set_yticks(np.linspace(0, model.Na[0].cpu(), 5), np.linspace(0, 360, 5).astype(int))
  ax[0].set_xlabel('Step')

  ax[1].imshow(ff_input[1].T, aspect='auto', cmap='jet', vmin=0, origin='lower')
  ax[1].set_ylabel('Pref. Location (°)')
  ax[1].set_yticks(np.linspace(0, model.Na[0].cpu(), 5), np.linspace(0, 360, 5).astype(int))
  ax[1].set_xlabel('Step')
  
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/828022f39d5c28e8d915ee2e94a7182fe1ba5d42.png]]

#+begin_src ipython
  ff_input[0,:,0]
#+end_src

#+RESULTS:
: array([44.72136, 44.72136, 44.72136, ..., 44.72136, 44.72136, 44.72136],
:       dtype=float32)

** Batching Live Inputs

#+begin_src ipython

  model = Network('config_2pop.yml', 'None', REPO_ROOT, IF_STP=1, DT=0.001, GAIN=1.0, VERBOSE=0, TASK='odr', seed=1, LIVE_FF_UPDATE=1)

  #########################################################################################################
  ### WARNING ### YOU NEED TO SET LIVE_FF_UPDATE INSIDE THE MODEL DEF OTHERWISE Ja0 WONT BE SCALED PROPERLY
  #########################################################################################################

  N_PHASE = 32
  print(model.PHI0.shape)

  PHI0 = model.PHI0.unsqueeze(-1).repeat((N_PHASE, 1, 1))

  print(PHI0.shape)
  PHI0[:, -1] = torch.linspace(45, 360, N_PHASE).unsqueeze(1)
  # print(PHI0[:, :, 0])
#+end_src

#+RESULTS:
: torch.Size([1, 3])
: torch.Size([32, 3, 1])

#+begin_src ipython
  model.PHI0 = PHI0
  model.N_BATCH = N_PHASE
  rates = model(RET_FF=0).cpu().numpy()
  print(rates.shape)
#+end_src

#+RESULTS:
: (32, 111, 8000)

#+begin_src ipython
  m0, m1, phi = decode_bump(rates, axis=-1)
  print(phi.shape)
#+end_src

#+RESULTS:
: (32, 111)

#+begin_src ipython
  fig, ax = plt.subplots(1, 2, figsize=[2*width, height])
  
  ax[0].imshow(rates[0].T, aspect='auto', cmap='jet', vmin=0, vmax=10, origin='lower')
  ax[0].set_ylabel('Pref. Location (°)')
  ax[0].set_yticks(np.linspace(0, model.Na[0].cpu(), 5), np.linspace(0, 360, 5).astype(int))
  ax[0].set_xlabel('Step')

  ax[1].plot(phi.T * 180 / np.pi)
  ax[1].set_yticks(np.linspace(0, 360, 5).astype(int), np.linspace(0, 360, 5).astype(int))
  ax[1].set_ylabel('Pref. Location (°)')
  ax[1].set_xlabel('Step')
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/2e3da880993b816fe62e82f81fff1cc277d17613.png]]

#+begin_src ipython
  rel_loc = (model.PHI0[:, 0] - model.PHI0[:, -1]).cpu().numpy()
  errors = model.PHI0[:, -1].cpu().numpy() - (360 - phi * 180 / np.pi)
#+end_src

#+RESULTS:

#+begin_src ipython
  plt.hist(errors[:, -1], bins='auto')
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/0a149af46ff4cacc2a532d85b042f455d3b9cd36.png]]

#+begin_src ipython
  plt.plot(rel_loc[:, 0], errors[:,-1], 'o')
  plt.xlabel('Rel. Loc. (°)')
  plt.ylabel('Error (°)')
  plt.ylim([-60, 60])
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/5de40ab6c3fc6f120474ec5b37fddb60cf58f101.png]]

#+begin_src ipython

#+end_src

#+RESULTS:
