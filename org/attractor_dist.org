#+STARTUP: fold
#+TITLE: Dual Task Readout Rotation
#+PROPERTY: header-args:ipython :results both :exports both :async yes :session dist :kernel torch

* Notebook Settings

#+begin_src ipython
  %load_ext autoreload
  %autoreload 2
  %reload_ext autoreload

  %run ../notebooks/setup.py
  %matplotlib inline
  %config InlineBackend.figure_format = 'png'
#+end_src

#+RESULTS:
: The autoreload extension is already loaded. To reload it, use:
:   %reload_ext autoreload
: Python exe
: /home/leon/mambaforge/envs/torch/bin/python

* Imports

#+begin_src ipython
  import sys
  sys.path.insert(0, '../')

  import torch
  import gc
  import pandas as pd
  from time import perf_counter

  from src.network import Network
  from src.plot_utils import plot_con
  from src.decode import decode_bump, decode_bump_torch, circcvl
  from src.utils import clear_cache

  from sklearn.cluster import KMeans
  kmeans = KMeans(n_clusters=2)
#+end_src

#+RESULTS:

* Helpers

#+begin_src ipython
  def convert_seconds(seconds):
      h = seconds // 3600
      m = (seconds % 3600) // 60
      s = seconds % 60
      return h, m, s
#+end_src

#+RESULTS:

#+begin_src ipython
  import numpy as np
  def get_theta(a, b, GM=0, IF_NORM=0):

      u, v = a, b

      if GM:
          v = b - np.dot(b, a) / np.dot(a, a) * a

      if IF_NORM:
          u = a / np.linalg.norm(a)
          v = b / np.linalg.norm(b)

      return np.arctan2(v, u) % (2.0 * np.pi)
#+end_src

#+RESULTS:

#+begin_src ipython
  def get_idx(model):
      ksi = model.PHI0.cpu().detach().numpy()
      theta = get_theta(ksi[0], ksi[2], GM=0, IF_NORM=0)
      return theta.argsort()
#+end_src

#+RESULTS:

#+begin_src ipython
  def get_overlap(model, rates):
      return rates @ model.PHI0.T / rates.shape[-1]
#+end_src

#+RESULTS:

#+begin_src ipython
  def get_perf_cr(rates, phi0, n_ini):
      m0, m1, phi = decode_bump_torch(rates, axis=-1)

      x = m1[..., -1] / m0[..., -1] * torch.cos(phi[..., -1])
      y = m1[..., -1] / m0[..., -1] * torch.sin(phi[..., -1])

      X = torch.stack((x,y))

      xPhi = torch.cos(torch.pi / 2 + torch.tensor(phi0))
      yPhi = torch.sin(torch.pi / 2 + torch.tensor(phi0))
      vPhi = torch.stack((xPhi, yPhi))

      dot = vPhi.to(X.device).to(X.dtype) @ X

      # if phi0 > 0 and phi0 < 180:
      #     dot = dot * -1

      # print(dot[:n_ini])
      A = torch.stack([(dot[:n_ini]<0).sum(), (dot[:n_ini]>0).sum()])
      # print('A perf', A)

      # print(dot[n_ini:])
      B = torch.stack([(dot[n_ini:]>0).sum(), (dot[n_ini:]<0).sum()])
      # print('B perf', B)

      perf = torch.max(A + B) / X.shape[1] * 100

      return perf
#+end_src

#+RESULTS:

#+begin_src ipython
  def get_perf(model, rates, n_ini):
      overlap = get_overlap(model, rates)

      readoutA = overlap[:n_ini, -5:, 0]
      readoutB = overlap[n_ini:, -5:, 0]

      readout = torch.stack((readoutA, readoutB))

      perf = (1.0 * (readout[0]>0)).mean((0, 1))
      perf += (1.0 * (readout[1]<0)).mean((0,1))

      return perf / 2.0
#+end_src

#+RESULTS:

#+begin_src ipython
  def get_avg_phi(centers):
      x_c1, y_c1 = centers[0]
      x_c2, y_c2 = centers[1]

      radius = np.sqrt(x_c1**2 + y_c1**2)

      # Midpoint M of A and B
      xM, yM = (x_c1 + x_c2) / 2, (y_c1 + y_c2) / 2

      phi1 = np.arctan2(y_c1, x_c1)
      phi2 = np.arctan2(y_c2, x_c2)

      phi0 = ( (phi1 + phi2) / 2 ) % (2 * np.pi)
      psi0 = (phi0 + np.pi) % (2 * np.pi)

      xPhi = radius * np.cos(phi0)
      yPhi = radius * np.sin(phi0)

      xPsi = radius * np.cos(psi0)
      yPsi = radius * np.sin(psi0)

      dist = [np.sqrt((xPhi - xM)**2 + (yPhi - yM)**2),
              np.sqrt((xPsi - xM)**2 + (yPsi - yM)**2)]

      if dist[0]>dist[1]:
          mean_phi = phi0
      else:
          mean_phi = psi0

      return mean_phi
#+end_src

#+RESULTS:

#+begin_src ipython
  from sklearn.cluster import KMeans
  kmeans = KMeans(n_clusters=2)

  def get_centers(x, y):
      data = np.stack((x,y)).T
      kmeans.fit(data)
      centers = kmeans.cluster_centers_

      return centers

  def get_coord(rates):
      m0, m1, phi = decode_bump_torch(rates, axis=-1)

      x = m1 / m0 * torch.cos(phi)
      y = m1 / m0 * torch.sin(phi)

      return x.real, y.real
#+end_src

#+RESULTS:

* Dual task with rotating readout
** Parameters

#+begin_src ipython
   REPO_ROOT = "/home/leon/models/NeuroFlame"
   conf_name = "config_EI.yml"

   n_ini  = 32

   LR_COV = [[1.0, 1.0, 0.0, 0.0],
             [0.8, 1.0, 0.0, 0.0],
             [0.0, 0.0, 1.0, 0.8],
             [0.0, 0.0, 0.8, 1.0]]

   device = 'cuda'
#+end_src

#+RESULTS:

** Fixed Points
*** Simulation

#+begin_src ipython
  start = perf_counter()

  rates_fp = []
  rates_list = []
  rates_cr_list = []

  perf_list = []
  perf_cr_list = []

  distance_list = []
  centers_list = []
  phi0_list = []

  for i in range(20):
      seed = np.random.randint(10000)

      n_ini  = 32
      model = Network(conf_name, REPO_ROOT, VERBOSE=0, DEVICE=device,
                      N_BATCH=2*n_ini, SEED=seed, LR_COV=LR_COV,
                      TASK='dual_rand', LIVE_FF_UPDATE=1, DURATION=20)

      idx = get_idx(model)

      rates = model(REC_LAST_ONLY=1)[..., idx]
      rates_fp.append(rates)

      x, y = get_coord(rates)
      centers = get_centers(x.cpu().numpy(), y.cpu().numpy())
      mean_phi = get_avg_phi(centers)

      centers_list.append(centers)
      phi0_list.append(mean_phi)
      distance_list.append(np.linalg.norm(centers[0]-centers[1]))

      n_ini  = 32
      # model = Network(conf_name, REPO_ROOT, VERBOSE=0, DEVICE=device,
      #                 N_BATCH=2*n_ini, SEED=seed, LR_COV=LR_COV,
      #                 TASK='dual', LIVE_FF_UPDATE=1, DURATION=10, I0=[1.0, 1.0])

      model.TASK = 'dual'
      model.DURATION = 10
      model.N_STEPS = int(model.DURATION / model.DT) + model.N_STEADY + model.N_WINDOW
      model.I0 = [1.0, 1.0]

      rates = model()
      rates_list.append(rates[..., idx])
      perf_list.append(get_perf(model, rates, n_ini))

      # model = Network(conf_name, REPO_ROOT, VERBOSE=0, DEVICE=device,
      #                 N_BATCH=2*n_ini, SEED=seed, LR_COV=LR_COV,
      #                 TASK='dual_odr', LIVE_FF_UPDATE=1, DURATION=10, I0=[1.0, 1.0])

      model.TASK = 'dual_odr'
      model.PHI1 = torch.tensor([0, mean_phi], device=device)

      rates_cr = model()
      rates_cr_list.append(rates_cr[..., idx])

      perf_cr = get_perf_cr(rates_cr[..., idx], mean_phi, n_ini)
      perf_cr_list.append(perf_cr)

      del model

  end = perf_counter()

  print("Elapsed (with compilation) = %dh %dm %ds" % convert_seconds(end - start))

#+end_src

#+RESULTS:
: Elapsed (with compilation) = 0h 14m 34s

#+begin_src ipython
  print(mean_phi*180/np.pi)
#+end_src

#+RESULTS:
: 54.07276009282046

#+begin_src ipython
  rates_list = torch.stack(rates_list).cpu().numpy()
  rates_fp = torch.stack(rates_fp).cpu().numpy()
  rates_cr_list = torch.stack(rates_cr_list).cpu().numpy()
#+end_src

#+RESULTS:

#+begin_src ipython
  perf_list = torch.stack(perf_list).cpu().numpy()
  perf_cr_list = torch.stack(perf_cr_list).cpu().numpy()
#+end_src

#+RESULTS:

#+begin_src ipython
  centers_list = np.array(centers_list)
  distance_list = np.array(distance_list)
  phi0_list = np.array(phi0_list)
#+end_src

#+RESULTS:

*** plots

#+begin_src ipython
  def plot_ring(i, ax, color):
      ax.plot(x_cloud[i], y_cloud[i], 'o', alpha=.25, color=color)

      x_c1, y_c1 = centers_list[i, 0]
      x_c2, y_c2 = centers_list[i, 1]

      ax.plot(x_c1, y_c1, 'x', alpha=1, ms=20, color=color, lw=10)
      ax.plot(x_c2, y_c2, 'x', alpha=1, ms=20, color=color, lw=10)

      # plot separatrix
      x = 1.75 * np.cos(phi0_list[i])
      y = 1.75 * np.sin(phi0_list[i])

      # Draw an arrow using plt.arrow(x, y, dx, dy, **kwargs)
      plt.arrow(0, 0, x, y, head_width=0.25, head_length=0.25, fc=color)

      mean = np.array([phi0_list[i], phi0_list[i] - np.pi ])

      x = 1.75 * np.cos(mean)
      y = 1.75 * np.sin(mean)
      ax.plot(x, y, '--', color=color)

      ax.set_xlim([-2, 2])
      ax.set_ylim([-2, 2])
      ax.set_title('Fixed Points')
#+end_src

#+RESULTS:

#+begin_src ipython
  fig, ax = plt.subplots(1, 1, figsize=[height, height])

  m0, m1, phi = decode_bump(rates_fp, axis=-1)

  # plot clouds
  x_cloud = m1 / m0 * np.cos(phi)
  y_cloud = m1 / m0 * np.sin(phi)

  # plot centers
  for i in range(centers_list.shape[0]):
      color = np.random.rand(3,)
      plot_ring(i, ax, color)

  plt.show()
  #+end_src

  #+RESULTS:
  [[file:./.ob-jupyter/62c4333519819d8faf87d5a2f79b3001d3cc4244.png]]

#+begin_src ipython
  def plot_trajectory(rates, i, ax):
    m0, m1, phi = decode_bump(rates[i], axis=-1)

    x = m1 / m0 * np.cos(phi)
    y = m1 / m0 * np.sin(phi)

    xA = x[:n_ini]
    yA = y[:n_ini]

    ax.plot(xA.T[0], yA.T[0], 'xb', alpha=.25, ms=10)
    # ax.plot(xA.T, yA.T, '-b', alpha=.25)
    ax.plot(xA.T[-1], yA.T[-1], 'ob', alpha=.25, ms=10)

    xB = x[n_ini:]
    yB = y[n_ini:]

    ax.plot(xB.T[0], yB.T[0], 'xr', alpha=.25, ms=10)
    # ax.plot(x.T, y.T, '-r', alpha=.25)
    ax.plot(xB.T[-1], yB.T[-1], '*r', alpha=.25, ms=10)

    x_c1, y_c1 = centers_list[i, 0]
    x_c2, y_c2 = centers_list[i, 1]

    ax.plot(x_c1, y_c1, 'x', alpha=1, ms=20, color='k', lw=10)
    ax.plot(x_c2, y_c2, 'x', alpha=1, ms=20, color='k', lw=10)

    # plot separatrix
    x = 1.75 * np.cos(phi0_list[i])
    y = 1.75 * np.sin(phi0_list[i])

    # Draw an arrow using plt.arrow(x, y, dx, dy, **kwargs)
    plt.arrow(0, 0, x, y, head_width=0.25, head_length=0.25, fc='k')

    x = 1.75 * np.cos(phi0_list[i] + np.pi/2)
    y = 1.75 * np.sin(phi0_list[i] + np.pi/2)

    # Draw an arrow using plt.arrow(x, y, dx, dy, **kwargs)
    plt.arrow(0, 0, x, y, head_width=0.25, head_length=0.25, fc='b')

    mean = np.array([phi0_list[i], phi0_list[i] - np.pi ])

    x = 1.75 * np.cos(mean)
    y = 1.75 * np.sin(mean)
    ax.plot(x, y, '--', color='k')

    mean = np.array([phi0_list[i] + np.pi/2, phi0_list[i] - np.pi + np.pi/2])

    x = 1.75 * np.cos(mean)
    y = 1.75 * np.sin(mean)
    ax.plot(x, y, '--', color='b')

    ax.set_xlim([-2, 2])
    ax.set_ylim([-2, 2])

#+end_src

#+RESULTS:

#+begin_src ipython
  i = 0
  fig, ax = plt.subplots(1, 3, figsize=(3*height, height))

  plot_ring(i, ax[0], 'b')
  ax[0].set_title('Distance %.1f' % (distance_list[i] / 2))

  plot_trajectory(rates_list, i, ax[1])
  ax[1].set_title('Performance %.1f' % (perf_list[i] * 100))

  plot_trajectory(rates_cr_list, i, ax[2])
  ax[2].set_title('Performance %.1f' % (perf_cr_list[i]))

  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/82c8b64fd370e4f93c0003d05df3343ccc891671.png]]

#+begin_src ipython
  rates = rates_cr_list[i]
  # print(get_perf_cr(rates, phi0_list[i], n_ini))

  print(rates.shape)
  m0, m1, phi = decode_bump(rates, axis=-1)
  x = m1[..., -1] / m0[..., -1] * np.cos(phi[..., -1])
  y = m1[..., -1] / m0[..., -1] * np.sin(phi[..., -1])

  X = np.stack((x,y))
  print(X.shape)

  centers = centers_list[i]
  phi0 = phi0_list[i]

  x_c1, y_c1 = centers[0]
  x_c2, y_c2 = centers[1]

  # Midpoint M of A and B
  print(phi0)
  radius = np.sqrt(x_c1**2 + y_c1**2)
  xPhi =  np.cos(np.pi / 2 + phi0)
  yPhi =  np.sin(np.pi / 2 + phi0)

  vPhi = np.stack((xPhi, yPhi))
  print(vPhi.shape)

  dot = vPhi @ X

  A = np.stack([(dot[:n_ini]<0).sum(), (dot[:n_ini]>0).sum()])
  print('A perf', A)

  # print(dot[n_ini:])
  B = np.stack([(dot[n_ini:]>0).sum(), (dot[n_ini:]<0).sum()])
  print('B perf', B)

  perf = np.max(A + B) / X.shape[1] * 100

  # perf = (A + B) / 2 * 100
  print('performance', perf)
#+end_src

#+RESULTS:
: (64, 101, 2000)
: (2, 64)
: 3.427289756136485
: (2,)
: A perf [ 0 32]
: B perf [ 0 32]
: performance 100.0

*** performance

#+begin_src ipython
  print('dist', distance_list)
  print('perf_list',perf_list*100)
  print('perf_cr_list', perf_cr_list)
#+end_src

#+RESULTS:
: dist [1.8715259 2.7111084 1.1955316 2.8439548 2.3836904 2.6076121 2.1728323
:  2.4747825 2.79506   2.4765794 2.2945778 1.7466853 2.3865876 2.8042555
:  2.7227674 2.4310265 2.8928723 2.5577729 2.1913402 2.0672505]
: perf_list [ 58.75    50.      50.      96.875  100.      50.      81.5625  41.5625
:   50.9375  50.      50.      43.75    13.4375  50.      96.875   48.75
:   74.375   50.625   55.625   50.    ]
: perf_cr_list [100.     100.      50.      90.625   85.9375  92.1875  75.      50.
:   50.      59.375   53.125   98.4375  51.5625  50.      67.1875  50.
:  100.      50.      50.      50.    ]

#+begin_src ipython
  fig, ax = plt.subplots(1, 2, figsize=[2 * width, height])

  ax[0].hist(distance_list / 2 / radius, density=True)
  ax[0].set_xlabel('Distance')
  ax[0].set_ylabel('Density')

  ax[1].hist(phi0_list * 180 / np.pi, density='True')
  ax[1].set_xlabel('Location (°)')
  ax[1].set_ylabel('Density')

  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/6d1b14b53c425832efee4e8477275b61de2c523a.png]]


#+begin_src ipython
  window = 3

  fig, ax = plt.subplots(1, 2, figsize=[2 * width, height])

  idx = distance_list.argsort()

  ax[0].plot(distance_list[idx] / 2 / radius, circcvl(perf_list[idx]*100, window), '-ob')
  ax[0].plot(distance_list[idx] / 2 / radius, circcvl(perf_cr_list[idx], window), '-or')
  ax[0].set_xlabel('Distance')
  ax[0].set_ylabel('Performance')

  idx = phi0_list.argsort()

  ax[1].plot(phi0_list[idx] * 180 / np.pi, circcvl(perf_list[idx]*100, window), '-ob', label='uncorrected')
  ax[1].plot(phi0_list[idx] * 180 / np.pi, circcvl(perf_cr_list[idx], window), '-or', label='corrected')
  ax[1].set_xticks(np.linspace(0, 360, 5))
  ax[1].set_xlabel('Readout Location (°)')
  ax[1].set_ylabel('Performance')
  ax[1].legend(frameon=0, fontsize=14, loc='best')

  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/6318725dedd7446d13b5b5d0193ef94480a3b802.png]]

#+begin_src ipython

#+end_src

#+RESULTS:
