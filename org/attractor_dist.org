#+STARTUP: fold
#+TITLE: Dual Task Readout Rotation
#+PROPERTY: header-args:ipython :results both :exports both :async yes :session dist :kernel torch

* Notebook Settings

#+begin_src ipython
  %load_ext autoreload
  %autoreload 2
  %reload_ext autoreload

  %run ../notebooks/setup.py
  %matplotlib inline
  %config InlineBackend.figure_format = 'png'
#+end_src

#+RESULTS:
: The autoreload extension is already loaded. To reload it, use:
:   %reload_ext autoreload
: Python exe
: /home/leon/mambaforge/envs/torch/bin/python

* Imports

#+begin_src ipython
  import sys
  sys.path.insert(0, '../')

  import torch
  import gc
  import pandas as pd
  from time import perf_counter

  from src.network import Network
  from src.plot_utils import plot_con
  from src.decode import decode_bump, decode_bump_torch, circcvl
  from src.utils import clear_cache

  from sklearn.cluster import KMeans
  kmeans = KMeans(n_clusters=2)
#+end_src

#+RESULTS:

* Helpers

#+begin_src ipython
  def convert_seconds(seconds):
      h = seconds // 3600
      m = (seconds % 3600) // 60
      s = seconds % 60
      return h, m, s
#+end_src

#+RESULTS:

#+begin_src ipython 
  import numpy as np
  def get_theta(a, b, GM=0, IF_NORM=0):

      u, v = a, b

      if GM:
          v = b - np.dot(b, a) / np.dot(a, a) * a

      if IF_NORM:
          u = a / np.linalg.norm(a)
          v = b / np.linalg.norm(b)

      return np.arctan2(v, u)
#+end_src

#+RESULTS:

#+begin_src ipython 
  def get_idx(model):
      ksi = model.PHI0.cpu().detach().numpy()
      theta = get_theta(ksi[0], ksi[2], GM=0, IF_NORM=0)
      return theta.argsort()
#+end_src

#+RESULTS:

#+begin_src ipython 
  def get_overlap(model, rates):
      return rates @ model.PHI0.T / rates.shape[-1]
#+end_src

#+RESULTS:

#+begin_src ipython
  def get_perf_cr(rates, phi0, n_ini):
      m0, m1, phi = decode_bump_torch(rates, axis=-1)

      x = m1[..., -1] / m0[..., -1] * torch.cos(phi[..., -1])
      y = m1[..., -1] / m0[..., -1] * torch.sin(phi[..., -1])

      X = torch.stack((x,y))

      xPhi = torch.cos(torch.pi / 2 + torch.tensor(phi0) * torch.pi / 180)
      yPhi = torch.sin(torch.pi / 2 + torch.tensor(phi0) * torch.pi / 180)
      vPhi = torch.stack((xPhi, yPhi))

      dot = vPhi.to(X.device).to(X.dtype) @ X

      # if phi0 > 0 and phi0 < 180:
      #     dot = dot * -1
      
      # print(dot[:n_ini])
      A = torch.stack([(dot[:n_ini]<0).sum(), (dot[:n_ini]>0).sum()])
      # print('A perf', A)

      # print(dot[n_ini:])
      B = torch.stack([(dot[n_ini:]>0).sum(), (dot[n_ini:]<0).sum()])
      # print('B perf', B)

      perf = torch.max(A + B) / X.shape[1] * 100

      return perf
#+end_src

#+RESULTS:

#+begin_src ipython
  def get_perf(model, rates, n_ini):
      overlap = get_overlap(model, rates)
      
      readoutA = overlap[:n_ini, -5:, 0]
      readoutB = overlap[n_ini:, -5:, 0]

      readout = torch.stack((readoutA, readoutB))

      perf = (1.0 * (readout[0]>0)).mean((0, 1))
      perf += (1.0 * (readout[1]<0)).mean((0,1))

      return perf / 2.0
#+end_src

#+RESULTS:

#+begin_src ipython
  def get_avg_phi(centers):
      x_c1, y_c1 = centers[0]
      x_c2, y_c2 = centers[1]
      
      radius = np.sqrt(x_c1**2 + y_c1**2)

      # Midpoint M of A and B
      xM, yM = (x_c1 + x_c2) / 2, (y_c1 + y_c2) / 2

      phi1 = np.arctan2(y_c1, x_c1)
      phi2 = np.arctan2(y_c2, x_c2)

      phi0 = ( (phi1 + phi2) / 2 ) % np.pi
      psi0 = (phi0 + np.pi) % (2 * np.pi)

      xPhi = radius * np.cos(phi0)
      yPhi = radius * np.sin(phi0)

      xPsi = radius * np.cos(psi0)
      yPsi = radius * np.sin(psi0)

      dist = [np.sqrt((xPhi - xM)**2 + (yPhi - yM)**2),
              np.sqrt((xPsi - xM)**2 + (yPsi - yM)**2)]

      if dist[0]>dist[1]:
          mean_phi = phi0 * 180 / np.pi
      else:
          mean_phi = psi0 * 180 / np.pi

      return mean_phi
#+end_src

#+RESULTS:

#+begin_src ipython
  from sklearn.cluster import KMeans
  kmeans = KMeans(n_clusters=2)

  def get_centers(x, y):
      data = np.stack((x,y)).T
      kmeans.fit(data)
      centers = kmeans.cluster_centers_

      return centers

  def get_coord(rates):
      m0, m1, phi = decode_bump_torch(rates, axis=-1)

      x = m1 / m0 * torch.cos(phi)
      y = m1 / m0 * torch.sin(phi)

      return x.real, y.real
#+end_src

#+RESULTS:

* Dual task with rotating readout
** Parameters

#+begin_src ipython
  REPO_ROOT = "/home/leon/models/NeuroTorch"
  conf_name = "config_EI.yml"
  name = "low_rank_ini"

  n_ini  = 32

  LR_COV = [[1.0, 0.8, 0.0, 0.0],
            [0.8, 1.0, 0.0, 0.0],
            [0.0, 0.0, 1.0, 0.8],
            [0.0, 0.0, 0.8, 1.0]]
  
#+end_src

#+RESULTS:

** Fixed Points
*** Simulation

#+begin_src ipython
  start = perf_counter()

  rates_fp = []
  rates_list = []
  rates_cr_list = []

  perf_list = []
  perf_cr_list = []

  distance_list = []
  centers_list = []
  phi0_list = []

  for i in range(10):
      seed = np.random.randint(10000)

      n_ini  = 50
      model = Network(conf_name, name, REPO_ROOT, VERBOSE=0, DEVICE='cuda:1',
                      N_BATCH=2*n_ini, SEED=seed, LR_COV=LR_COV,
                      TASK='dual_rand', LIVE_FF_UPDATE=1, DURATION=30)

      idx = get_idx(model)

      rates = model(REC_LAST_ONLY=1)[..., idx]
      rates_fp.append(rates)

      x, y = get_coord(rates)
      centers = get_centers(x.cpu().numpy(), y.cpu().numpy())
      mean_phi = get_avg_phi(centers)

      centers_list.append(centers)
      phi0_list.append(mean_phi)
      distance_list.append(np.linalg.norm(centers[0]-centers[1]))

      n_ini  = 32
      model = Network(conf_name, name, REPO_ROOT, VERBOSE=0, DEVICE='cuda:1',
                      N_BATCH=2*n_ini, SEED=seed, LR_COV=LR_COV,
                      TASK='dual', LIVE_FF_UPDATE=1, DURATION=10)

      # model.TASK = 'dual'
      # model.DURATION = 10
      # model.N_STEPS = int(model.DURATION / model.DT) + model.N_STEADY + model.N_WINDOW

      rates = model()
      rates_list.append(rates[..., idx])
      perf_list.append(get_perf(model, rates, n_ini))

      # model.PHI1 = torch.tensor([0, 180-mean_phi], device='cuda:1')
      # model.TASK = 'dual_odr'

      model = Network(conf_name, name, REPO_ROOT, VERBOSE=0, DEVICE='cuda:1',
                      N_BATCH=2*n_ini, SEED=seed, LR_COV=LR_COV,
                      TASK='dual_odr', LIVE_FF_UPDATE=1, DURATION=10)

      rates_cr = model()
      rates_cr_list.append(rates_cr[..., idx])
      
      perf_cr = get_perf_cr(rates_cr[..., idx], mean_phi, n_ini)
      perf_cr_list.append(perf_cr)

      del model

  end = perf_counter()

  print("Elapsed (with compilation) = %dh %dm %ds" % convert_seconds(end - start))

#+end_src

#+RESULTS:
: 0931504a-9206-4184-9fb4-9f66f0e1ffcc

#+begin_src ipython
  rates_list = torch.stack(rates_list).cpu().numpy()
  rates_fp = torch.stack(rates_fp).cpu().numpy()
  rates_cr_list = torch.stack(rates_cr_list).cpu().numpy()
#+end_src

#+RESULTS:
: 778af4ee-cf18-4590-b10a-6531be3cab58

#+begin_src ipython
  perf_list = torch.stack(perf_list).cpu().numpy()
  perf_cr_list = torch.stack(perf_cr_list).cpu().numpy()
#+end_src

#+RESULTS:
: 3fc50d0b-f6b6-47c8-a288-11c7401452e1

#+begin_src ipython
  centers_list = np.array(centers_list)
  distance_list = np.array(distance_list)
  phi0_list = np.array(phi0_list)
#+end_src

#+RESULTS:
: 7249b012-f294-4cdd-8ce9-a20aadc48e28

*** plots

#+begin_src ipython
  def plot_ring(i, ax, color):
      ax.plot(x_cloud[i], y_cloud[i], 'o', alpha=.25, color=color)

      x_c1, y_c1 = centers_list[i, 0]
      x_c2, y_c2 = centers_list[i, 1]

      ax.plot(x_c1, y_c1, 'x', alpha=1, ms=20, color=color, lw=10)
      ax.plot(x_c2, y_c2, 'x', alpha=1, ms=20, color=color, lw=10)

      # plot separatrix
      x = 1.75 * np.cos(phi0_list[i] * np.pi / 180)
      y = 1.75 * np.sin(phi0_list[i] * np.pi / 180)

      # Draw an arrow using plt.arrow(x, y, dx, dy, **kwargs)
      plt.arrow(0, 0, x, y, head_width=0.25, head_length=0.25, fc=color)

      mean = np.array([phi0_list[i], phi0_list[i] - 180 ]) * np.pi/180

      x = 1.75 * np.cos(mean)
      y = 1.75 * np.sin(mean)
      ax.plot(x, y, '--', color=color)

      ax.set_xlim([-2, 2])
      ax.set_ylim([-2, 2])
      ax.set_title('Fixed Points')
#+end_src

#+RESULTS:
: 4ca94923-f3ec-44d7-a1bf-57d5831eef60

#+begin_src ipython
  fig, ax = plt.subplots(1, 1, figsize=[height, height])

  m0, m1, phi = decode_bump(rates_fp, axis=-1)

  # plot clouds
  x_cloud = m1 / m0 * np.cos(phi)
  y_cloud = m1 / m0 * np.sin(phi)

  # plot centers
  for i in range(centers_list.shape[0]):      
      color = np.random.rand(3,)
      plot_ring(i, ax, color)
      
  plt.show()
  #+end_src

  #+RESULTS:
  : 2272cf1f-6763-4d15-95ca-d5db1fc54b24

#+begin_src ipython
  def plot_trajectory(rates, i, ax):
    m0, m1, phi = decode_bump(rates[i], axis=-1)

    x = m1 / m0 * np.cos(phi)
    y = m1 / m0 * np.sin(phi)

    xA = x[:n_ini]
    yA = y[:n_ini]

    ax.plot(xA.T[0], yA.T[0], 'xb', alpha=.25, ms=10)
    # ax.plot(xA.T, yA.T, '-b', alpha=.25)
    ax.plot(xA.T[-1], yA.T[-1], 'ob', alpha=.25, ms=10)

    xB = x[n_ini:]
    yB = y[n_ini:]

    ax.plot(xB.T[0], yB.T[0], 'xr', alpha=.25, ms=10)
    # ax.plot(x.T, y.T, '-r', alpha=.25)
    ax.plot(xB.T[-1], yB.T[-1], '*r', alpha=.25, ms=10)

    x_c1, y_c1 = centers_list[i, 0]
    x_c2, y_c2 = centers_list[i, 1]

    ax.plot(x_c1, y_c1, 'x', alpha=1, ms=20, color='k', lw=10)
    ax.plot(x_c2, y_c2, 'x', alpha=1, ms=20, color='k', lw=10)

    # plot separatrix
    x = 1.75 * np.cos(phi0_list[i] * np.pi / 180)
    y = 1.75 * np.sin(phi0_list[i] * np.pi / 180)

    # Draw an arrow using plt.arrow(x, y, dx, dy, **kwargs)
    plt.arrow(0, 0, x, y, head_width=0.25, head_length=0.25, fc='k')

    x = 1.75 * np.cos(phi0_list[i] * np.pi / 180 + np.pi/2)
    y = 1.75 * np.sin(phi0_list[i] * np.pi / 180 + np.pi/2)

    # Draw an arrow using plt.arrow(x, y, dx, dy, **kwargs)
    plt.arrow(0, 0, x, y, head_width=0.25, head_length=0.25, fc='b')

    mean = np.array([phi0_list[i], phi0_list[i] - 180 ]) * np.pi/180

    x = 1.75 * np.cos(mean)
    y = 1.75 * np.sin(mean)
    ax.plot(x, y, '--', color='k')

    mean = np.array([phi0_list[i] + 90, phi0_list[i] - 180 + 90]) * np.pi/180

    x = 1.75 * np.cos(mean)
    y = 1.75 * np.sin(mean)
    ax.plot(x, y, '--', color='b')


    ax.set_xlim([-2, 2])
    ax.set_ylim([-2, 2])

#+end_src

#+RESULTS:
: 4de0fc48-7f45-4759-9f3d-b3190a339b13

#+begin_src ipython
  i = 4
  fig, ax = plt.subplots(1, 3, figsize=(3*height, height))

  plot_ring(i, ax[0], 'b')
  ax[0].set_title('Distance %.1f' % (distance_list[i] / 2))

  plot_trajectory(rates_list, i, ax[1])
  ax[1].set_title('Performance %.1f' % (perf_list[i] * 100))

  plot_trajectory(rates_cr_list, i, ax[2])
  ax[2].set_title('Performance %.1f' % (perf_cr_list[i]))

  plt.show()
#+end_src

#+RESULTS:
: b4f595cb-c904-4d95-b619-f75426793ef2

#+begin_src ipython 
  rates = rates_cr_list[i]
  # print(get_perf_cr(rates, phi0_list[i], n_ini))

  print(rates.shape)
  m0, m1, phi = decode_bump(rates, axis=-1)
  x = m1[..., -1] / m0[..., -1] * np.cos(phi[..., -1])
  y = m1[..., -1] / m0[..., -1] * np.sin(phi[..., -1])

  X = np.stack((x,y))
  print(X.shape)

  centers = centers_list[i]
  phi0 = phi0_list[i]

  x_c1, y_c1 = centers[0]
  x_c2, y_c2 = centers[1]

  # Midpoint M of A and B
  print(phi0)
  # radius = np.sqrt(x_c1**2 + y_c1**2)
  xPhi =  np.cos(np.pi / 2 + phi0 * np.pi / 180)
  yPhi =  np.sin(np.pi / 2 + phi0 * np.pi / 180)

  vPhi = np.stack((xPhi, yPhi))
  print(vPhi.shape)

  dot = vPhi @ X

  A = np.stack([(dot[:n_ini]<0).sum(), (dot[:n_ini]>0).sum()])
  print('A perf', A)

  # print(dot[n_ini:])
  B = np.stack([(dot[n_ini:]>0).sum(), (dot[n_ini:]<0).sum()])
  print('B perf', B)

  perf = np.max(A + B) / X.shape[1] * 100

  # perf = (A + B) / 2 * 100
  print('performance', perf)
#+end_src

#+RESULTS:
: 044369fb-a21e-4997-a523-5ec90375f0e4

*** performance

#+begin_src ipython
  print('dist', distance_list)
  print('perf_list',perf_list*100)
  print('perf_cr_list', perf_cr_list)
#+end_src

#+RESULTS:
: 5988530c-5686-4f8a-9310-1fac10c9c543

#+begin_src ipython
  idx = distance_list.argsort()
  plt.plot(distance_list[idx]/2, circcvl(perf_list[idx]*100, 2), '-ob')
  plt.plot(distance_list[idx]/2, circcvl(perf_cr_list[idx], 2), '-or')
  plt.xlabel('Distance')
  plt.ylabel('Performance')
  plt.show()
#+end_src

#+RESULTS:
: d893d690-4d79-43c6-8838-559ba76f1159

#+begin_src ipython
  idx = phi0_list.argsort()
  plt.plot(phi0_list[idx], circcvl(perf_list[idx]*100, 2), '-ob')
  plt.plot(phi0_list[idx], circcvl(perf_cr_list[idx], 2), '-or')

  plt.xticks(np.linspace(0, 360, 5))
  plt.xlabel('Readout Location (Â°)')
  plt.ylabel('Performance')
  plt.show()
#+end_src

#+RESULTS:
: 3bc97d4f-9fbb-4c60-b21d-95cd6554261f

#+begin_src ipython

#+end_src

#+RESULTS:
: c39abad0-ec72-4335-b277-0bf4f958f454
