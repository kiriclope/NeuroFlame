#+STARTUP: fold
#+TITLE: Dual Task Readout Rotation
#+PROPERTY: header-args:ipython :results both :exports both :async yes :session dist :kernel torch

* Notebook Settings

#+begin_src ipython
  %load_ext autoreload
  %autoreload 2
  %reload_ext autoreload

  %run ../notebooks/setup.py
  %matplotlib inline
  %config InlineBackend.figure_format = 'png'
#+end_src

#+RESULTS:
: The autoreload extension is already loaded. To reload it, use:
:   %reload_ext autoreload
: Python exe
: /home/leon/mambaforge/envs/torch/bin/python

* Imports

#+begin_src ipython
  import sys
  sys.path.insert(0, '../')

  import torch
  import gc
  import pandas as pd
  from time import perf_counter

  from src.network import Network
  from src.plot_utils import plot_con
  from src.decode import decode_bump, decode_bump_torch, circcvl
  from src.utils import clear_cache

  from sklearn.cluster import KMeans
  kmeans = KMeans(n_clusters=2)
#+end_src

#+RESULTS:

* Helpers

#+begin_src ipython
  def convert_seconds(seconds):
      h = seconds // 3600
      m = (seconds % 3600) // 60
      s = seconds % 60
      return h, m, s
#+end_src

#+RESULTS:

#+begin_src ipython 
  import numpy as np
  def get_theta(a, b, GM=0, IF_NORM=0):

      u, v = a, b

      if GM:
          v = b - np.dot(b, a) / np.dot(a, a) * a

      if IF_NORM:
          u = a / np.linalg.norm(a)
          v = b / np.linalg.norm(b)

      return np.arctan2(v, u)
#+end_src

#+RESULTS:

#+begin_src ipython 
  def get_idx(model):
      ksi = model.PHI0.cpu().detach().numpy()
      theta = get_theta(ksi[0], ksi[2], GM=0, IF_NORM=0)
      return theta.argsort()
#+end_src

#+RESULTS:

#+begin_src ipython 
  def get_overlap(model, rates):
      return rates @ model.PHI0.T / rates.shape[-1]
#+end_src

#+RESULTS:

#+begin_src ipython
  def get_perf_cr(rates, phi0, n_ini):
      m0, m1, phi = decode_bump_torch(rates, axis=-1)

      x = m1[..., -1] / m0[..., -1] * torch.cos(phi[..., -1])
      y = m1[..., -1] / m0[..., -1] * torch.sin(phi[..., -1])

      X = torch.stack((x,y))

      xPhi = torch.cos(torch.pi / 2 + torch.tensor(phi0) * torch.pi / 180)
      yPhi = torch.sin(torch.pi / 2 + torch.tensor(phi0) * torch.pi / 180)
      vPhi = torch.stack((xPhi, yPhi))

      dot = vPhi.to(X.device).to(X.dtype) @ X

      # if phi0 > 0 and phi0 < 180:
      #     dot = dot * -1
      
      # print(dot[:n_ini])
      A = torch.stack([(dot[:n_ini]<0).sum(), (dot[:n_ini]>0).sum()])
      # print('A perf', A)

      # print(dot[n_ini:])
      B = torch.stack([(dot[n_ini:]>0).sum(), (dot[n_ini:]<0).sum()])
      # print('B perf', B)

      perf = torch.max(A + B) / X.shape[1] * 100

      return perf
#+end_src

#+RESULTS:

#+begin_src ipython
  def get_perf(model, rates, n_ini):
      overlap = get_overlap(model, rates)
      
      readoutA = overlap[:n_ini, -5:, 0]
      readoutB = overlap[n_ini:, -5:, 0]

      readout = torch.stack((readoutA, readoutB))

      perf = (1.0 * (readout[0]>0)).mean((0, 1))
      perf += (1.0 * (readout[1]<0)).mean((0,1))

      return perf / 2.0
#+end_src

#+RESULTS:

#+begin_src ipython
  def get_avg_phi(centers):
      x_c1, y_c1 = centers[0]
      x_c2, y_c2 = centers[1]
      
      radius = np.sqrt(x_c1**2 + y_c1**2)

      # Midpoint M of A and B
      xM, yM = (x_c1 + x_c2) / 2, (y_c1 + y_c2) / 2

      phi1 = np.arctan2(y_c1, x_c1)
      phi2 = np.arctan2(y_c2, x_c2)

      phi0 = ( (phi1 + phi2) / 2 ) % np.pi
      psi0 = (phi0 + np.pi) % (2 * np.pi)

      xPhi = radius * np.cos(phi0)
      yPhi = radius * np.sin(phi0)

      xPsi = radius * np.cos(psi0)
      yPsi = radius * np.sin(psi0)

      dist = [np.sqrt((xPhi - xM)**2 + (yPhi - yM)**2),
              np.sqrt((xPsi - xM)**2 + (yPsi - yM)**2)]

      if dist[0]>dist[1]:
          mean_phi = phi0 * 180 / np.pi
      else:
          mean_phi = psi0 * 180 / np.pi

      return mean_phi
#+end_src

#+RESULTS:

#+begin_src ipython
  from sklearn.cluster import KMeans
  kmeans = KMeans(n_clusters=2)

  def get_centers(x, y):
      data = np.stack((x,y)).T
      kmeans.fit(data)
      centers = kmeans.cluster_centers_

      return centers

  def get_coord(rates):
      m0, m1, phi = decode_bump_torch(rates, axis=-1)

      x = m1 / m0 * torch.cos(phi)
      y = m1 / m0 * torch.sin(phi)

      return x.real, y.real
#+end_src

#+RESULTS:

* Dual task with rotating readout
** Parameters

#+begin_src ipython
  REPO_ROOT = "/home/leon/models/NeuroTorch"
  conf_name = "config_EI.yml"
  name = "low_rank_ini"

  n_ini  = 32
  
  LR_COV = [[1.0, 1.0, 0.0, 0.0],
            [0.8, 1.0, 0.0, 0.0],
            [0.0, 0.0, 1.0, 0.8],
            [0.0, 0.0, 0.8, 1.0]]

#+end_src

#+RESULTS:

** Fixed Points
*** Simulation

#+begin_src ipython
  start = perf_counter()

  rates_fp = []
  rates_list = []
  rates_cr_list = []

  perf_list = []
  perf_cr_list = []

  distance_list = []
  centers_list = []
  phi0_list = []
  
  for i in range(100):
      seed = np.random.randint(10000)

      n_ini  = 50
      model = Network(conf_name, name, REPO_ROOT, VERBOSE=0, DEVICE='cuda:1',
                      N_BATCH=2*n_ini, SEED=seed, LR_COV=LR_COV,
                      TASK='dual_rand', LIVE_FF_UPDATE=1, DURATION=30)

      idx = get_idx(model)

      rates = model(REC_LAST_ONLY=1)[..., idx]
      rates_fp.append(rates)

      x, y = get_coord(rates)
      centers = get_centers(x.cpu().numpy(), y.cpu().numpy())
      mean_phi = get_avg_phi(centers)

      centers_list.append(centers)
      phi0_list.append(mean_phi)
      distance_list.append(np.linalg.norm(centers[0]-centers[1]))

      n_ini  = 32
      model = Network(conf_name, name, REPO_ROOT, VERBOSE=0, DEVICE='cuda:1',
                      N_BATCH=2*n_ini, SEED=seed, LR_COV=LR_COV,
                      TASK='dual', LIVE_FF_UPDATE=1, DURATION=10, I0=[0.2, 0.2])

      # model.TASK = 'dual'
      # model.DURATION = 10
      # model.N_STEPS = int(model.DURATION / model.DT) + model.N_STEADY + model.N_WINDOW

      rates = model()
      rates_list.append(rates[..., idx])
      perf_list.append(get_perf(model, rates, n_ini))

      # model.PHI1 = torch.tensor([0, 180-mean_phi], device='cuda:1')
      # model.TASK = 'dual_odr'

      model = Network(conf_name, name, REPO_ROOT, VERBOSE=0, DEVICE='cuda:1',
                      N_BATCH=2*n_ini, SEED=seed, LR_COV=LR_COV,
                      TASK='dual_odr', LIVE_FF_UPDATE=1, DURATION=10, I0=[0.2, 0.2])

      rates_cr = model()
      rates_cr_list.append(rates_cr[..., idx])

      perf_cr = get_perf_cr(rates_cr[..., idx], mean_phi, n_ini)
      perf_cr_list.append(perf_cr)

      del model

  end = perf_counter()

  print("Elapsed (with compilation) = %dh %dm %ds" % convert_seconds(end - start))

#+end_src

#+RESULTS:
: Elapsed (with compilation) = 0h 45m 48s

#+begin_src ipython
  rates_list = torch.stack(rates_list).cpu().numpy()
  rates_fp = torch.stack(rates_fp).cpu().numpy()
  rates_cr_list = torch.stack(rates_cr_list).cpu().numpy()
#+end_src

#+RESULTS:

#+begin_src ipython
  perf_list = torch.stack(perf_list).cpu().numpy()
  perf_cr_list = torch.stack(perf_cr_list).cpu().numpy()
#+end_src

#+RESULTS:

#+begin_src ipython
  centers_list = np.array(centers_list)
  distance_list = np.array(distance_list)
  phi0_list = np.array(phi0_list)
#+end_src

#+RESULTS:

*** plots

#+begin_src ipython
  def plot_ring(i, ax, color):
      ax.plot(x_cloud[i], y_cloud[i], 'o', alpha=.25, color=color)

      x_c1, y_c1 = centers_list[i, 0]
      x_c2, y_c2 = centers_list[i, 1]

      ax.plot(x_c1, y_c1, 'x', alpha=1, ms=20, color=color, lw=10)
      ax.plot(x_c2, y_c2, 'x', alpha=1, ms=20, color=color, lw=10)

      # plot separatrix
      x = 1.75 * np.cos(phi0_list[i] * np.pi / 180)
      y = 1.75 * np.sin(phi0_list[i] * np.pi / 180)

      # Draw an arrow using plt.arrow(x, y, dx, dy, **kwargs)
      plt.arrow(0, 0, x, y, head_width=0.25, head_length=0.25, fc=color)

      mean = np.array([phi0_list[i], phi0_list[i] - 180 ]) * np.pi/180

      x = 1.75 * np.cos(mean)
      y = 1.75 * np.sin(mean)
      ax.plot(x, y, '--', color=color)

      ax.set_xlim([-2, 2])
      ax.set_ylim([-2, 2])
      ax.set_title('Fixed Points')
#+end_src

#+RESULTS:

#+begin_src ipython
  fig, ax = plt.subplots(1, 1, figsize=[height, height])

  m0, m1, phi = decode_bump(rates_fp, axis=-1)

  # plot clouds
  x_cloud = m1 / m0 * np.cos(phi)
  y_cloud = m1 / m0 * np.sin(phi)

  # plot centers
  for i in range(centers_list.shape[0]):      
      color = np.random.rand(3,)
      plot_ring(i, ax, color)
      
  plt.show()
  #+end_src

  #+RESULTS:
  [[file:./.ob-jupyter/b688ec2c63861ec777fc36fbe0f8a042be3bcf7d.png]]

#+begin_src ipython
  def plot_trajectory(rates, i, ax):
    m0, m1, phi = decode_bump(rates[i], axis=-1)

    x = m1 / m0 * np.cos(phi)
    y = m1 / m0 * np.sin(phi)

    xA = x[:n_ini]
    yA = y[:n_ini]

    ax.plot(xA.T[0], yA.T[0], 'xb', alpha=.25, ms=10)
    # ax.plot(xA.T, yA.T, '-b', alpha=.25)
    ax.plot(xA.T[-1], yA.T[-1], 'ob', alpha=.25, ms=10)

    xB = x[n_ini:]
    yB = y[n_ini:]

    ax.plot(xB.T[0], yB.T[0], 'xr', alpha=.25, ms=10)
    # ax.plot(x.T, y.T, '-r', alpha=.25)
    ax.plot(xB.T[-1], yB.T[-1], '*r', alpha=.25, ms=10)

    x_c1, y_c1 = centers_list[i, 0]
    x_c2, y_c2 = centers_list[i, 1]

    ax.plot(x_c1, y_c1, 'x', alpha=1, ms=20, color='k', lw=10)
    ax.plot(x_c2, y_c2, 'x', alpha=1, ms=20, color='k', lw=10)

    # plot separatrix
    x = 1.75 * np.cos(phi0_list[i] * np.pi / 180)
    y = 1.75 * np.sin(phi0_list[i] * np.pi / 180)

    # Draw an arrow using plt.arrow(x, y, dx, dy, **kwargs)
    plt.arrow(0, 0, x, y, head_width=0.25, head_length=0.25, fc='k')

    x = 1.75 * np.cos(phi0_list[i] * np.pi / 180 + np.pi/2)
    y = 1.75 * np.sin(phi0_list[i] * np.pi / 180 + np.pi/2)

    # Draw an arrow using plt.arrow(x, y, dx, dy, **kwargs)
    plt.arrow(0, 0, x, y, head_width=0.25, head_length=0.25, fc='b')

    mean = np.array([phi0_list[i], phi0_list[i] - 180 ]) * np.pi/180

    x = 1.75 * np.cos(mean)
    y = 1.75 * np.sin(mean)
    ax.plot(x, y, '--', color='k')

    mean = np.array([phi0_list[i] + 90, phi0_list[i] - 180 + 90]) * np.pi/180

    x = 1.75 * np.cos(mean)
    y = 1.75 * np.sin(mean)
    ax.plot(x, y, '--', color='b')


    ax.set_xlim([-2, 2])
    ax.set_ylim([-2, 2])

#+end_src

#+RESULTS:

#+begin_src ipython
  i = 4
  fig, ax = plt.subplots(1, 3, figsize=(3*height, height))

  plot_ring(i, ax[0], 'b')
  ax[0].set_title('Distance %.1f' % (distance_list[i] / 2))

  plot_trajectory(rates_list, i, ax[1])
  ax[1].set_title('Performance %.1f' % (perf_list[i] * 100))

  plot_trajectory(rates_cr_list, i, ax[2])
  ax[2].set_title('Performance %.1f' % (perf_cr_list[i]))

  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/1587bf454ad3bdcc5db2e4cf78f958e12c90bedf.png]]

#+begin_src ipython 
  rates = rates_cr_list[i]
  # print(get_perf_cr(rates, phi0_list[i], n_ini))

  print(rates.shape)
  m0, m1, phi = decode_bump(rates, axis=-1)
  x = m1[..., -1] / m0[..., -1] * np.cos(phi[..., -1])
  y = m1[..., -1] / m0[..., -1] * np.sin(phi[..., -1])

  X = np.stack((x,y))
  print(X.shape)

  centers = centers_list[i]
  phi0 = phi0_list[i]

  x_c1, y_c1 = centers[0]
  x_c2, y_c2 = centers[1]

  # Midpoint M of A and B
  print(phi0)
  # radius = np.sqrt(x_c1**2 + y_c1**2)
  xPhi =  np.cos(np.pi / 2 + phi0 * np.pi / 180)
  yPhi =  np.sin(np.pi / 2 + phi0 * np.pi / 180)

  vPhi = np.stack((xPhi, yPhi))
  print(vPhi.shape)

  dot = vPhi @ X

  A = np.stack([(dot[:n_ini]<0).sum(), (dot[:n_ini]>0).sum()])
  print('A perf', A)

  # print(dot[n_ini:])
  B = np.stack([(dot[n_ini:]>0).sum(), (dot[n_ini:]<0).sum()])
  print('B perf', B)

  perf = np.max(A + B) / X.shape[1] * 100

  # perf = (A + B) / 2 * 100
  print('performance', perf)
#+end_src

#+RESULTS:
: (64, 101, 2000)
: (2, 64)
: 350.55975649150446
: (2,)
: A perf [ 3 29]
: B perf [31  1]
: performance 53.125

*** performance

#+begin_src ipython
  print('dist', distance_list)
  print('perf_list',perf_list*100)
  print('perf_cr_list', perf_cr_list)
#+end_src

#+RESULTS:
#+begin_example
  dist [2.5422373  1.5583098  1.4090744  2.4617333  1.783738   2.543086
   2.336324   2.398269   2.1371472  2.9048698  2.9256124  2.5317092
   2.691419   1.5192612  2.2205324  1.8627285  2.906968   2.4142277
   0.6477917  1.977871   2.1422615  2.7471917  2.5350084  2.7127745
   1.60163    2.8680336  2.4903338  2.4094667  2.2524886  0.5003558
   2.0219383  2.884606   2.3468297  2.5292816  2.8067644  3.0389884
   1.1580625  1.8991463  0.35927868 1.6431282  2.5252957  2.7266686
   2.6830583  2.9275603  2.1343498  2.540884   2.9165113  2.8607054
   2.8628     2.1670663  2.7952013  2.9051108  2.7680073  0.8466251
   2.7133293  2.7041147  2.1743088  2.611503   1.2339985  2.8742402
   2.7031207  2.8501868  2.2684762  2.0378194  2.5124516  2.510251
   2.5820034  2.7159503  2.0516024  2.1123536  2.8742845  2.616953
   2.2831023  2.3507495  2.2904484  0.46176836 2.372453   2.602506
   2.4226546  2.3873572  2.7698956  2.5988793  2.5267117  2.8722541
   0.35973868 2.7505498  2.4345775  2.5386293  3.0384297  2.5902374
   1.453211   2.0834513  2.9366677  2.427846   2.5118494  2.9957767
   2.704483   2.1505053  0.6526659  2.0818627 ]
  perf_list [100.      100.      100.      100.       50.       98.4375  100.
   100.      100.       89.0625   57.8125  100.       98.4375   53.125
   100.      100.      100.       96.875    50.      100.       92.1875
    50.      100.       98.4375  100.      100.       98.4375   85.3125
   100.       50.       50.      100.      100.      100.      100.
   100.       50.       98.4375   51.5625   83.75    100.      100.
    90.625    92.8125   99.0625  100.       98.4375  100.       94.0625
    80.625   100.      100.      100.       86.875   100.      100.
    50.      100.       50.      100.       76.875   100.      100.
   100.       73.125    95.3125  100.      100.       89.0625  100.
   100.      100.       57.8125   50.       80.3125   50.       96.56251
   100.      100.      100.      100.      100.      100.      100.
    95.3125   96.56251 100.      100.      100.      100.       98.4375
   100.       90.       90.       52.8125   54.6875   90.9375  100.
    54.6875  100.     ]
  perf_cr_list [100.     100.     100.     100.      53.125  100.      89.0625  50.
   100.      95.3125  51.5625 100.      70.3125  81.25    98.4375 100.
   100.     100.      92.1875 100.      95.3125  50.     100.      98.4375
    95.3125 100.      93.75    50.     100.      92.1875  93.75   100.
   100.     100.     100.     100.      51.5625 100.      92.1875  79.6875
   100.     100.      59.375   54.6875  54.6875 100.      98.4375 100.
    65.625   51.5625 100.      50.     100.     100.     100.     100.
    50.     100.      87.5    100.      53.125  100.     100.      98.4375
    50.      98.4375 100.      64.0625  93.75   100.     100.     100.
    50.      50.      82.8125  56.25    50.     100.      60.9375 100.
    98.4375 100.     100.     100.     100.      82.8125 100.     100.
   100.      50.     100.     100.      50.      50.      51.5625  75.
   100.     100.      73.4375 100.    ]
#+end_example

#+begin_src ipython
  plt.hist(distance_list/2)
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/c234711087cb7e5a759449ee5e84c1495b993fdd.png]]

#+begin_src ipython
  idx = distance_list.argsort()
  window = 10

  plt.plot(distance_list[idx]/2, circcvl(perf_list[idx]*100, window), '-ob')
  plt.plot(distance_list[idx]/2, circcvl(perf_cr_list[idx], window), '-or')

  plt.xlabel('Distance')
  plt.ylabel('Performance')
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/428c7f62402c04d3e17854c7356b73d1f58e2104.png]]

#+begin_src ipython
  idx = phi0_list.argsort()
  window = 10

  plt.plot(phi0_list[idx], circcvl(perf_list[idx]*100, window), '-ob')
  plt.plot(phi0_list[idx], circcvl(perf_cr_list[idx], window), '-or')

  plt.xticks(np.linspace(0, 360, 5))
  plt.xlabel('Readout Location (°)')
  plt.ylabel('Performance')
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/fba85e1f47900e025c0a840495e33ff0cabdaf67.png]]

#+begin_src ipython

#+end_src

#+RESULTS:
