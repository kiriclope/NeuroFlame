#+STARTUP: fold
#+TITLE: Dual Task Readout Rotation
#+PROPERTY: header-args:ipython :results both :exports both :async yes :session dist :kernel torch

* Notebook Settings

#+begin_src ipython
  %load_ext autoreload
  %autoreload 2
  %reload_ext autoreload

  %run ../notebooks/setup.py
  %matplotlib inline
  %config InlineBackend.figure_format = 'png'
#+end_src

#+RESULTS:
: The autoreload extension is already loaded. To reload it, use:
:   %reload_ext autoreload
: Python exe
: /home/leon/mambaforge/envs/torch/bin/python

* Imports

#+begin_src ipython
  import sys
  sys.path.insert(0, '../')

  import torch
  import gc
  import pandas as pd
  from time import perf_counter

  from src.network import Network
  from src.plot_utils import plot_con
  from src.decode import decode_bump, decode_bump_torch
  from src.utils import clear_cache

  from sklearn.cluster import KMeans
  kmeans = KMeans(n_clusters=2)
#+end_src

#+RESULTS:

* Helpers

#+begin_src ipython
  def convert_seconds(seconds):
      h = seconds // 3600
      m = (seconds % 3600) // 60
      s = seconds % 60
      return h, m, s
#+end_src

#+RESULTS:

#+begin_src ipython 
  import numpy as np
  def get_theta(a, b, GM=0, IF_NORM=0):

      u, v = a, b

      if GM:
          v = b - np.dot(b, a) / np.dot(a, a) * a

      if IF_NORM:
          u = a / np.linalg.norm(a)
          v = b / np.linalg.norm(b)

      return np.arctan2(v, u)
#+end_src

#+RESULTS:

#+begin_src ipython 
  def get_idx(model):
      ksi = model.PHI0.cpu().detach().numpy()
      theta = get_theta(ksi[0], ksi[2], GM=0, IF_NORM=0)
      return theta.argsort()
#+end_src

#+RESULTS:

#+begin_src ipython 
  def get_overlap(model, rates):
      return rates @ model.PHI0.T / rates.shape[-1]
#+end_src

#+RESULTS:

#+begin_src ipython
  def get_perf_cr(rates, phi0, n_ini):
      m0, m1, phi = decode_bump(rates, axis=-1)
      
      x = m1[..., -1] / m0[..., -1] * np.cos(phi[..., -1])
      y = m1[..., -1] / m0[..., -1] * np.sin(phi[..., -1])

      X = np.stack((x,y))

      xPhi = np.cos(np.pi / 2 + phi0 * np.pi / 180)
      yPhi = np.sin(np.pi / 2 + phi0 * np.pi / 180)
      vPhi = np.stack((xPhi, yPhi))

      dot = vPhi @ X

      if phi0 > 90 and phi0 < 270:
          dot = dot * -1

      # print(dot[:n_ini])
      A = (dot[:n_ini]<0).sum()
      #print('A perf', A)

      # print(dot[n_ini:])
      B = (dot[n_ini:]>0).sum()
      # print('B perf', B)

      perf = (A + B) / X.shape[1] * 100
      # perf = (A + B) / 2 * 100
      # print('performance', perf)

      return perf
#+end_src

#+RESULTS:

#+begin_src ipython
  def get_perf(model, rates, n_ini):
      overlap = get_overlap(model, rates)
      
      readoutA = overlap[:n_ini, -5:, 0]
      readoutB = overlap[n_ini:, -5:, 0]

      readout = torch.stack((readoutA, readoutB))

      perf = (1.0 * (readout[0]>0)).mean((0, 1))
      perf += (1.0 * (readout[1]<0)).mean((0,1))

      return perf / 2.0
#+end_src

#+RESULTS:

#+begin_src ipython
  def get_avg_phi(centers):
      x_c1, y_c1 = centers[0]
      x_c2, y_c2 = centers[1]

      radius = np.sqrt(x_c1**2 + y_c1**2)

      # Midpoint M of A and B
      xM, yM = (x_c1 + x_c2) / 2, (y_c1 + y_c2) / 2

      phi1 = np.arctan2(y_c1, x_c1)
      phi2 = np.arctan2(y_c2, x_c2)

      phi0 = ( (phi1 + phi2) / 2 ) % np.pi
      psi0 = (phi0 + np.pi) % (2 * np.pi)

      xPhi = radius * np.cos(phi0)
      yPhi = radius * np.sin(phi0)

      xPsi = radius * np.cos(psi0)
      yPsi = radius * np.sin(psi0)

      dist = [np.sqrt((xPhi - xM)**2 + (yPhi - yM)**2),
              np.sqrt((xPsi - xM)**2 + (yPsi - yM)**2)]
      
      if dist[0]>dist[1]:
          mean_phi = phi0 * 180 / np.pi
      else:
          mean_phi = psi0 * 180 / np.pi

      return mean_phi
#+end_src

#+RESULTS:

#+begin_src ipython
  from sklearn.cluster import KMeans
  kmeans = KMeans(n_clusters=2)

  def get_centers(x, y):
      data = np.stack((x,y)).T
      kmeans.fit(data)
      centers = kmeans.cluster_centers_

      return centers

  def get_coord(rates):
      m0, m1, phi = decode_bump_torch(rates, axis=-1)

      x = m1 / m0 * torch.cos(phi)
      y = m1 / m0 * torch.sin(phi)

      return x.real, y.real
#+end_src

#+RESULTS:

* Dual task with rotating readout
** Parameters

#+begin_src ipython
  REPO_ROOT = "/home/leon/models/NeuroTorch"
  conf_name = "config_EI.yml"
  name = "low_rank_ini"

  n_ini  = 32

  LR_COV = [[1.0, 1.0, 0.0, 0.0],
            [0.8, 1.0, 0.0, 0.0],
            [0.0, 0.0, 1.0, 0.8],
            [0.0, 0.0, 0.8, 1.0]]
  
#+end_src

#+RESULTS:

** Fixed Points
*** Simulation

#+begin_src ipython
  start = perf_counter()

  rates_fp = []
  rates_list = []
  rates_cr_list = []

  perf_list = []
  perf_cr_list = []

  distance_list = []
  centers_list = []
  phi0_list = []

  for i in range(20):
      seed = np.random.randint(10000)

      n_ini  = 50
      model = Network(conf_name, name, REPO_ROOT, VERBOSE=0, DEVICE='cuda:1',
                      N_BATCH=2*n_ini, SEED=seed, LR_COV=LR_COV,
                      TASK='dual_rand', LIVE_FF_UPDATE=1, DURATION=30)

      idx = get_idx(model)

      rates = model(REC_LAST_ONLY=1)[..., idx]
      rates_fp.append(rates)

      x, y = get_coord(rates)
      centers = get_centers(x.cpu().numpy(), y.cpu().numpy())
      mean_phi = get_avg_phi(centers)

      centers_list.append(centers)
      phi0_list.append(mean_phi)
      distance_list.append(np.linalg.norm(centers[0]-centers[1]))
      
      n_ini  = 32
      model = Network(conf_name, name, REPO_ROOT, VERBOSE=0, DEVICE='cuda:1',
                      N_BATCH=2*n_ini, SEED=seed, LR_COV=LR_COV,
                      TASK='dual', LIVE_FF_UPDATE=1, DURATION=10)

      # model.TASK = 'dual'
      # model.DURATION = 10
      # model.N_STEPS = int(model.DURATION / model.DT) + model.N_STEADY + model.N_WINDOW

      rates = model()
      rates_list.append(rates[..., idx])
      perf_list.append(get_perf(model, rates, n_ini))

      # model.PHI1 = torch.tensor([0, 180-mean_phi], device='cuda:1')
      # model.TASK = 'dual_odr'

      model = Network(conf_name, name, REPO_ROOT, VERBOSE=0, DEVICE='cuda:1',
                      N_BATCH=2*n_ini, SEED=seed, LR_COV=LR_COV,
                      TASK='dual_odr', LIVE_FF_UPDATE=1, DURATION=10)

      rates_cr = model()
      rates_cr_list.append(rates_cr[..., idx])

      perf_cr = get_perf_cr(rates_cr[..., idx].cpu().numpy(), mean_phi, n_ini)
      perf_cr_list.append(perf_cr)

      del model

  end = perf_counter()

  print("Elapsed (with compilation) = %dh %dm %ds" % convert_seconds(end - start))

#+end_src

#+RESULTS:
: Elapsed (with compilation) = 0h 8m 53s

#+begin_src ipython
  rates_list = torch.stack(rates_list).cpu().numpy()
  rates_fp = torch.stack(rates_fp).cpu().numpy()
  rates_cr_list = torch.stack(rates_cr_list).cpu().numpy()
#+end_src

#+RESULTS:

#+begin_src ipython
  perf_list = torch.stack(perf_list).cpu().numpy()
  perf_cr_list = np.array(perf_cr_list)
#+end_src

#+RESULTS:

#+begin_src ipython
  centers_list = np.array(centers_list)
  distance_list = np.array(distance_list)
  phi0_list = np.array(phi0_list)
#+end_src

#+RESULTS:

*** plots

#+begin_src ipython
  def plot_ring(i, ax, color):
      ax.plot(x_cloud[i], y_cloud[i], 'o', alpha=.25, color=color)

      x_c1, y_c1 = centers_list[i, 0]
      x_c2, y_c2 = centers_list[i, 1]

      ax.plot(x_c1, y_c1, 'x', alpha=1, ms=20, color=color, lw=10)
      ax.plot(x_c2, y_c2, 'x', alpha=1, ms=20, color=color, lw=10)

      # plot separatrix
      x = 1.75 * np.cos(phi0_list[i] * np.pi / 180)
      y = 1.75 * np.sin(phi0_list[i] * np.pi / 180)

      # Draw an arrow using plt.arrow(x, y, dx, dy, **kwargs)
      plt.arrow(0, 0, x, y, head_width=0.25, head_length=0.25, fc=color)

      mean = np.array([phi0_list[i], phi0_list[i] - 180 ]) * np.pi/180

      x = 1.75 * np.cos(mean)
      y = 1.75 * np.sin(mean)
      ax.plot(x, y, '--', color=color)

      ax.set_xlim([-2, 2])
      ax.set_ylim([-2, 2])
      ax.set_title('Fixed Points')
#+end_src

#+RESULTS:

#+begin_src ipython
  fig, ax = plt.subplots(1, 1, figsize=[height, height])

  m0, m1, phi = decode_bump(rates_fp, axis=-1)

  # plot clouds
  x_cloud = m1 / m0 * np.cos(phi)
  y_cloud = m1 / m0 * np.sin(phi)

  # plot centers
  for i in range(centers_list.shape[0]):      
      color = np.random.rand(3,)
      plot_ring(i, ax, color)
      
  plt.show()
  #+end_src

  #+RESULTS:
  [[file:./.ob-jupyter/9e2b687962db43ab24a2d4a58ce9ac6cbb55f980.png]]

#+begin_src ipython
  def plot_trajectory(rates, i, ax):
    m0, m1, phi = decode_bump(rates[i], axis=-1)

    x = m1 / m0 * np.cos(phi)
    y = m1 / m0 * np.sin(phi)

    xA = x[:n_ini]
    yA = y[:n_ini]

    ax.plot(xA.T[0], yA.T[0], 'xb', alpha=.25, ms=10)
    # ax.plot(xA.T, yA.T, '-b', alpha=.25)
    ax.plot(xA.T[-1], yA.T[-1], 'ob', alpha=.25, ms=10)

    xB = x[n_ini:]
    yB = y[n_ini:]

    ax.plot(xB.T[0], yB.T[0], 'xr', alpha=.25, ms=10)
    # ax.plot(x.T, y.T, '-r', alpha=.25)
    ax.plot(xB.T[-1], yB.T[-1], '*r', alpha=.25, ms=10)

    x_c1, y_c1 = centers_list[i, 0]
    x_c2, y_c2 = centers_list[i, 1]

    ax.plot(x_c1, y_c1, 'x', alpha=1, ms=20, color='k', lw=10)
    ax.plot(x_c2, y_c2, 'x', alpha=1, ms=20, color='k', lw=10)

    # plot separatrix
    x = 1.75 * np.cos(phi0_list[i] * np.pi / 180)
    y = 1.75 * np.sin(phi0_list[i] * np.pi / 180)

    # Draw an arrow using plt.arrow(x, y, dx, dy, **kwargs)
    plt.arrow(0, 0, x, y, head_width=0.25, head_length=0.25, fc='k')

    x = 1.75 * np.cos(phi0_list[i] * np.pi / 180 + np.pi/2)
    y = 1.75 * np.sin(phi0_list[i] * np.pi / 180 + np.pi/2)

    # Draw an arrow using plt.arrow(x, y, dx, dy, **kwargs)
    plt.arrow(0, 0, x, y, head_width=0.25, head_length=0.25, fc='b')

    mean = np.array([phi0_list[i], phi0_list[i] - 180 ]) * np.pi/180

    x = 1.75 * np.cos(mean)
    y = 1.75 * np.sin(mean)
    ax.plot(x, y, '--', color='k')

    mean = np.array([phi0_list[i] + 90, phi0_list[i] - 180 + 90]) * np.pi/180

    x = 1.75 * np.cos(mean)
    y = 1.75 * np.sin(mean)
    ax.plot(x, y, '--', color='b')


    ax.set_xlim([-2, 2])
    ax.set_ylim([-2, 2])

#+end_src

#+RESULTS:

#+begin_src ipython
  i = 2
  fig, ax = plt.subplots(1, 3, figsize=(3*height, height))

  plot_ring(i, ax[0], 'b')

  plot_trajectory(rates_list, i, ax[1])
  ax[1].set_title('Performance %.1f' % (perf_list[i] * 100))
  
  plot_trajectory(rates_cr_list, i, ax[2])
  ax[2].set_title('Performance %.1f' % (perf_cr_list[i]))

  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/597d8a0fcebe3dd1efeec7f2c0ea6ef1dcf7ebb4.png]]

#+begin_src ipython 
  rates = rates_cr_list[i]
  print(rates.shape)
  m0, m1, phi = decode_bump(rates, axis=-1)
  x = m1[..., -1] / m0[..., -1] * np.cos(phi[..., -1])
  y = m1[..., -1] / m0[..., -1] * np.sin(phi[..., -1])

  X = np.stack((x,y))
  print(X.shape)

  centers = centers_list[i]
  phi0 = phi0_list[i]

  x_c1, y_c1 = centers[0]
  x_c2, y_c2 = centers[1]
  
  # Midpoint M of A and B
  print(phi0)
  # radius = np.sqrt(x_c1**2 + y_c1**2)
  xPhi =  np.cos(np.pi / 2 + phi0 * np.pi / 180)
  yPhi =  np.sin(np.pi / 2 + phi0 * np.pi / 180)

  vPhi = np.stack((xPhi, yPhi))
  print(vPhi.shape)

  dot = vPhi @ X

  if phi0 > 0 and phi0<180:
       dot = dot * -1

  # print(dot[:n_ini])
  A = (dot[:n_ini]<0).sum()
  print('A perf', A)

  # print(dot[n_ini:])
  B = (dot[n_ini:]>0).sum()
  print('B perf', B)

  perf = (A + B) / X.shape[1] * 100
  # perf = (A + B) / 2 * 100
  print('performance', perf)
#+end_src

#+RESULTS:
: (64, 101, 2000)
: (2, 64)
: 293.2949928674431
: (2,)
: A perf 32
: B perf 32
: performance 100.0

#+begin_src ipython
270-90
#+end_src

#+RESULTS:
: 180

*** performance
#+begin_src ipython
  print('dist', distance_list)
  print('perf_list',perf_list*100)
  print('perf_cr_list', perf_cr_list)
#+end_src

#+RESULTS:
#+begin_example
  dist [2.285811   0.29512873 2.4616005  2.1527345  2.0966911  2.2849119
   2.420521   0.33093303 2.3977222  2.4136317  2.3718414  1.77061
   2.2574203  2.4484315  0.3971883  0.21420151 2.2458     0.27559188
   1.9549289  2.3824887 ]
  perf_list [ 84.375     50.       100.        70.9375    68.4375    49.6875
    81.875     50.        80.        65.3125    62.1875    96.875
    75.625     58.437504  77.5       50.        50.        50.
    69.0625    96.875   ]
  perf_cr_list [ 95.3125  40.625  100.      50.      51.5625  50.       1.5625  45.3125
     0.      20.3125  50.       0.      98.4375  75.      62.5     43.75
    67.1875  31.25     9.375  100.    ]
#+end_example

#+begin_src ipython
  plt.plot(distance_list[distance_list.argsort()]/2, perf_list[distance_list.argsort()]*100, '-ob')
  plt.plot(distance_list[distance_list.argsort()]/2, perf_cr_list[distance_list.argsort()], '-or')
  plt.xlabel('Distance')
  plt.ylabel('Performance')
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/7a30c7aa0bd73b486f397a6c2882099067aa6553.png]]

#+begin_src ipython
  plt.plot(phi0_list[phi0_list.argsort()], perf_list[phi0_list.argsort()]*100, '-ob')
  plt.plot(phi0_list[phi0_list.argsort()], perf_cr_list[phi0_list.argsort()], '-or')

  plt.xticks(np.linspace(0, 360, 5))
  plt.xlabel('Readout Location (°)')
  plt.ylabel('Performance')
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/d4379642129b66e60c7b82aabbe4bf5d904875ea.png]]

#+begin_src ipython

#+end_src

#+RESULTS:
