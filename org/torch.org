#+STARTUP: fold
#+TITLE: RNN with pytorch
#+PROPERTY: header-args:ipython :results both :exports both :async yes :session torch :kernel torch

* Notebook Settings

#+begin_src ipython
  %load_ext autoreload
  %autoreload 2
  %reload_ext autoreload

  %run ../notebooks/setup.py
  %matplotlib inline
  %config InlineBackend.figure_format = 'png'
#+end_src

#+RESULTS:
: The autoreload extension is already loaded. To reload it, use:
:   %reload_ext autoreload
: Python exe
: /home/leon/mambaforge/envs/torch/bin/python

* Imports

#+begin_src ipython
  import sys
  sys.path.insert(0, '../')

  import torch
  import gc
  import pandas as pd
  from time import perf_counter  

  from src.network import Network
  from src.plot_utils import plot_con
  from src.decode import decode_bump
#+end_src

#+RESULTS:
* Helpers

#+begin_src ipython
  def convert_seconds(seconds):
      h = seconds // 3600
      m = (seconds % 3600) // 60
      s = seconds % 60
      return h, m, s
#+end_src

#+RESULTS:

#+begin_src ipython
  def get_theta(a, b, GM=0, IF_NORM=0):

      u, v = a, b

      if GM:          
          v = b - np.dot(b, a) / np.dot(a, a) * a
          
      if IF_NORM:
          u = a / np.linalg.norm(a)
          v = b / np.linalg.norm(b)

      return np.arctan2(v, u)
#+end_src

#+RESULTS:

#+begin_src ipython
  def get_idx(model):
      ksi = model.PHI0.cpu().detach().numpy()
      print(ksi.shape)

      idx = np.arange(0, len(ksi[0]))
      theta = get_theta(ksi[0], ksi[2], GM=0, IF_NORM=0)

      return theta.argsort()
#+end_src

#+RESULTS:

#+begin_src ipython
  def get_overlap(model, rates):
      ksi = model.PHI0.cpu().detach().numpy()
      return rates @ ksi.T / rates.shape[-1]
  
#+end_src

#+RESULTS:

* Phase space

#+begin_src ipython
  REPO_ROOT = "/home/leon/models/NeuroTorch"
  conf_name = "config_EI.yml"
  name = "low_rank_ini"
  n_ini = 20
#+end_src

#+RESULTS:

#+begin_src ipython
      model = Network(conf_name, '%s' % (name),
                      REPO_ROOT, DEVICE='cuda', LR_TRAIN=0, TASK='None',
                      LR_COV = [[1.0, 0.9, 0.0, 0.0],
                                [0.9, 1.0, 0., 0.0],
                                [0.0, 0., 1.0, 0.9],
                                [0.0, 0.0, 0.9, 1.0]],
                      VERBOSE=0, SEED=0, N_BATCH=n_ini)
#+end_src

#+RESULTS:
: [[1.0, 0.9, 0.0, 0.0], [0.9, 1.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.9], [0.0, 0.0, 0.9, 1.0]]

#+begin_src ipython
  Ja0 = np.linspace(0, 2, 10)
  print(Ja0)
#+end_src

#+RESULTS:
: [0.         0.22222222 0.44444444 0.66666667 0.88888889 1.11111111
:  1.33333333 1.55555556 1.77777778 2.        ]

#+begin_src ipython
  ff_input = []
  for x in Ja0:
      model.Ja0[0] = x
      ff_input.append(model.init_ff_input())

  ff_input = torch.cat(ff_input)
#+end_src

#+RESULTS:

#+begin_src ipython
  print(ff_input.shape)
#+end_src

#+RESULTS:
: torch.Size([200, 1200, 10000])

#+begin_src ipython
  rates = model.forward(ff_input, REC_LAST_ONLY=0).cpu().detach().numpy()
#+end_src

#+RESULTS:

#+begin_src ipython
  overlap = get_overlap(model, rates)
  overlap = np.abs(overlap.reshape(10, n_ini, 11, -1))
  print(overlap.shape)
#+end_src

#+RESULTS:
: (10, 20, 11, 4)

#+begin_src ipython
  mean_overlap = overlap.mean(1)
  for i in range(n_ini):
      plt.plot(overlap[:, i, -1], 'o')
  plt.plot(mean_overlap[:, -1, :], '-o')
  plt.ylabel('Overlap')
  plt.xlabel('$J_{A0}$')
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/686154d466dae923b6f7d1800299bb645726cb0c.png]]

#+begin_src ipython
  idx = get_idx(model)
  rates_ord = rates[..., idx].reshape((10, n_ini, 11, -1))[..., -1, :]
  m0, m1, phi = decode_bump(rates_ord, axis=-1)
  print(m0.shape)
#+end_src

#+RESULTS:
: (4, 8000)
: (10, 20)

#+begin_src ipython
  fig, ax = plt.subplots(1, 2, figsize=[2*height, height])

  x = m1 / m0 * np.cos(phi)
  y = m1 / m0 * np.sin(phi)

  ax[0].hist(np.hstack(phi) * 180 / np.pi, density=True, bins='auto')
  ax[0].set_xlim([0, 360])
  ax[0].set_xticks([0, 180, 360])
  ax[0].set_xlabel('Pref. Location (°)')
  ax[0].set_ylabel('Density')

  ax[1].plot(x.T, y.T, 'o')
  ax[1].set_xlim([-2, 2])
  ax[1].set_ylim([-2, 2])
  # ax[1].set_title('$h_S . \\xi_D = 0$')
  ax[1].set_xlabel('Sample Axis')
  ax[1].set_ylabel('Distractor Axis')

  plt.show() 
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/a3e007e35c354880d0390b321f8173ef1a06ab1f.png]]

#+begin_src ipython
  cos = torch.nn.CosineSimilarity(dim=0, eps=1e-6)  
  print(model.PHI0.shape)
  
  theta01 = np.arccos(cos(model.PHI0[0], model.PHI0[1]).item()) * 180 / np.pi
  theta02 = np.arccos(cos(model.PHI0[0], model.PHI0[2]).item()) * 180 / np.pi
  theta12 = np.arccos(cos(model.PHI0[1], model.PHI0[2]).item()) * 180 / np.pi
  print(theta01, theta02, theta12)
#+end_src

#+RESULTS:
: torch.Size([4, 8000])
: 25.84251566350928 90.12336302340005 90.16332386469915

#+begin_src ipython
  def covariance(x, y):
      if x.size(0) != y.size(0):
          raise ValueError("x and y must have the same number of elements.")
    
      x_mean = torch.mean(x)
      y_mean = torch.mean(y)
    
      cov = torch.mean((x - x_mean) * (y - y_mean))
      return cov

#+end_src

#+RESULTS:

#+begin_src ipython
  print(model.PHI0.shape)
  cov01 = covariance(model.PHI0[0], model.PHI0[1]).item()
  cov02 = covariance(model.PHI0[0], model.PHI0[2]).item()
  cov12 = covariance(model.PHI0[1], model.PHI0[2]).item()
  print(cov01, cov02, cov12)
#+end_src

#+RESULTS:
: torch.Size([4, 8000])
: 0.8871580958366394 -0.0017717686714604497 -0.0025606986600905657

* RNN with torch
** Single Trial
*** Model

#+begin_src ipython
  REPO_ROOT = "/home/leon/models/NeuroTorch"
  model = Network('config_EI.yml', 'dual', REPO_ROOT, VERBOSE=1, DEVICE='cuda', LR_TRAIN=0)

  rates = model.forward(REC_LAST_ONLY=0).detach().cpu().numpy()[0]
  
  Ne = model.Na[0].detach().cpu().numpy()
  N = model.N_NEURON

  print(rates.shape)
#+end_src

#+RESULTS:
#+begin_example
  Na tensor([8000, 2000], device='cuda:0', dtype=torch.int32) Ka tensor([500., 500.], device='cuda:0') csumNa tensor([    0,  8000, 10000], device='cuda:0')
  Jab [1.0, -1.5, 1, -1]
  Ja0 [2.0, 1.0]
  generating ff input
  times (s) 0.0 rates (Hz) [0.0, 2.61]
  times (s) 0.83 rates (Hz) [20.22, 2.63]
  times (s) 1.67 rates (Hz) [10.21, 16.44]
  times (s) 2.5 rates (Hz) [9.09, 14.17]
  times (s) 3.33 rates (Hz) [8.73, 13.66]
  times (s) 4.17 rates (Hz) [9.24, 14.44]
  times (s) 5.0 rates (Hz) [9.74, 15.48]
  times (s) 5.83 rates (Hz) [10.12, 16.35]
  times (s) 6.67 rates (Hz) [9.97, 15.98]
  times (s) 7.5 rates (Hz) [9.49, 14.52]
  times (s) 8.33 rates (Hz) [10.03, 15.57]
  Elapsed (with compilation) = 1.7092998465523124s
  (11, 8000)
#+end_example

*** Dynamics

#+begin_src ipython
  ff_input = model.ff_input.cpu().detach().numpy()
  print(ff_input.shape)
  
  fig, ax = plt.subplots(1, 2, figsize=(2*width, height))

  ax[0].plot(ff_input[0, :, :5])
  ax[0].plot(ff_input[0, :, -5:])
  ax[0].set_xlabel('Step')
  ax[0].set_ylabel('FF Input')

  ax[1].imshow(ff_input[0].T, cmap='jet', vmin=0, aspect='auto')
  ax[1].set_xlabel('Step')
  ax[1].set_ylabel('Neuron #')
  ax[1].set_ylim([0, N])
  plt.show()
#+end_src

#+RESULTS:
:RESULTS:
: (1, 1200, 10000)
[[file:./.ob-jupyter/6a49e81ca10a0ea0bc8eaa4f0ad323cf7441513f.png]]
:END:

#+begin_src ipython
  print(rates.shape)
  r_max = 15 # 0.5 * np.max(rates[-1])
  
  plt.imshow(rates.T, aspect='auto', cmap='jet', vmin=0, vmax=r_max, origin='lower')
  plt.colorbar()
  plt.show()
#+end_src

#+RESULTS:
:RESULTS:
: (11, 8000)
[[file:./.ob-jupyter/408b86edbfb495000616a543027ab8f2a5d1f10c.png]]
:END:

#+RESULTS:

#+begin_src ipython
  overlap = get_overlap(model, rates)
  print(overlap.shape)
#+end_src

#+RESULTS:
: (11, 4)

#+begin_src ipython
  plt.plot(overlap[:, :2], 'r')
  plt.plot(overlap[:, 2:], 'b')
  plt.xlabel('Step')
  plt.ylabel('Overlap')
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/784b6e33506c42a228573d57b364e2978134479d.png]]

#+begin_src ipython
  idx = get_idx(model)
  rates_ordered = rates[:, idx]
#+end_src

#+RESULTS:
: (4, 8000)

#+begin_src ipython
  plt.imshow(rates_ordered.T, aspect='auto', cmap='jet', vmin=0, vmax=15)
  plt.ylabel('Pref. Location (°)')
  plt.xlabel('Time (au)')
  plt.yticks(np.linspace(0, Ne, 5), np.linspace(0, 360, 5).astype(int))
  plt.colorbar()
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/738b62a0143851d0056893941dd05fe1fef2dd70.png]]

#+begin_src ipython
  m0, m1, phi = decode_bump(rates_ordered, axis=-1)
#+end_src

#+RESULTS:

#+begin_src ipython
  plt.plot((phi * 180 / np.pi))
  plt.yticks(np.linspace(0, 360, 5).astype(int), np.linspace(0, 360, 5).astype(int))  
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/fa5a80d3c364da6b143d8b63e3c529656e0d2db3.png]]

#+begin_src ipython

#+end_src

#+RESULTS:

** Multiple initializations
*** Parameters

#+begin_src ipython
  REPO_ROOT = "/home/leon/models/NeuroTorch"
  conf_name = "config_EI.yml"
  name = "low_rank_ini"
  seed = 0
#+end_src

#+RESULTS:

*** Simulation

#+begin_src ipython  
  start = perf_counter()
  model = Network(conf_name, name, REPO_ROOT, VERBOSE=0, DEVICE='cuda', N_BATCH=10, LR_TRAIN=0, SEED=seed)
  
  model.I0[0] = 1
  sample_A = model.init_ff_input()

  model.I0[0] = -1
  sample_B = model.init_ff_input()

  ff_input = torch.vstack((sample_A, sample_B))
  print(ff_input.shape)

  rates = model.forward(ff_input, REC_LAST_ONLY=0).detach().cpu().numpy()
  end = perf_counter()

  print("Elapsed (with compilation) = %dh %dm %ds" % convert_seconds(end - start))
  print('rates', rates.shape)

#+end_src

#+RESULTS:
: torch.Size([20, 1200, 10000])
: Elapsed (with compilation) = 0h 0m 1s
: rates (20, 11, 8000)

*** Results

#+begin_src ipython 
  Ne = model.Na[0].detach().cpu().numpy()
  N = model.N_NEURON

  ff_input = model.ff_input.cpu().detach().numpy()
  print(ff_input.shape)

  fig, ax = plt.subplots(1, 2, figsize=(2*width, height))

  ax[0].plot(ff_input[0, :, :5])
  ax[0].plot(ff_input[1, :, :5])
  ax[0].set_xlabel('Step')
  ax[0].set_ylabel('FF Input')

  ax[1].imshow(ff_input[1].T, cmap='jet', vmin=0, aspect='auto')
  ax[1].set_xlabel('Step')
  ax[1].set_ylabel('Neuron #')
  ax[1].set_ylim([0, N])
  plt.show()
#+end_src

#+RESULTS:
:RESULTS:
: (20, 1200, 10000)
[[file:./.ob-jupyter/a5069129f7f4d5ab52bd5222126f997dc97504ce.png]]
:END:

#+begin_src ipython
  print(rates.mean(-1).shape)
  plt.plot(rates.mean(-1).T)
  plt.xlabel('Step')
  plt.ylabel('Rates (Hz)')
  plt.show()
#+end_src

#+RESULTS:
:RESULTS:
: (20, 11)
[[file:./.ob-jupyter/6235a8c7dc76c24bc8917c6ad242a780486eea24.png]]
:END:

#+begin_src ipython
  idx = get_idx(model)
  rates_ordered = rates[..., idx]
  print(rates_ordered.shape)
#+end_src

#+RESULTS:
: (4, 8000)
: (20, 11, 8000)

#+begin_src ipython
  overlap = get_overlap(model, rates)
  print(overlap.T.shape)
#+end_src

#+RESULTS:
: (4, 11, 20)

#+begin_src ipython
  fig, ax = plt.subplots(1, 3, figsize=[2*width, height])

  ax[0].plot(overlap.T[0])
  ax[0].set_ylabel('Overlap on $\\xi_1$ (Hz)')
  ax[0].set_xlabel('Step')

  ax[1].plot(overlap.T[1])
  ax[1].set_ylabel('Overlap on $\\xi_2$ (Hz)')
  ax[1].set_xlabel('Step')

  ax[2].plot(overlap.T[2])
  ax[2].set_ylabel('Overlap on $\\xi_3$ (Hz)')
  ax[2].set_xlabel('Step')
  
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/f4c374283006cf28ad0e5349ac756c96d748f1c4.png]]

#+begin_src ipython
  m0, m1, phi = decode_bump(rates_ordered, axis=-1)
  print(m0.shape)
#+end_src

#+RESULTS:
: (20, 11)

#+begin_src ipython
  fig, ax = plt.subplots(1, 3, figsize=[2*width, height])
  
  ax[0].plot(m0.T)
  #ax[0].set_ylim([0, 360])
  #ax[0].set_yticks([0, 90, 180, 270, 360])
  ax[0].set_ylabel('$\mathcal{F}_0$ (Hz)')
  ax[0].set_xlabel('Step')

  ax[1].plot(m1.T)
  # ax[1].set_ylim([0, 360])
  # ax[1].set_yticks([0, 90, 180, 270, 360])
  ax[1].set_ylabel('$\mathcal{F}_1$ (Hz)')
  ax[1].set_xlabel('Step')

  ax[2].plot(phi.T * 180 / np.pi)
  ax[2].set_ylim([0, 360])
  ax[2].set_yticks([0, 90, 180, 270, 360])
  ax[2].set_ylabel('Phase (°)')
  ax[2].set_xlabel('Step')

  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/e298c05513d4db2295626b13bdc8b9bdb8a3064d.png]]

#+begin_src ipython
  print(rates_ordered.shape)

  plt.imshow(rates_ordered[0].T, aspect='auto', cmap='jet', vmin=0, vmax=15)
  plt.ylabel('Pref. Location (°)')
  plt.xlabel('Time (au)')
  plt.yticks(np.linspace(0, rates_ordered.shape[-1], 5), np.linspace(0, 360, 5).astype(int))
  plt.colorbar()
  plt.show()
#+end_src

#+RESULTS:
:RESULTS:
: (20, 11, 8000)
[[file:./.ob-jupyter/2038a312b0d08a127c52b98bd4d85fe7e9a8967f.png]]
:END:

#+begin_src ipython
  print(m0.shape)
  x = m1[:, -1]/ m0[:, -1] * np.cos(phi[:, -1])
  y = m1[:, -1] / m0[:, -1] * np.sin(phi[:, -1])

  fig, ax = plt.subplots(figsize=(height, height))
  ax.plot(x, y, 'o')
  ax.set_xlim([-2, 2])
  ax.set_ylim([-2, 2])
  plt.show()
#+end_src

#+RESULTS:
:RESULTS:
: (20, 11)
[[file:./.ob-jupyter/fe2457d3e56cd7028ba081ef37b4d00c3b6103a7.png]]
:END:

#+begin_src ipython

#+end_src

#+RESULTS:

** Behavior
*** Helpers

#+begin_src ipython
  def run_behavior(conf_name, name, cov_list, n_ini, seed, device='cuda', **kwargs):
      start = perf_counter()

      rates = []
      ksi = []
      with torch.no_grad():
          for cov in cov_list:

              model = Network(conf_name, '%s_cov_%.3f' % (name, cov),
                              REPO_ROOT, DEVICE=device, LR_TRAIN=0,
                              # LR_COV = [[1.0, cov], [cov, 1.0]],
                              # LR_COV = [[1.0, cov, cov], [cov, 1.0, cov], [cov, cov, 1.0]],
                              LR_COV = [[1.0, 0.9, 0.0, 0.0], [0.9, 1.0, cov, 0.0],
                                        [0.0, cov, 1.0, 0.9], [0.0, 0.0, 0.9, 1.0]],
                              VERBOSE=0, SEED=seed, N_BATCH=n_ini, **kwargs)

              model.I0[0] = .1
              # ff_input = model.init_ff_input()
              sample_A = model.init_ff_input()

              model.I0[0] = -.1
              sample_B = model.init_ff_input()
              
              ff_input = torch.cat((sample_A, sample_B))

              sample_A.cpu(), sample_B.cpu()
              del sample_A, sample_B

              rates.append(model.forward(ff_input, REC_LAST_ONLY=0).cpu().detach().numpy())
              ksi.append(model.PHI0.cpu().detach().numpy())

              model.cpu()
              ff_input.cpu()

              del ff_input
              del model

              gc.collect()
              torch.cuda.empty_cache()
              # print(torch.cuda.memory_allocated())

      end = perf_counter()

      print("Elapsed (with compilation) = %dh %dm %ds" % convert_seconds(end - start))      

      return np.array(rates), np.array(ksi)
#+end_src

#+RESULTS:

*** Parameters

#+begin_src ipython
  REPO_ROOT = "/home/leon/models/NeuroTorch"
  conf_name = "config_EI.yml"
  name = "low_rank_ini"
#+end_src
w
#+RESULTS:

#+begin_src ipython
  cov_list = np.linspace(0.05, 0, 10)
  print(cov_list)
  n_ini = 32
  seed = np.random.randint(100)
  # 34, 53
  print(seed)
#+end_src

#+RESULTS:
: [0.05       0.04444444 0.03888889 0.03333333 0.02777778 0.02222222
:  0.01666667 0.01111111 0.00555556 0.        ]
: 7

#+begin_src ipython
  def ret_overlap(rates, ksi):
      rates_ord = np.zeros(rates.shape)
      overlap = []
      
      for i in range(len(cov_list)):
          idx = np.arange(len(ksi[i][0]))
          theta = get_theta(ksi[i][0], ksi[i][2], GM=0, IF_NORM=0)

          overlap.append(rates[i] @ ksi[i].T / rates.shape[-1])

          index_order = theta.argsort()
          rates_ord[i] = rates[i][..., index_order]

      return np.array(overlap), rates_ord
  #+end_src

#+RESULTS:

*** Run

#+begin_src ipython
  I0 = [0.1, 0.0, 0.0]
  rates, ksi = run_behavior(conf_name, name, cov_list, n_ini, seed, device='cuda', I0=I0)
#+end_src

#+RESULTS:
: Elapsed (with compilation) = 0h 1m 44s

#+begin_src ipython
  print(rates.shape)
  print(ksi.shape)  
#+end_src

#+RESULTS:
: (10, 64, 11, 8000)
: (10, 4, 8000)

#+begin_src ipython
  I0 = [0.1, 0.1, 0.0]
  ratesGo, ksiGo = run_behavior(conf_name, name, cov_list, n_ini, seed, device='cuda', I0=I0)
#+end_src

#+RESULTS:
: Elapsed (with compilation) = 0h 1m 27s

#+begin_src ipython  
  print(ratesGo.shape)
  print(ksiGo.shape)  
#+end_src

#+RESULTS:
: (10, 64, 11, 8000)
: (10, 4, 8000)

#+begin_src ipython
  overlap1, rates1 = ret_overlap(rates, ksi)
  overlap2, rates2 = ret_overlap(ratesGo, ksiGo)
#+end_src

#+RESULTS:

#+begin_src ipython
  print(overlap1.shape)
  print(overlap2.shape)
#+end_src

#+RESULTS:
: (10, 64, 11, 4)
: (10, 64, 11, 4)

#+begin_src ipython
  fig, ax = plt.subplots(1, 2, figsize=(2*width, height))

  ax[0].plot(overlap1[:, :n_ini, -5:, 0].mean((1,2)), '-rs')
  ax[0].plot(overlap1[:, n_ini:, -5:, 0].mean((1,2)), '-ro')
  ax[0].set_ylabel('Sample Overlap')
  ax[0].set_xlabel('Day')
  ax[0].set_title('DPA')
  
  ax[1].plot(overlap2[:, :n_ini, -5:, 0].mean((1,2)), '-bs')
  ax[1].plot(overlap2[:, n_ini:, -5:, 0].mean((1,2)), '-bo')
  ax[1].set_ylabel('Sample Overlap')
  ax[1].set_xlabel('Day')
  ax[1].set_title('Dual Go')

  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/4deb5a7ac80d559e78d0764532f2db3a91f6c1b5.png]]

#+begin_src ipython
  readout1A = overlap1[:, :n_ini, -5:, 0]
  readout1B = overlap1[:, n_ini:, -5:, 0]

  readout1 = np.stack((readout1A, readout1B))
  # print(readout1.shape)

  perf1 = (readout1[0]>0).mean((1, 2))
  perf1 += (readout1[1]<0).mean((1, 2))

  readout2A = overlap2[:, :n_ini, -5:, 0]
  readout2B = overlap2[:, n_ini:, -5:, 0]

  readout2 = np.stack((readout2A, readout2B))
  print((readout2[0]>0).shape)

  perf2 = (readout2[0]>0).mean((1, 2))

  perf2 += (readout2[1]<0).mean((1, 2))

  plt.plot(perf1/2, 'r')
  plt.plot(perf2/2, 'b')

  plt.ylabel('Performance')
  plt.xlabel('Day')
  plt.show()
#+end_src
#+RESULTS:
:RESULTS:
: (10, 32, 5)
[[file:./.ob-jupyter/8683874d4f0ffe8cce819cb0890e384ef19659cf.png]]
:END:

#+begin_src ipython

#+end_src

#+RESULTS:

**** Performance from phase

#+begin_src ipython
  def get_perf(rates):
      m0, m1, phi = decode_bump(rates, axis=-1)
      x = m1[..., -1] / m0[..., -1] * np.cos(phi[..., -1])
      performance = (x[: , :n_ini] < 0).mean(1) * 100
      performance += (x[: , n_ini:] > 0).mean(1) * 100

      return performance / 2
#+end_src

#+RESULTS:

#+begin_src ipython 
  perf1 = get_perf(rates1)
  print(perf1)
  perf2 = get_perf(rates2)
  print(perf2)

  plt.plot(perf1, 'r')
  plt.plot(perf2, 'b')
  plt.ylabel('Performance')
  plt.xlabel('Day')
  plt.show()
#+end_src

#+RESULTS:
:RESULTS:
: [64.0625 60.9375 56.25   68.75   67.1875 64.0625 78.125  70.3125 84.375
:  75.    ]
: [50.     50.     50.     50.     50.     50.     51.5625 50.     54.6875
:  59.375 ]
[[file:./.ob-jupyter/c7fe9b8f29a6f143629602c634e93606ff972201.png]]
:END:

**** Single

#+begin_src ipython
  ini = -1
  overlap = overlap1.copy()
  print(overlap1[ini].shape)
  m0, m1, phi = decode_bump(rates1, axis=-1)
  print(m0[ini].shape)
#+end_src

#+RESULTS:
: (64, 11, 4)
: (64, 11)

#+begin_src ipython
  fig, ax = plt.subplots(1, 3, figsize=[2*width, height])
  
  ax[0].plot(overlap[ini, ..., 0].T, alpha=.2)
  ax[0].set_ylabel('Overlap on $\\xi_1$ (Hz)')
  ax[0].set_xlabel('Step')

  ax[1].plot(overlap[ini, ..., 1].T, alpha=.2)
  ax[1].set_ylabel('Overlap on $\\xi_2$ (Hz)')
  ax[1].set_xlabel('Step')

  ax[2].plot(overlap[ini, ..., 2].T, alpha=.2)
  ax[2].set_ylabel('Overlap on $\\xi_3$ (Hz)')
  ax[2].set_xlabel('Step')

  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/de5ea793aa0a91b89326ec578d0b431602bc1e8b.png]]

#+begin_src ipython
  fig, ax = plt.subplots(1, 3, figsize=[2*width, height])
 
  ax[0].plot(m0[ini].T)
  #ax[0].set_ylim([0, 360])
  #ax[0].set_yticks([0, 90, 180, 270, 360])
  ax[0].set_ylabel('$\mathcal{F}_0$ (Hz)')
  ax[0].set_xlabel('Step')

  ax[1].plot(m1[ini].T)
  # ax[1].set_ylim([0, 360])
  # ax[1].set_yticks([0, 90, 180, 270, 360])
  ax[1].set_ylabel('$\mathcal{F}_1$ (Hz)')
  ax[1].set_xlabel('Step')

  ax[2].plot(phi[ini].T * 180 / np.pi)
  ax[2].set_ylim([0, 360])
  ax[2].set_yticks([0, 90, 180, 270, 360])
  ax[2].set_ylabel('Phase (°)')
  ax[2].set_xlabel('Step')

  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/e6a71062bebc5f6772126c537ab28f98a7ae49c5.png]]

#+begin_src ipython  
  x = m1[ini, ..., -1] / m0[ini, ..., -1] * np.cos(phi[ini, ..., -1])
  y = m1[ini, ..., -1] / m0[ini, ..., -1] * np.sin(phi[ini, ..., -1])

  fig, ax = plt.subplots(figsize=(height, height))
  ax.plot(x.T, y.T, 'o')
  ax.set_xlim([-2, 2])
  ax.set_ylim([-2, 2])
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/dfbc01ed1a353f2fc09f0e93b44801ac281047f0.png]]

#+begin_src ipython

#+end_src

#+RESULTS:

** Different Realizations
*** Helpers

#+begin_src ipython
  def run_X(conf_name, name, real_list, n_ini, device='cuda', **kwargs):
      start = perf_counter()

      rates = []
      ksi = []
      with torch.no_grad():
          for real in real_list:

              model = Network(conf_name, '%s_real_%d' % (name, real),
                              REPO_ROOT, DEVICE=device,  VERBOSE=0, SEED=0,
                              LR_TRAIN=0, N_BATCH=n_ini, **kwargs)

              model.I0[0] = .1
              sample_A = model.init_ff_input()

              model.I0[0] = -.1
              sample_B = model.init_ff_input()

              ff_input = torch.cat((sample_A, sample_B))

              ksi.append(model.PHI0.cpu().detach().numpy())
              rates.append(model.forward(ff_input, REC_LAST_ONLY=1).cpu().detach().numpy())

              del model

      end = perf_counter()

      print("Elapsed (with compilation) = %dh %dm %ds" % convert_seconds(end - start))      

      return np.array(rates), np.array(ksi)
#+end_src

#+RESULTS:

*** Parameters

#+begin_src ipython
  REPO_ROOT = "/home/leon/models/NeuroTorch"
  conf_name = "config_EI.yml"
  name = "low_rank_ini"
#+end_src

#+RESULTS:

#+begin_src ipython
  real_list = np.arange(0, 50)
  n_ini = 1
#+end_src

#+RESULTS:

*** Run
**** Orthogonal

#+begin_src ipython
    rates, ksi = run_X(conf_name, name, real_list, n_ini,
                       device='cuda',
                       LR_COV=[[1.0, 0.9, 0.0, 0.0],
                               [0.9, 1.0, 0.0, 0.0],
                               [0.0, 0.0, 1.0, 0.9],
                               [0.0, 0.0, 0.9, 1.0]]
                       )
#+end_src

#+RESULTS:
: Elapsed (with compilation) = 0h 1m 38s

#+begin_src ipython
  rates_ord = np.zeros(rates.shape)
  
  for i in real_list:
      idx = np.arange(0, len(ksi[i][0]))
      theta = get_theta(ksi[i][0], ksi[i][2], GM=0, IF_NORM=1)

      index_order = theta.argsort()
      rates_ord[i] = rates[i][ ..., index_order]
  print(rates_ord.shape)

  m0, m1, phi = decode_bump(rates_ord, axis=-1)
  print(m0.shape)
#+end_src

#+RESULTS:
: (50, 2, 8000)
: (50, 2)

#+begin_src ipython
  fig, ax = plt.subplots(1, 2, figsize=[2*height, height])

  x = m1 / m0 * np.cos(phi)
  y = m1 / m0 * np.sin(phi)
  
  ax[0].hist(np.hstack(phi) * 180 / np.pi, density=True, bins='auto')
  ax[0].set_title('$h_S . \\xi_D = 0$')
  ax[0].set_xlim([0, 360])
  ax[0].set_xticks([0, 180, 360])
  ax[0].set_xlabel('Pref. Location (°)')
  ax[0].set_ylabel('Density')

  ax[1].plot(x.T, y.T, 'o')
  ax[1].set_xlim([-2, 2])
  ax[1].set_ylim([-2, 2])
  ax[1].set_title('$h_S . \\xi_D = 0$')
  ax[1].set_xlabel('Sample Axis')
  ax[1].set_ylabel('Distractor Axis')

  plt.show() 
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/b6bc38eaf8721b85b979f683526c764a007deb3a.png]]

#+begin_src ipython

#+end_src

#+RESULTS:

**** xi_S . xi_D >0

#+begin_src ipython
  rates_cov, ksi_cov = run_X(conf_name, name, real_list, n_ini,
                             device='cuda',
                             LR_COV=[[1.0, 0.8, 0.2, 0.0],
                                     [0.8, 1.0, 0.0, 0.0],
                                     [0.2, 0.0, 1.0, 0.8],
                                     [0.0, 0.0, 0.8, 1.0]]
                             )
#+end_src

#+RESULTS:
: Elapsed (with compilation) = 0h 1m 17s

#+begin_src ipython
  rates_ord_cov = np.zeros(rates_cov.shape)

  for i in real_list:      
      idx = np.arange(0, len(ksi_cov[i][0]))
      theta = get_theta(ksi_cov[i][0], ksi_cov[i][2], GM=0, IF_NORM=1)
      
      index_order = theta.argsort()
      rates_ord_cov[i] = rates_cov[i][..., index_order]

  print(rates_ord_cov.shape)

  m0_cov, m1_cov, phi_cov = decode_bump(rates_ord_cov, axis=-1)
#+end_src

#+RESULTS:
: (50, 2, 8000)

#+begin_src ipython
  fig, ax = plt.subplots(1, 2, figsize=[2*height, height])

  x = m1_cov / m0_cov * np.cos(phi_cov)
  y = m1_cov / m0_cov * np.sin(phi_cov)

  ax[0].hist(np.hstack(phi_cov) * 180 / np.pi, density=True, bins='auto')
  ax[0].set_title('$\\xi_S . \\xi_D > 0$')
  ax[0].set_xlim([0, 360])
  ax[0].set_xticks([0, 180, 360])
  ax[0].set_xlabel('Pref. Location (°)')
  ax[0].set_ylabel('Density')

  ax[1].plot(x, y, 'o')
  ax[1].set_xlim([-2, 2])
  ax[1].set_ylim([-2, 2])
  # ax[1].set_title('$\\xi_S . \\xi_D > 0$')
  ax[1].set_xlabel('Sample Axis')
  ax[1].set_ylabel('Distractor Axis')

  plt.show() 
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/cc617a5700de5b2085defe78b55767a2f1b834c6.png]]

#+begin_src ipython

#+end_src

#+RESULTS:

**** h_S . xi_D >0

#+begin_src ipython
  rates_cov2, ksi_cov2 = run_X(conf_name, name, real_list, n_ini,
                               device='cuda',
                               LR_COV=[[1.0, 0.8, 0.0, 0.0],
                                       [0.8, 1.0, 0.2, 0.0],
                                       [0.0, 0.2, 1.0, 0.8],
                                       [0.0, 0.0, 0.8, 1.0]]
                               )
#+end_src

#+RESULTS:
: Elapsed (with compilation) = 0h 1m 19s

#+begin_src ipython
  rates_ord_cov2 = np.zeros(rates_cov2.shape)

  for i in real_list:      
      idx = np.arange(0, len(ksi_cov2[i][0]))
      theta = get_theta(ksi_cov2[i][0], ksi_cov2[i][2], GM=0, IF_NORM=0)

      index_order = theta.argsort()
      rates_ord_cov2[i] = rates_cov2[i][..., index_order]

  print(rates_ord_cov2.shape)

  m0_cov2, m1_cov2, phi_cov2 = decode_bump(rates_ord_cov2, axis=-1)
#+end_src

#+RESULTS:
: (50, 2, 8000)

#+begin_src ipython
  fig, ax = plt.subplots(1, 2, figsize=[2*height, height])

  x = m1_cov2 / m0_cov2 * np.cos(phi_cov2)
  y = m1_cov2 / m0_cov2 * np.sin(phi_cov2)

  ax[0].hist(np.hstack(phi_cov2) * 180 / np.pi, density=True, bins=20)
  ax[0].set_title('$h_S . \\xi_D > 0$')
  ax[0].set_xlim([0, 360])
  ax[0].set_xticks([0, 180, 360])
  ax[0].set_xlabel('Pref. Location (°)')
  ax[0].set_ylabel('Density')

  ax[1].plot(x, y, 'o')
  ax[1].set_xlim([-2, 2])
  ax[1].set_ylim([-2, 2])
  ax[1].set_title('$h_S . \\xi_D > 0$')
  ax[1].set_xlabel('Sample Axis')
  ax[1].set_ylabel('Distractor Axis')

  plt.show() 
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/cbeba9992b9dae06d86e4f6762cdf58ff692f4b6.png]]

#+begin_src ipython

#+end_src

#+RESULTS:

**** h_S . xi_D >0 and xi_S . xi_D>0

#+begin_src ipython
  rates_cov3, ksi_cov3 = run_X(conf_name, name, real_list, n_ini,
                               device='cuda',
                               LR_COV=[[1.0, 0.8, 0.2, 0.0],
                                       [0.8, 1.0, 0.2, 0.0],
                                       [0.2, 0.2, 1.0, 0.8],
                                       [0.0, 0.0, 0.8, 1.0]]
                               )
#+end_src

#+RESULTS:
: Elapsed (with compilation) = 0h 1m 19s

#+begin_src ipython
  rates_ord_cov3 = np.zeros(rates_cov3.shape)

  for i in real_list:      
      idx = np.arange(0, len(ksi_cov3[i][0]))
      theta = get_theta(ksi_cov3[i][0], ksi_cov3[i][2], GM=0, IF_NORM=0)

      index_order = theta.argsort()
      rates_ord_cov3[i] = rates_cov3[i][..., index_order]

  print(rates_ord_cov3.shape)

  m0_cov3, m1_cov3, phi_cov3 = decode_bump(rates_ord_cov3, axis=-1)
#+end_src

#+RESULTS:
: (50, 2, 8000)

#+begin_src ipython
  fig, ax = plt.subplots(1, 2, figsize=[2*height, height])

  x = m1_cov3 / m0_cov3 * np.cos(phi_cov3)
  y = m1_cov3 / m0_cov3 * np.sin(phi_cov3)

  # fig.suptitle('$\\xi_S . \\xi_D > 0$, $h_S . \\xi_D > 0$', fontsize=22)

  ax[0].hist(np.hstack(phi_cov3) * 180 / np.pi, density=True, bins='auto')
  ax[0].set_title('$\\xi_S . \\xi_D > 0$ and $h_S . \\xi_D > 0$')
  ax[0].set_xlim([0, 360])
  ax[0].set_xticks([0, 180, 360])
  ax[0].set_xlabel('Pref. Location (°)')
  ax[0].set_ylabel('Density')

  ax[1].plot(x, y, 'o')
  ax[1].set_xlim([-2, 2])
  ax[1].set_ylim([-2, 2])
  # ax[1].set_title('$\\xi_S . \\xi_D > 0$ \n $h_S . \\xi_D > 0$')
  ax[1].set_xlabel('Sample Axis')
  ax[1].set_ylabel('Distractor Axis')

  plt.show() 
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/6370a61fcdc6fb47a660c9d942897b5c2acad86c.png]]

#+begin_src ipython

#+end_src

#+RESULTS:

**** h_S . xi_D >0 and xi_S . xi_D>0

#+begin_src ipython
  rates_cov4, ksi_cov4 = run_X(conf_name, name, real_list, n_ini,
                               device='cuda',
                               LR_COV=[[1.0, 0.8, -0.2, 0.0],
                                       [0.8, 1.0, -0.2, 0.0],
                                       [-0.2, -0.2, 1.0, 0.8],
                                       [0.0, 0., 0.8, 1.0]]
                               )
#+end_src

#+RESULTS:
: Elapsed (with compilation) = 0h 1m 8s

#+begin_src ipython
  rates_ord_cov4 = np.zeros(rates_cov4.shape)

  for i in real_list:      
      idx = np.arange(0, len(ksi_cov4[i][0]))
      theta = get_theta(ksi_cov4[i][0], ksi_cov4[i][2], GM=0, IF_NORM=0)

      index_order = theta.argsort()
      rates_ord_cov4[i] = rates_cov4[i][..., index_order]

  print(rates_ord_cov4.shape)

  m0_cov4, m1_cov4, phi_cov4 = decode_bump(rates_ord_cov4, axis=-1)
#+end_src

#+RESULTS:
: (50, 2, 8000)

#+begin_src ipython
  fig, ax = plt.subplots(1, 2, figsize=[2*height, height])

  x = m1_cov4 / m0_cov4 * np.cos(phi_cov4)
  y = m1_cov4 / m0_cov4 * np.sin(phi_cov4)

  # fig.suptitle('$\\xi_S . \\xi_D > 0$, $h_S . \\xi_D > 0$', fontsize=22)

  ax[0].hist(np.hstack(phi_cov4) * 180 / np.pi, density=True, bins='auto')
  ax[0].set_title('$\\xi_S . \\xi_D > 0$ and $h_S . \\xi_D > 0$')
  ax[0].set_xlim([0, 360])
  ax[0].set_xticks([0, 180, 360])
  ax[0].set_xlabel('Pref. Location (°)')
  ax[0].set_ylabel('Density')

  ax[1].plot(x, y, 'o')
  ax[1].set_xlim([-2, 2])
  ax[1].set_ylim([-2, 2])
  # ax[1].set_title('$\\xi_S . \\xi_D > 0$ \n $h_S . \\xi_D > 0$')
  ax[1].set_xlabel('Sample Axis')
  ax[1].set_ylabel('Distractor Axis')

  plt.show() 
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/a2ced8049cf1196d48f5d31826cd329cf01feca8.png]]

#+begin_src ipython

#+end_src

#+RESULTS:





