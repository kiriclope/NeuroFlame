#+STARTUP: fold
#+TITLE: RNN with pytorch
#+PROPERTY: header-args:ipython :results both :exports both :async yes :session torch :kernel torch

* Notebook Settings

#+begin_src ipython 
  %load_ext autoreload
  %autoreload 2
  %reload_ext autoreload
  
  %run ../notebooks/setup.py
  %matplotlib inline
  %config InlineBackend.figure_format = 'png'
#+end_src

#+RESULTS:
: The autoreload extension is already loaded. To reload it, use:
:   %reload_ext autoreload
: Python exe
: /home/leon/mambaforge/envs/torch/bin/python

* Imports

#+begin_src ipython
  import sys
  sys.path.insert(0, '../')
  
  import torch
  import gc
  import pandas as pd
  from time import perf_counter

  from src.network import Network
  from src.plot_utils import plot_con
  from src.decode import decode_bump
  from src.utils import clear_cache
#+end_src

#+RESULTS:
* Helpers

#+begin_src ipython
  def convert_seconds(seconds):
      h = seconds // 3600
      m = (seconds % 3600) // 60
      s = seconds % 60
      return h, m, s
#+end_src

#+RESULTS:

#+begin_src ipython :tangle ../src/lr_utils.py
  import numpy as np
  def get_theta(a, b, GM=0, IF_NORM=0):

      u, v = a, b

      if GM:
          v = b - np.dot(b, a) / np.dot(a, a) * a

      if IF_NORM:
          u = a / np.linalg.norm(a)
          v = b / np.linalg.norm(b)

      return np.arctan2(v, u)
#+end_src

#+RESULTS:

#+begin_src ipython :tangle ../src/lr_utils.py
  def get_idx(model):
      ksi = model.PHI0.cpu().detach().numpy()
      print(ksi.shape)

      theta = get_theta(ksi[0], ksi[2], GM=0, IF_NORM=0)
      return theta.argsort()
#+end_src

#+RESULTS:

#+begin_src ipython :tangle ../src/lr_utils.py
  def get_overlap(model, rates):
      ksi = model.PHI0.cpu().detach().numpy()
      return rates @ ksi.T / rates.shape[-1]

#+end_src

#+RESULTS:

* Parameters

#+begin_src ipython
  REPO_ROOT = "/home/leon/models/NeuroTorch"
  conf_name = "config_EI.yml"
#+end_src

#+RESULTS:

* RNN with torch
** Single Trial
*** Model

#+begin_src ipython
  start = perf_counter()
  model = Network(conf_name, REPO_ROOT, VERBOSE=1, DEVICE='cuda', LIVE_FF_UPDATE=1, TASK='dual_rand', seed=0)  
  rates = model(RET_FF=1).cpu().numpy()  
  end = perf_counter()
  print("Elapsed (with compilation) = %dh %dm %ds" % convert_seconds(end - start))

  Ne = model.Na[0].detach().cpu().numpy()
  N = model.N_NEURON

  print('rates', rates.shape)
#+end_src

#+RESULTS:
#+begin_example
  Na tensor([2000,  500], device='cuda:0', dtype=torch.int32) Ka tensor([250., 250.], device='cuda:0') csumNa tensor([   0, 2000, 2500], device='cuda:0')
  Jab [1.0, -1.5, 1, -1]
  Ja0 [1.3, 1.0]
  Generating ff input
  times (s) 0.0 rates (Hz) [0.06, 2.12]
  times (s) 0.07 rates (Hz) [0.07, 2.15]
  times (s) 0.13 rates (Hz) [0.04, 1.25]
  times (s) 0.2 rates (Hz) [0.05, 1.22]
  times (s) 0.26 rates (Hz) [0.03, 1.23]
  times (s) 0.33 rates (Hz) [0.05, 1.37]
  times (s) 0.4 rates (Hz) [0.06, 1.45]
  times (s) 0.46 rates (Hz) [0.06, 1.32]
  times (s) 0.53 rates (Hz) [0.08, 2.17]
  times (s) 0.6 rates (Hz) [0.08, 2.16]
  times (s) 0.66 rates (Hz) [1.84, 2.21]
  times (s) 0.73 rates (Hz) [0.69, 2.19]
  times (s) 0.79 rates (Hz) [0.72, 2.35]
  times (s) 0.86 rates (Hz) [0.76, 2.48]
  times (s) 0.93 rates (Hz) [0.9, 2.72]
  times (s) 0.99 rates (Hz) [1.19, 3.2]
  times (s) 1.06 rates (Hz) [1.95, 4.47]
  times (s) 1.13 rates (Hz) [2.55, 5.7]
  times (s) 1.19 rates (Hz) [2.23, 5.75]
  times (s) 1.26 rates (Hz) [2.21, 5.88]
  times (s) 1.32 rates (Hz) [2.08, 6.12]
  times (s) 1.39 rates (Hz) [0.67, 4.02]
  times (s) 1.46 rates (Hz) [1.67, 4.85]
  times (s) 1.52 rates (Hz) [1.61, 5.04]
  times (s) 1.59 rates (Hz) [1.45, 4.77]
  times (s) 1.66 rates (Hz) [1.59, 4.96]
  times (s) 1.72 rates (Hz) [1.46, 4.81]
  times (s) 1.79 rates (Hz) [1.46, 4.77]
  times (s) 1.85 rates (Hz) [1.5, 4.81]
  times (s) 1.92 rates (Hz) [1.49, 4.81]
  times (s) 1.99 rates (Hz) [1.49, 4.81]
  times (s) 2.05 rates (Hz) [1.5, 4.83]
  times (s) 2.12 rates (Hz) [1.48, 4.8]
  times (s) 2.19 rates (Hz) [1.52, 4.84]
  times (s) 2.25 rates (Hz) [1.54, 4.87]
  times (s) 2.32 rates (Hz) [1.58, 4.93]
  times (s) 2.38 rates (Hz) [1.58, 4.95]
  times (s) 2.45 rates (Hz) [1.53, 4.91]
  times (s) 2.52 rates (Hz) [1.47, 4.84]
  times (s) 2.58 rates (Hz) [1.45, 4.78]
  times (s) 2.65 rates (Hz) [1.43, 4.74]
  times (s) 2.72 rates (Hz) [1.43, 4.72]
  times (s) 2.78 rates (Hz) [1.44, 4.74]
  times (s) 2.85 rates (Hz) [1.48, 4.79]
  times (s) 2.91 rates (Hz) [1.52, 4.85]
  times (s) 2.98 rates (Hz) [1.53, 4.88]
  times (s) 3.05 rates (Hz) [1.5, 4.86]
  times (s) 3.11 rates (Hz) [1.5, 4.84]
  times (s) 3.18 rates (Hz) [1.54, 4.88]
  times (s) 3.25 rates (Hz) [1.57, 4.92]
  times (s) 3.31 rates (Hz) [1.53, 4.88]
  times (s) 3.38 rates (Hz) [1.44, 4.78]
  times (s) 3.44 rates (Hz) [1.43, 4.74]
  times (s) 3.51 rates (Hz) [1.44, 4.73]
  times (s) 3.58 rates (Hz) [1.49, 4.78]
  times (s) 3.64 rates (Hz) [1.5, 4.82]
  times (s) 3.71 rates (Hz) [1.47, 4.79]
  times (s) 3.77 rates (Hz) [1.44, 4.74]
  times (s) 3.84 rates (Hz) [1.44, 4.73]
  times (s) 3.91 rates (Hz) [1.44, 4.71]
  times (s) 3.97 rates (Hz) [1.48, 4.75]
  times (s) 4.04 rates (Hz) [1.52, 4.81]
  times (s) 4.11 rates (Hz) [1.53, 4.84]
  times (s) 4.17 rates (Hz) [1.6, 4.92]
  times (s) 4.24 rates (Hz) [1.62, 4.97]
  times (s) 4.3 rates (Hz) [1.55, 4.91]
  times (s) 4.37 rates (Hz) [1.45, 4.79]
  times (s) 4.44 rates (Hz) [1.43, 4.73]
  times (s) 4.5 rates (Hz) [1.47, 4.74]
  times (s) 4.57 rates (Hz) [1.49, 4.76]
  times (s) 4.64 rates (Hz) [1.53, 4.81]
  times (s) 4.7 rates (Hz) [1.49, 4.79]
  times (s) 4.77 rates (Hz) [1.41, 4.68]
  times (s) 4.83 rates (Hz) [1.43, 4.67]
  times (s) 4.9 rates (Hz) [1.49, 4.73]
  times (s) 4.97 rates (Hz) [1.53, 4.77]
  times (s) 5.03 rates (Hz) [1.58, 4.83]
  times (s) 5.1 rates (Hz) [1.61, 4.9]
  times (s) 5.17 rates (Hz) [1.63, 4.94]
  times (s) 5.23 rates (Hz) [1.61, 4.94]
  times (s) 5.3 rates (Hz) [1.57, 4.89]
  times (s) 5.36 rates (Hz) [1.62, 4.95]
  times (s) 5.43 rates (Hz) [1.67, 5.01]
  times (s) 5.5 rates (Hz) [1.71, 5.08]
  times (s) 5.56 rates (Hz) [1.69, 5.08]
  times (s) 5.63 rates (Hz) [1.84, 5.28]
  times (s) 5.7 rates (Hz) [1.91, 5.42]
  times (s) 5.76 rates (Hz) [1.9, 5.48]
  times (s) 5.83 rates (Hz) [1.82, 5.43]
  times (s) 5.89 rates (Hz) [1.75, 5.36]
  times (s) 5.96 rates (Hz) [1.67, 5.24]
  times (s) 6.03 rates (Hz) [1.66, 5.18]
  times (s) 6.09 rates (Hz) [1.62, 5.13]
  times (s) 6.16 rates (Hz) [1.56, 5.02]
  times (s) 6.23 rates (Hz) [1.55, 4.98]
  times (s) 6.29 rates (Hz) [1.58, 5.01]
  times (s) 6.36 rates (Hz) [1.59, 5.02]
  times (s) 6.42 rates (Hz) [1.57, 4.98]
  times (s) 6.49 rates (Hz) [1.6, 5.01]
  times (s) 6.56 rates (Hz) [1.6, 5.0]
  times (s) 6.62 rates (Hz) [1.57, 4.98]
  Elapsed (with compilation) = 0h 0m 2s
  rates (1, 101, 2000)
#+end_example
#+RESULTS:

#+begin_src ipython
  overlap = get_overlap(model, rates)
  print(overlap.shape)

  idx = get_idx(model)
  rates_ordered = rates[..., idx]

  m0, m1, phi = decode_bump(rates_ordered, axis=-1)
  print(m0.shape)
#+end_src

#+RESULTS:
: (1, 101, 4)
: (4, 2000)
: (1, 101)

#+begin_src ipython
  print(torch.cuda.memory_allocated()/100000)
  # del model
  clear_cache()
  print(torch.cuda.memory_allocated()/100000)
#+end_src

#+RESULTS:
: 506.2912
: 506.2912

*** Dynamics

#+begin_src ipython
  ff_input = model.ff_input.cpu().detach().numpy()
  print(ff_input.shape)

  fig, ax = plt.subplots(1, 2, figsize=(2*width, height))
  
  ax[0].plot(ff_input[0, :, :5])
  ax[0].plot(ff_input[0, :, -5:])
  ax[0].set_xlabel('Step')
  ax[0].set_ylabel('FF Input')

  ax[1].imshow(ff_input[0].T, cmap='jet', vmin=0, aspect='auto')
  ax[1].set_xlabel('Step')
  ax[1].set_ylabel('Neuron #')
  ax[1].set_ylim([0, Ne])
  plt.show()
#+end_src

#+RESULTS:
:RESULTS:
: (1, 101, 2000)
[[file:./.ob-jupyter/981b3ed31be68cfb7939f9421a5aefd6cec91093.png]]
:END:

#+begin_src ipython
  fig, ax = plt.subplots(1, 2, figsize=(2*width, height))
  
  r_max = 15

  ax[0].imshow(rates[0].T, aspect='auto', cmap='jet', vmin=0, vmax=r_max, origin='lower')
  ax[0].set_ylabel('Neuron #')
  ax[0].set_xlabel('Step')

  ax[1].imshow(rates_ordered[0].T, aspect='auto', cmap='jet', vmin=0, vmax=r_max)
  ax[1].set_ylabel('Pref. Location (°)')
  ax[1].set_xlabel('Step')
  ax[1].set_yticks(np.linspace(0, Ne, 5), np.linspace(360, 0, 5).astype(int))
  # ax[0][1].colorbar()

  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/8a52ec47d48d3e43cca2c2c78fd568af0775d41e.png]]

#+begin_src ipython
  fig, ax = plt.subplots(1, 2, figsize=(2*width, height))

  ax[0].plot((m1.T/m0.T))
  ax[0].set_xlabel('Step')
  ax[0].set_ylabel('$\mathcal{F}_1$')

  ax[1].plot((phi.T * 180 / np.pi))
  ax[1].set_yticks(np.linspace(0, 360, 5).astype(int), np.linspace(0, 360, 5).astype(int))
  ax[1].set_xlabel('Step')
  ax[1].set_ylabel('Phase (°)')
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/e52a12274529ae91e9a96dfb77d09dafb1b7297c.png]]

#+begin_src ipython

#+end_src

#+RESULTS:

** Multiple initializations
*** Parameters

#+begin_src ipython
  seed = np.random.randint(100)
  print(seed)
#+end_src

#+RESULTS:
: 45

*** Simulation

#+begin_src ipython
  LR_COV = [[1.0, 1.0, 0.0, 0.0],
            [0.8, 1.0, 0., 0.0],
            [0.0, 0., 1.0, 0.8],
            [0.0, 0.0, 0.8, 1.0]]

  start = perf_counter()
  model = Network(conf_name, REPO_ROOT, VERBOSE=0, DEVICE='cuda',
                  N_BATCH=100, SEED=seed, LR_COV=LR_COV,
                  TASK='dual_rand', LIVE_FF_UPDATE=1, DURATION=10)
  
  rates = model(RET_FF=1).detach().cpu().numpy()
  end = perf_counter()

  print("Elapsed (with compilation) = %dh %dm %ds" % convert_seconds(end - start))
  print('rates', rates.shape)
#+end_src

#+RESULTS:
: Elapsed (with compilation) = 0h 0m 4s
: rates (100, 101, 2000)

#+begin_src ipython
  plt.hist(model.phase.cpu().numpy())
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/49f9a6e46296e81fdbafa6773d46dad611d29b71.png]]

*** Results 

#+begin_src ipython
  Ne = model.Na[0].detach().cpu().numpy()
  N = model.N_NEURON

  ff_input = model.ff_input.cpu().detach().numpy()
  print(ff_input.shape)

  fig, ax = plt.subplots(1, 2, figsize=(2*width, height))

  ax[0].plot(ff_input[0, :, :5])
  ax[0].plot(ff_input[1, :, :5])
  ax[0].set_xlabel('Step')
  ax[0].set_ylabel('FF Input')

  ax[1].imshow(ff_input[1].T, cmap='jet', vmin=0, vmax= 400, aspect='auto')
  ax[1].set_xlabel('Step')
  ax[1].set_ylabel('Neuron #')
  ax[1].set_ylim([0, Ne])
  plt.show()
#+end_src

#+RESULTS:
:RESULTS:
: (100, 101, 2000)
[[file:./.ob-jupyter/aa7ac2ec376e39fc0269b017bb9223d6acf6a8e0.png]]
:END:

#+begin_src ipython
  print(rates.mean(-1).shape)
  plt.plot(rates.mean(-1).T)
  plt.xlabel('Step')
  plt.ylabel('Rates (Hz)')
  plt.show()
#+end_src

#+RESULTS:
:RESULTS:
: (100, 101)
[[file:./.ob-jupyter/d8025483b72bc5c4d79dc2863076b12576caf8ed.png]]
:END:

#+begin_src ipython
  idx = get_idx(model)
  rates_ordered = rates[..., idx]
  print(rates_ordered.shape)
#+end_src

#+RESULTS:
: (4, 2000)
: (100, 101, 2000)

#+begin_src ipython
  overlap = get_overlap(model, rates)
  print(overlap.T.shape)
#+end_src

#+RESULTS:
: (4, 101, 100)

#+begin_src ipython
  fig, ax = plt.subplots(1, 3, figsize=[2*width, height])

  ax[0].plot(overlap.T[0])
  ax[0].set_ylabel('Overlap on $\\xi_1$ (Hz)')
  ax[0].set_xlabel('Step')

  ax[1].plot(overlap.T[1])
  ax[1].set_ylabel('Overlap on $\\xi_2$ (Hz)')
  ax[1].set_xlabel('Step')

  ax[2].plot(overlap.T[2])
  ax[2].set_ylabel('Overlap on $\\xi_3$ (Hz)')
  ax[2].set_xlabel('Step')

  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/55b31c5726fcad9f5a77cb60ed497ee8b062c6b3.png]]

#+begin_src ipython
  m0, m1, phi = decode_bump(rates_ordered, axis=-1)
  print(m0.shape)
#+end_src

#+RESULTS:
: (100, 101)

#+begin_src ipython
  fig, ax = plt.subplots(1, 3, figsize=[2.2*width, height])

  ax[0].plot(m0.T)
  #ax[0].set_ylim([0, 360])
  #ax[0].set_yticks([0, 90, 180, 270, 360])
  ax[0].set_ylabel('$\mathcal{F}_0$ (Hz)')
  ax[0].set_xlabel('Step')

  ax[1].plot(m1.T)
  # ax[1].set_ylim([0, 360])
  # ax[1].set_yticks([0, 90, 180, 270, 360])
  ax[1].set_ylabel('$\mathcal{F}_1$ (Hz)')
  ax[1].set_xlabel('Step')

  ax[2].plot(phi.T * 180 / np.pi, alpha=.2)
  ax[2].set_ylim([0, 360])
  ax[2].set_yticks([0, 90, 180, 270, 360])
  ax[2].set_ylabel('Phase (°)')
  ax[2].set_xlabel('Step')

  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/574c12c00ea27d7ae3dba6465f530ae881084f7c.png]]

#+begin_src ipython
  print(rates_ordered.shape)

  plt.imshow(rates_ordered[0].T, aspect='auto', cmap='jet', vmin=0, vmax=10)
  plt.ylabel('Pref. Location (°)')
  plt.xlabel('Time (au)')
  plt.yticks(np.linspace(0, rates_ordered.shape[-1], 5), np.linspace(0, 360, 5).astype(int))
  plt.colorbar()
  plt.show()
#+end_src

#+RESULTS:
:RESULTS:
: (100, 101, 2000)
[[file:./.ob-jupyter/414f44b4f47032031f91dea17c85ddcec8eb3fd8.png]]
:END:

#+begin_src ipython
  print(m0.shape)
  x = m1[:, -1]/ m0[:, -1] * np.cos(phi[:, -1])
  y = m1[:, -1] / m0[:, -1] * np.sin(phi[:, -1])

  fig, ax = plt.subplots(figsize=(height, height))
  ax.plot(x, y, 'o')
  ax.set_xlim([-2, 2])
  ax.set_ylim([-2, 2])
  plt.show()
#+end_src

#+RESULTS:
:RESULTS:
: (100, 101)
[[file:./.ob-jupyter/e44db61204f86370be4a7ae8fbaa4ba84f38d797.png]]
:END:

#+begin_src ipython

#+end_src

#+RESULTS:

** Behavior
*** Helpers

#+begin_src ipython
  def run_behavior(conf_name, cov_list, n_ini, seed, device='cuda', **kwargs):
      start = perf_counter()

      rates = []
      ksi = []
      with torch.no_grad():
          for cov in cov_list:

              model = Network(conf_name, REPO_ROOT, DEVICE=device,
                              LR_COV = [[1.0, 0.9, 0.0, 0.0],
                                        [0.9, 1.0, cov, 0.0],
                                        [0.0, cov, 1.0, 0.9],
                                        [0.0, 0.0, 0.9, 1.0]],
                              LIVE_FF_UPDATE=1,
                              VERBOSE=0, SEED=seed, N_BATCH=2*n_ini, **kwargs)

              rates.append(model().cpu().detach().numpy())
              ksi.append(model.PHI0.cpu().detach().numpy())

              model.cpu()
              del model

              gc.collect()
              torch.cuda.empty_cache()
              
      end = perf_counter()

      print("Elapsed (with compilation) = %dh %dm %ds" % convert_seconds(end - start))

      return np.array(rates), np.array(ksi)
#+end_src

#+RESULTS:
: bdbeee11-661c-4836-a988-bf74e9dab3c4

*** Parameters

#+begin_src ipython
  REPO_ROOT = "/home/leon/models/NeuroTorch"
  conf_name = "config_EI.yml"
#+end_src

#+RESULTS:
: 6469e188-1595-4d8e-83e4-ac6458ed45f6

#+begin_src ipython
  cov_list = np.linspace(0.1, 0, 5)
  print(cov_list)
  n_ini = 32
  seed = np.random.randint(100)
  # 34, 53
  print(seed)
#+end_src

#+RESULTS:
: 38ec7f71-c23b-4ede-984b-ebac6c840068

#+begin_src ipython
  def ret_overlap(rates, ksi):
      rates_ord = np.zeros(rates.shape)
      overlap = []

      for i in range(len(cov_list)):
          theta = get_theta(ksi[i][0], ksi[i][2], GM=0, IF_NORM=0)
          
          overlap.append(rates[i] @ ksi[i].T / rates.shape[-1])

          index_order = theta.argsort()
          rates_ord[i] = rates[i][..., index_order]

      return np.array(overlap), rates_ord
  #+end_src

#+RESULTS:
: eb610161-0192-4199-b9a5-15ad192b4e41

*** Single run

#+begin_src ipython
  I0 = [.1, 0.0, 0.0]
  rates, ksi = run_behavior(conf_name, cov_list, n_ini, seed, device='cuda', I0=I0)
#+end_src

#+RESULTS:
: 17a2e5b3-e34f-40df-af8f-d4ffd21827c3

#+begin_src ipython
  print(rates.shape)
  print(ksi.shape)
#+end_src

#+RESULTS:
: 80cf63ab-dd43-45c2-942b-676430019681

#+begin_src ipython
  I0 = [.1, .1, 0.0]
  ratesGo, ksiGo = run_behavior(conf_name, cov_list, n_ini, seed, device='cuda', I0=I0)
#+end_src

#+RESULTS:
: 85e78419-e33b-4103-928f-ca8e183e6c0a

#+begin_src ipython
  print(ratesGo.shape)
  print(ksiGo.shape)
#+end_src

#+RESULTS:
: 08e534da-f709-4bc3-817b-2043637d5b5f

#+begin_src ipython
  overlap1, rates1 = ret_overlap(rates, ksi)
  overlap2, rates2 = ret_overlap(ratesGo, ksiGo)
#+end_src

#+RESULTS:
: ec34a4c1-cbbf-460b-ae13-5f95ef30a6c5

#+begin_src ipython
  print(overlap1.shape)
  print(overlap2.shape)
#+end_src

#+RESULTS:
: 6b65d8d2-9c1a-497a-b263-5f37f1607e9e

#+begin_src ipython
  # n_ini = 16
  fig, ax = plt.subplots(1, 2, figsize=(2*width, height))

  ax[0].plot(overlap1[:, :n_ini, -5:, 0].mean((1,2)), '-rs')
  ax[0].plot(overlap1[:, n_ini:, -5:, 0].mean((1,2)), '-ro')
  ax[0].set_ylabel('Sample Overlap')
  ax[0].set_xlabel('Day')
  ax[0].set_title('DPA')

  ax[1].plot(overlap2[:, :n_ini, -5:, 0].mean((1,2)), '-bs')
  ax[1].plot(overlap2[:, n_ini:, -5:, 0].mean((1,2)), '-bo')
  ax[1].set_ylabel('Sample Overlap')
  ax[1].set_xlabel('Day')
  ax[1].set_title('Dual Go')

  plt.show()
#+end_src

#+RESULTS:
: 287ed627-d592-4dec-a232-2c604b2a2254

#+begin_src ipython
  readout1A = overlap1[:, :n_ini, -5:, 0]
  readout1B = overlap1[:, n_ini:, -5:, 0]

  readout1 = np.stack((readout1A, readout1B))
  # print(readout1.shape)

  perf1 = (readout1[0]>0).mean((1, 2))
  perf1 += (readout1[1]<0).mean((1, 2))

  readout2A = overlap2[:, :n_ini, -5:, 0]
  readout2B = overlap2[:, n_ini:, -5:, 0]

  readout2 = np.stack((readout2A, readout2B))
  print((readout2[0]>0).shape)

  perf2 = (readout2[0]>0).mean((1, 2))

  perf2 += (readout2[1]<0).mean((1, 2))

  plt.plot(perf1/2, 'r')
  plt.plot(perf2/2, 'b')

  plt.ylabel('Performance')
  plt.xlabel('Day')
  plt.show()
#+end_src
#+RESULTS:
: edb812bc-b3e1-4d54-ad6f-6acc4dc6bcb1

#+begin_src ipython

#+end_src

#+RESULTS:
: ef075384-d47e-414a-90c4-e7e2c9e3e3a4

**** Performance from phase

#+begin_src ipython
  def get_perf(rates):
      m0, m1, phi = decode_bump(rates, axis=-1)
      x = m1[..., -1] / m0[..., -1] * np.cos(phi[..., -1])
      performance = (x[: , :n_ini] < 0).mean(1) * 100
      performance += (x[: , n_ini:] > 0).mean(1) * 100

      return performance / 2
#+end_src

#+RESULTS:
: fc1e26b3-1eaa-48be-86b2-024e69854ecc

#+begin_src ipython
  perf1 = get_perf(rates1)
  print(perf1)
  perf2 = get_perf(rates2)
  print(perf2)

  plt.plot(perf1, 'r')
  plt.plot(perf2, 'b')
  plt.ylabel('Performance')
  plt.xlabel('Day')
  plt.show()
#+end_src

#+RESULTS:
: 2c0bfec5-ef5b-4372-a2ad-12c4c338d7d5

**** Single

#+begin_src ipython
  ini = -1
  overlap = overlap2.copy()
  print(overlap1[ini].shape)
  m0, m1, phi = decode_bump(rates2, axis=-1)
  print(m0[ini].shape)
#+end_src

#+RESULTS:
: fd7b9aa1-e4e1-4f51-8789-d17f7db67d95

#+begin_src ipython
  fig, ax = plt.subplots(1, 3, figsize=[2*width, height])

  ax[0].plot(overlap[ini, ..., 0].T, alpha=.2)
  ax[0].set_ylabel('Overlap on $\\xi_1$ (Hz)')
  ax[0].set_xlabel('Step')

  ax[1].plot(overlap[ini, ..., 1].T, alpha=.2)
  ax[1].set_ylabel('Overlap on $\\xi_2$ (Hz)')
  ax[1].set_xlabel('Step')

  ax[2].plot(overlap[ini, ..., 2].T, alpha=.2)
  ax[2].set_ylabel('Overlap on $\\xi_3$ (Hz)')
  ax[2].set_xlabel('Step')

  plt.show()
#+end_src

#+RESULTS:
: 25e0e1cc-5500-4329-8b45-aecc25ff0db6

#+begin_src ipython
  fig, ax = plt.subplots(1, 3, figsize=[2*width, height])

  ax[0].plot(m0[ini].T)
  #ax[0].set_ylim([0, 360])
  #ax[0].set_yticks([0, 90, 180, 270, 360])
  ax[0].set_ylabel('$\mathcal{F}_0$ (Hz)')
  ax[0].set_xlabel('Step')

  ax[1].plot(m1[ini].T)
  # ax[1].set_ylim([0, 360])
  # ax[1].set_yticks([0, 90, 180, 270, 360])
  ax[1].set_ylabel('$\mathcal{F}_1$ (Hz)')
  ax[1].set_xlabel('Step')

  ax[2].plot(phi[ini].T * 180 / np.pi)
  ax[2].set_ylim([0, 360])
  ax[2].set_yticks([0, 90, 180, 270, 360])
  ax[2].set_ylabel('Phase (°)')
  ax[2].set_xlabel('Step')

  plt.show()
#+end_src

#+RESULTS:
: 3ce2cb0b-095a-431e-90e9-5335eb5b587d

#+begin_src ipython
  x = m1[ini, ..., -1] / m0[ini, ..., -1] * np.cos(phi[ini, ..., -1])
  y = m1[ini, ..., -1] / m0[ini, ..., -1] * np.sin(phi[ini, ..., -1])

  fig, ax = plt.subplots(figsize=(height, height))
  ax.plot(x.T, y.T, 'o')
  ax.set_xlim([-2, 2])
  ax.set_ylim([-2, 2])
  plt.show()
#+end_src

#+RESULTS:
: 0560a77e-6ac5-4101-860c-7e5e11b5faf1

#+begin_src ipython

#+end_src

#+RESULTS:
: 967bb0d9-cf4d-4485-b938-41f845aebd4d

** Run

#+begin_src ipython
  I0 = [.1, 0.0, 0.0]
  rates_list = []
  ksi_list = []
  
  for i in range(10):
      rates, ksi = run_behavior(conf_name, cov_list, n_ini, seed=i, device='cuda', I0=I0)
      rates_list.append(rates)
      ksi_list.append(ksi)

  rates_list = np.array(rates_list)
  ksi_list = np.array(ksi_list)
#+end_src

#+RESULTS:
: 97aedb22-552b-4770-95c6-486002328ba6

#+begin_src ipython
  overlap_list, rate_list = [], []
  for i in range(rates_list.shape[0]):
      overlap, rates = ret_overlap(rates_list[i], ksi_list[i])
      rate_list.append(rates)
      overlap_list.append(overlap)

  rate_list = np.array(rate_list)
  overlap_list = np.array(overlap_list)
#+end_src

#+RESULTS:
: 22d4f76f-5b72-46d0-8454-5530440549f1

#+begin_src ipython
  print(overlap_list.shape)
#+end_src

#+RESULTS:
: 5d102ca8-c0d0-40bb-9bcb-23f1b81e065b

#+begin_src ipython
  readoutA = overlap_list[..., :n_ini, -5:, 0]
  readoutB = overlap_list[..., n_ini:, -5:, 0]

  readout = np.stack((readoutA, readoutB))
  print(readout.shape)
#+end_src

#+RESULTS:
: ee46671c-a6db-4558-99d9-3e86c680f83a

#+begin_src ipython
  perf = (readout[0]>0).mean((2, 3))
  perf += (readout[1]<0).mean((2, 3))

  print(perf.shape)

  plt.plot(perf.T/2)
  plt.show()
#+end_src

#+RESULTS:
: e7ad010c-fce6-4881-9e5d-f4361f42d22d

#+begin_src ipython
  print(rate_list.shape)
#+end_src

#+RESULTS:
: 8c363ab0-9ee1-4f95-a582-9dbab6ba5283

#+begin_src ipython
  m0, m1, phi = decode_bump(rate_list, axis=-1)
  print(m0.shape)
#+end_src

#+RESULTS:
: 33f5bdd5-bbdf-4e65-b6f4-07188305ec5f

#+begin_src ipython
  ini = 0
  
  x = m1[:, ini, ..., -1] / m0[:, ini, ..., -1] * np.cos(phi[:, ini, ..., -1])
  y = m1[:, ini, ..., -1] / m0[:, ini, ..., -1] * np.sin(phi[:, ini, ..., -1])

  fig, ax = plt.subplots(figsize=(height, height))
  ax.plot(x.T, y.T, 'o')
  ax.set_xlim([-2, 2])
  ax.set_ylim([-2, 2])
  plt.show()
#+end_src

#+RESULTS:
: 19250477-fd54-4953-b567-d44e622f29c3

** Different Realizations
*** Helpers

#+begin_src ipython
  def run_X(conf_name, real_list, n_ini, device='cuda', **kwargs):
      start = perf_counter()

      rates = []
      ksi = []
      with torch.no_grad():
          for real in real_list:

              model = Network(conf_name,
                              REPO_ROOT, DEVICE=device,  VERBOSE=0, SEED=0,
                              LIVE_FF_UPDATE=1, N_BATCH=n_ini, **kwargs)
              
              # model.I0[0] = .1
              # sample_A = model.init_ff_input()

              # model.I0[0] = -.1
              # sample_B = model.init_ff_input()

              # ff_input = torch.cat((sample_A, sample_B))
              ff_input = None
              ksi.append(model.PHI0.cpu().detach().numpy())
              rates.append(model(ff_input, REC_LAST_ONLY=1).cpu().detach().numpy())

              del model

      end = perf_counter()

      print("Elapsed (with compilation) = %dh %dm %ds" % convert_seconds(end - start))

      return np.array(rates), np.array(ksi)
#+end_src

#+RESULTS:
: fc5c378e-ddcb-4e1a-b392-56900303c724

*** Parameters

#+begin_src ipython
  REPO_ROOT = "/home/leon/models/NeuroTorch"
  conf_name = "config_EI.yml"
#+end_src

#+RESULTS:
: dbf67752-e390-4a58-8262-7af41e049f28

#+begin_src ipython
  real_list = np.arange(0, 10)
  n_ini = 32
#+end_src

#+RESULTS:
: d8e77246-96e5-4e84-80ed-7535bf55239e

*** Run
**** Orthogonal

#+begin_src ipython
    rates, ksi = run_X(conf_name, real_list, n_ini,
                       device='cuda',
                       LR_COV=[[1.0, 0.9, 0.0, 0.0],
                               [0.9, 1.0, 0.0, 0.0],
                               [0.0, 0.0, 1.0, 0.9],
                               [0.0, 0.0, 0.9, 1.0]]
                       )
#+end_src

#+RESULTS:
: 0c1358a4-8f68-40de-8db2-a4bce776c999

#+begin_src ipython
  rates_ord = np.zeros(rates.shape)

  for i in real_list:
      idx = np.arange(0, len(ksi[i][0]))
      theta = get_theta(ksi[i][0], ksi[i][2], GM=0, IF_NORM=1)

      index_order = theta.argsort()
      rates_ord[i] = rates[i][ ..., index_order]
  print(rates_ord.shape)

  m0, m1, phi = decode_bump(rates_ord, axis=-1)
  print(m0.shape)
#+end_src

#+RESULTS:
: 462b3193-005b-45c1-8c16-6798a5947a11

#+begin_src ipython
  fig, ax = plt.subplots(1, 2, figsize=[2*height, height])

  x = m1 / m0 * np.cos(phi)
  y = m1 / m0 * np.sin(phi)

  ax[0].hist(np.hstack(phi) * 180 / np.pi, density=True, bins='auto')
  ax[0].set_title('$h_S . \\xi_D = 0$')
  ax[0].set_xlim([0, 360])
  ax[0].set_xticks([0, 180, 360])
  ax[0].set_xlabel('Pref. Location (°)')
  ax[0].set_ylabel('Density')

  ax[1].plot(x.T, y.T, 'o')
  ax[1].set_xlim([-2, 2])
  ax[1].set_ylim([-2, 2])
  ax[1].set_title('$h_S . \\xi_D = 0$')
  ax[1].set_xlabel('Sample Axis')
  ax[1].set_ylabel('Distractor Axis')

  plt.show()
#+end_src

#+RESULTS:
: 3ddb1838-49dd-4f95-8ec2-6392148b7c2c

#+begin_src ipython

#+end_src

#+RESULTS:
: a2e5eeaa-6530-4ae4-92b6-73f31d58e188


**** xi_S . xi_D >0

#+begin_src ipython
  rates_cov, ksi_cov = run_X(conf_name, real_list, n_ini,
                             device='cuda',
                             LR_COV=[[1.0, 0.9, 0.0, 0.0],
                                     [0.9, 1.0, 0.1, 0.0],
                                     [0.0, 0.1, 1.0, 0.9],
                                     [0.0, 0.0, 0.9, 1.0]]
                             )
#+end_src

#+RESULTS:
: 9d638fe0-c386-48eb-a01b-2ca39fdbcc72

#+begin_src ipython
  rates_ord_cov = np.zeros(rates_cov.shape)

  for i in real_list:
      idx = np.arange(0, len(ksi_cov[i][0]))
      theta = get_theta(ksi_cov[i][0], ksi_cov[i][2], GM=0, IF_NORM=1)

      index_order = theta.argsort()
      rates_ord_cov[i] = rates_cov[i][..., index_order]

  print(rates_ord_cov.shape)

  m0_cov, m1_cov, phi_cov = decode_bump(rates_ord_cov, axis=-1)
#+end_src

#+RESULTS:
: c3930a25-c07d-48d1-98c6-f183b51e2b61

#+begin_src ipython
  fig, ax = plt.subplots(1, 2, figsize=[2*height, height])

  x = m1_cov / m0_cov * np.cos(phi_cov)
  y = m1_cov / m0_cov * np.sin(phi_cov)

  ax[0].hist(np.hstack(phi_cov) * 180 / np.pi, density=True, bins='auto')
  ax[0].set_title('$\\xi_S . \\xi_D > 0$')
  ax[0].set_xlim([0, 360])
  ax[0].set_xticks([0, 180, 360])
  ax[0].set_xlabel('Pref. Location (°)')
  ax[0].set_ylabel('Density')

  ax[1].plot(x.T, y.T, 'o')
  ax[1].set_xlim([-2, 2])
  ax[1].set_ylim([-2, 2])
  # ax[1].set_title('$\\xi_S . \\xi_D > 0$')
  ax[1].set_xlabel('Sample Axis')
  ax[1].set_ylabel('Distractor Axis')

  plt.show()
#+end_src

#+RESULTS:
: 58ba395d-1eab-4a4b-946e-1854fbc60fde

#+begin_src ipython

#+end_src

#+RESULTS:
: c0aea610-9b42-40bc-87db-2748394101c0

**** h_S . xi_D >0

#+begin_src ipython
  rates_cov2, ksi_cov2 = run_X(conf_name, real_list, n_ini,
                               device='cuda',
                               LR_COV=[[1.0, 0.9, 0.0, 0.0],
                                       [0.9, 1.0, 0.0, 0.0],
                                       [0.0, 0.0, 0.5, 0.4],
                                       [0.0, 0.0, 0.4, 1.0]]
                               )
#+end_src

#+RESULTS:
: 33402515-9f77-4228-b080-12c30f496f13

#+begin_src ipython
  rates_ord_cov2 = np.zeros(rates_cov2.shape)

  for i in real_list:
      idx = np.arange(0, len(ksi_cov2[i][0]))
      theta = get_theta(ksi_cov2[i][0], ksi_cov2[i][2], GM=0, IF_NORM=0)

      index_order = theta.argsort()
      rates_ord_cov2[i] = rates_cov2[i][..., index_order]

  print(rates_ord_cov2.shape)

  m0_cov2, m1_cov2, phi_cov2 = decode_bump(rates_ord_cov2, axis=-1)
#+end_src

#+RESULTS:
: 5de18e77-e280-4035-87dd-b5b14b7e1b2e

#+begin_src ipython
  fig, ax = plt.subplots(1, 2, figsize=[2*height, height])

  x = m1_cov2 / m0_cov2 * np.cos(phi_cov2)
  y = m1_cov2 / m0_cov2 * np.sin(phi_cov2)

  ax[0].hist(np.hstack(phi_cov2) * 180 / np.pi, density=True, bins=20)
  ax[0].set_title('$h_S . \\xi_D > 0$')
  ax[0].set_xlim([0, 360])
  ax[0].set_xticks([0, 180, 360])
  ax[0].set_xlabel('Pref. Location (°)')
  ax[0].set_ylabel('Density')

  ax[1].plot(x.T, y.T, 'o')
  ax[1].set_xlim([-2, 2])
  ax[1].set_ylim([-2, 2])
  ax[1].set_title('$h_S . \\xi_D > 0$')
  ax[1].set_xlabel('Sample Axis')
  ax[1].set_ylabel('Distractor Axis')

  plt.show()
#+end_src

#+RESULTS:
: 80ccd588-7c3c-434d-986b-2cb711b5146f

#+begin_src ipython

#+end_src

#+RESULTS:
: 064ad313-80c4-476e-941a-e366e0127c95

**** h_S . xi_D >0 and xi_S . xi_D>0

#+begin_src ipython
  rates_cov3, ksi_cov3 = run_X(conf_name, real_list, n_ini,
                               device='cuda',
                               LR_COV=[[1.0, 0.8, 0.2, 0.0],
                                       [0.8, 1.0, 0.2, 0.0],
                                       [0.2, 0.2, 1.0, 0.8],
                                       [0.0, 0.0, 0.8, 1.0]]
                               )
#+end_src

#+RESULTS:
: 152cd0dd-5e85-4560-ab3e-06815ebee6cb

#+begin_src ipython
  rates_ord_cov3 = np.zeros(rates_cov3.shape)

  for i in real_list:
      idx = np.arange(0, len(ksi_cov3[i][0]))
      theta = get_theta(ksi_cov3[i][0], ksi_cov3[i][2], GM=0, IF_NORM=0)

      index_order = theta.argsort()
      rates_ord_cov3[i] = rates_cov3[i][..., index_order]

  print(rates_ord_cov3.shape)

  m0_cov3, m1_cov3, phi_cov3 = decode_bump(rates_ord_cov3, axis=-1)
#+end_src

#+RESULTS:
: 24912843-0fb5-4831-a632-f2d95a3a4dbc

#+begin_src ipython
  fig, ax = plt.subplots(1, 2, figsize=[2*height, height])

  x = m1_cov3 / m0_cov3 * np.cos(phi_cov3)
  y = m1_cov3 / m0_cov3 * np.sin(phi_cov3)

  # fig.suptitle('$\\xi_S . \\xi_D > 0$, $h_S . \\xi_D > 0$', fontsize=22)

  ax[0].hist(np.hstack(phi_cov3) * 180 / np.pi, density=True, bins='auto')
  ax[0].set_title('$\\xi_S . \\xi_D > 0$ and $h_S . \\xi_D > 0$')
  ax[0].set_xlim([0, 360])
  ax[0].set_xticks([0, 180, 360])
  ax[0].set_xlabel('Pref. Location (°)')
  ax[0].set_ylabel('Density')

  ax[1].plot(x, y, 'o')
  ax[1].set_xlim([-2, 2])
  ax[1].set_ylim([-2, 2])
  # ax[1].set_title('$\\xi_S . \\xi_D > 0$ \n $h_S . \\xi_D > 0$')
  ax[1].set_xlabel('Sample Axis')
  ax[1].set_ylabel('Distractor Axis')

  plt.show()
#+end_src

#+RESULTS:
: a2521f26-b362-4497-a8ea-87d635106432

#+begin_src ipython

#+end_src

#+RESULTS:
: 01b3f2a3-8b37-4722-90c2-422447a21158

**** h_S . xi_D >0 and xi_S . xi_D>0

#+begin_src ipython
  rates_cov4, ksi_cov4 = run_X(conf_name, real_list, n_ini,
                               device='cuda',
                               LR_COV=[[1.0, 0.9, 0.0, 0.0],
                                       [0.9, 1.0, 0.0, 0.0],
                                       [0.0, 0.0, 1.0, 0.2],
                                       [0.0, 0.0, 0.2, 1.0]]
                               )
#+end_src

#+RESULTS:
: d8fd5a9a-5c1c-4ee2-b627-f15e0987d728

#+begin_src ipython
  rates_ord_cov4 = np.zeros(rates_cov4.shape)
  
  for i in real_list:
      idx = np.arange(0, len(ksi_cov4[i][0]))
      theta = get_theta(ksi_cov4[i][0], ksi_cov4[i][2], GM=0, IF_NORM=0)

      index_order = theta.argsort()
      rates_ord_cov4[i] = rates_cov4[i][..., index_order]

  print(rates_ord_cov4.shape)

  m0_cov4, m1_cov4, phi_cov4 = decode_bump(rates_ord_cov4, axis=-1)
#+end_src

#+RESULTS:
: c9d85d60-0f28-4c8f-9f3c-9bd000507a07

#+begin_src ipython
  fig, ax = plt.subplots(1, 2, figsize=[2*height, height])

  x = m1_cov4 / m0_cov4 * np.cos(phi_cov4)
  y = m1_cov4 / m0_cov4 * np.sin(phi_cov4)

  # fig.suptitle('$\\xi_S . \\xi_D > 0$, $h_S . \\xi_D > 0$', fontsize=22)

  ax[0].hist(np.hstack(phi_cov4) * 180 / np.pi, density=True, bins='auto')
  ax[0].set_title('$\\xi_S . \\xi_D > 0$ and $h_S . \\xi_D > 0$')
  ax[0].set_xlim([0, 360])
  ax[0].set_xticks([0, 180, 360])
  ax[0].set_xlabel('Pref. Location (°)')
  ax[0].set_ylabel('Density')

  ax[1].plot(x.T, y.T, 'o')
  ax[1].set_xlim([-2, 2])
  ax[1].set_ylim([-2, 2])
  # ax[1].set_title('$\\xi_S . \\xi_D > 0$ \n $h_S . \\xi_D > 0$')
  ax[1].set_xlabel('Sample Axis')
  ax[1].set_ylabel('Distractor Axis')

  plt.show()
#+end_src

#+RESULTS:
: d573446a-afcb-483e-9458-77cc43618957

#+begin_src ipython

#+end_src

#+RESULTS:
: f7e96e6a-af94-4bac-b446-fe15945ff5fe
