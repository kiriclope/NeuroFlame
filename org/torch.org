#+STARTUP: fold
#+TITLE: RNN with pytorch
#+PROPERTY: header-args:ipython :results both :exports both :async yes :session torch :kernel torch

* Notebook Settings

#+begin_src ipython
  %load_ext autoreload
  %autoreload 2
  %reload_ext autoreload

  %run ../notebooks/setup.py
  %matplotlib inline
  %config InlineBackend.figure_format = 'png'
#+end_src

#+RESULTS:
: The autoreload extension is already loaded. To reload it, use:
:   %reload_ext autoreload
: Python exe
: /home/leon/mambaforge/envs/torch/bin/python

* Helpers
#+begin_src ipython
  def convert_seconds(seconds):
      h = seconds // 3600
      m = (seconds % 3600) // 60
      s = seconds % 60
      return h, m, s
#+end_src

#+RESULTS:

#+begin_src ipython
  def get_theta(a, b, GM=0, IF_NORM=0):

      if GM:          
          b = b - np.dot(b, a) / np.dot(a, a) * a

      if IF_NORM:
          u = a / np.linalg.norm(a)
          v = b / np.linalg.norm(b)
      else:
          u=a
          v=b

      return np.arctan2(v, u)
#+end_src

#+RESULTS:

#+begin_src ipython
  def normalize(v):
      return v / np.linalg.norm(v)

  def project(x, u):
      return x * u
  # return np.dot(x, u) * u

  def sort_by_angle(x, u, v):
      u_hat = normalize(u)
      v_hat = normalize(v)

      x_proj_u = project(x, u_hat)
      x_proj_v = project(x, v_hat)
      # x_proj = x_proj_u + x_proj_v
      theta = np.arctan2(x_proj_v, x_proj_u) + np.pi

      # cos_theta = np.dot(x_proj, u_hat) / np.linalg.norm(x_proj) * u_hat
      # sin_theta = np.dot(x_proj, v_hat) / np.linalg.norm(x_proj) * v_hat
      # theta = np.arctan2(sin_theta, cos_theta)

      # Pair up each element of x with the corresponding angle
      # x_angle_pairs = list(zip(x, theta))

      # Sort based on the angle
      # x_angle_pairs.sort(key=lambda pair: pair[1])

      # Extract the sorted elements
      # sorted_x = [pair[0] for pair in x_angle_pairs]

      return theta
#+end_src

** Data
#+begin_src ipython
  def get_rates_ini_phi(name, ini_list, phi_list):
    rates_list = []
    for ini in ini_list:
      for phi in phi_list:
        rates = np.load(REPO_ROOT + '/data/simul/%s_ini_%d_phi_%d.npy' % (name, ini, phi))
        rates_list.append(rates)

    rates_list = np.array(rates_list).reshape(len(ini_list), len(phi_list), rates.shape[0], rates.shape[1])
    print(rates_list.shape)
    return rates_list  
#+end_src

#+RESULTS:

#+begin_src ipython
  def get_df_ini_phi(rates):
      n_trials, n_phi, n_times, n_neurons = rates.shape

      # Create indices
      trials_ind, phi_ind, times_ind, neurons_ind = np.indices((n_trials, n_phi, n_times, n_neurons))

      # Construct DataFrame
      df = pd.DataFrame({
          'trial': trials_ind.flatten(),
          'phi': phi_ind.flatten(),
          'neuron': neurons_ind.flatten(),
          'time': times_ind.flatten(),
          'rates': rates.flatten()
      })

      return df

#+end_src

#+RESULTS:

#+begin_src ipython
  def load_data_ini_phi(name, ini_list, phi_list):
      rates = get_rates_ini_phi(name, ini_list, phi_list)
      df = get_df_ini_phi(rates)
      return df
#+end_src

#+RESULTS:

#+begin_src ipython
  def get_code_ini_phi(df):
      df_code = df.groupby(['time', 'trial', 'phi'] )['rates'].apply(decode_bump).reset_index()
      df_code[['m0', 'm1', 'phase']] = pd.DataFrame(df_code['rates'].tolist(), index=df_code.index)
      df_code = df_code.drop(columns=['rates'])
      
      end_point = df_code[df_code.time==df_code.time.iloc[-1]]
      end_point = end_point.drop(columns=['time'])
      print(end_point.head())  
      return df_code, end_point  
#+end_src

#+RESULTS:

#+begin_src ipython
  def get_precision(x):
      return x - circmean(x)
#+end_src

#+RESULTS:

** Simul

#+begin_src ipython
  import subprocess

  def gpu_memory_usage_percentage():
      total_mem_str = subprocess.check_output(["nvidia-smi", "--query-gpu=memory.total", "--format=csv,nounits,noheader"])
      used_mem_str = subprocess.check_output(["nvidia-smi", "--query-gpu=memory.used", "--format=csv,nounits,noheader"])
      
      total_mem_list = map(float, total_mem_str.decode('utf-8').strip().split('\n'))
      used_mem_list = map(float, used_mem_str.decode('utf-8').strip().split('\n'))

      mem_percentage_list = [(used_mem / total_mem) * 100.0 for total_mem, used_mem in zip(total_mem_list, used_mem_list)]

      return np.array(mem_percentage_list)

  memory_percentages = gpu_memory_usage_percentage()

  # The memory usage for each GPU is indexed from 0
  for index, percentage in enumerate(memory_percentages):
      print(f'GPU {index} Memory Usage: {percentage:.2f}%')

#+end_src

#+RESULTS:
: GPU 0 Memory Usage: 4.55%
: GPU 1 Memory Usage: 0.09%

#+begin_src ipython
  from time import sleep

  def check_gpu(device):
      memory_percentages = gpu_memory_usage_percentage()
      if device == 'cuda:0':
          if memory_percentages[0] > 75:
              while memory_percentages[1] > 75:
                  memory_percentages = gpu_memory_usage_percentage()
                  sleep(10)
              else:
                  device='cuda:1'
      else:
          if memory_percentages[1] > 75:
              while memory_percentages[0] > 75:
                  memory_percentages = gpu_memory_usage_percentage()
                  sleep(10)
              else:
                  device='cuda:0'
                  
      return device
#+end_src

#+RESULTS:

#+begin_src ipython
  device = check_gpu('cuda:0')
  print(device)
#+end_src

#+RESULTS:
: cuda:0

#+begin_src ipython
  # import multiprocessing
  # if multiprocessing.get_start_method(allow_none=True) != 'spawn':
  #   multiprocessing.set_start_method('spawn', force=True)
  # from multiprocessing import Process

  def run_ini_phi(conf, name, ini_list, phi_list):
      LOAD_MAT = 0
      SAVE_MAT = 1

      df_list = []
      for ini in ini_list:
          for phi in phi_list:

              print('##########################################')
              print("trial", ini, "phi", phi)
              print('##########################################')

              model = Network('%s.yml' % conf, '%s_ini_%d_phi_%d' % (name, ini, phi),
                              REPO_ROOT, LOAD_MAT=LOAD_MAT, SAVE_MAT=SAVE_MAT, PHI0=phi)
              
              model.run()
              # process = Process(target=model.run)
              # process.start()
              # process.join()
              # device = check_gpu(device)

              LOAD_MAT = 1
              SAVE_MAT = 0
#+end_src

#+RESULTS:

* RNN with torch
** Imports

#+begin_src ipython
  import sys
  sys.path.insert(0, '../')

  import pandas as pd
  from time import perf_counter  

  from src.network import Network
  from src.plot_utils import plot_con
  from src.decode import decode_bump
#+end_src

#+RESULTS:

** Balance

#+begin_src ipython
  REPO_ROOT = "/home/leon/models/NeuroTorch"
  K_list = [500, 1000, 1500, 2000, 2500]
  rates_list = []
  
  for K in K_list:
      model = Network('config_EI.yml', 'bump', REPO_ROOT, VERBOSE=0, DEVICE='cuda', K=K)
      rates = model.forward()
      rates_list.append(rates[-1])

#+end_src

#+RESULTS:

#+begin_src ipython
  rates = np.array(rates_list)
  print(rates.shape)
  
  rates = rates[:, 0, :30000]
  plt.plot(np.sqrt(K_list), np.mean(rates, axis=1) * np.sqrt(K_list), '-o')
  plt.xlabel('$\sqrt{K}$')
  plt.ylabel('$\sqrt{K}$ Rates')
  plt.show()
#+end_src

#+RESULTS:
:RESULTS:
: (5, 1, 40000)
[[file:./.ob-jupyter/b35420db36675c36fc60577d727e89b0db284f51.png]]
:END:

** Single Trial
*** Model

#+begin_src ipython
  REPO_ROOT = "/home/leon/models/NeuroTorch"
  model = Network('config_EI.yml', 'bump', REPO_ROOT, VERBOSE=1, DEVICE='cuda:1', PHI0=180)
  rates = model.forward()
#+end_src

#+RESULTS:
#+begin_example
  Na tensor([15000,  5000], device='cuda:1', dtype=torch.int32) Ka tensor([500., 500.], device='cuda:1') csumNa tensor([    0, 15000, 20000], device='cuda:1')
  Jab [1.0, -1.5, 1, -1]
  Ja0 [2.0, 1.0]
  ksi torch.Size([2, 15000])
  ksi . ksi1 tensor(26.2694, device='cuda:1', grad_fn=<DotBackward0>)
  Pij torch.Size([15000, 15000])
  Sparse random connectivity 
  with weak low rank structure, KAPPA 5.00
  Sparse random connectivity 
  Sparse random connectivity 
  Sparse random connectivity 
  times (s) 0.0 rates (Hz) [0.0, 2.75]
  times (s) 0.23 rates (Hz) [0.0, 2.82]
  times (s) 0.47 rates (Hz) [0.0, 2.88]
  times (s) 0.7 rates (Hz) [0.0, 2.86]
  STIM ON
  times (s) 0.93 rates (Hz) [125.93, 2.75]
  times (s) 1.16 rates (Hz) [100.35, 103.57]
  times (s) 1.4 rates (Hz) [103.38, 107.94]
  times (s) 1.63 rates (Hz) [108.05, 113.4]
  STIM OFF
  times (s) 1.86 rates (Hz) [48.48, 117.73]
  times (s) 2.09 rates (Hz) [24.15, 29.84]
  times (s) 2.33 rates (Hz) [17.75, 22.38]
  times (s) 2.56 rates (Hz) [13.3, 17.38]
  times (s) 2.79 rates (Hz) [10.32, 13.68]
  times (s) 3.02 rates (Hz) [8.24, 10.89]
  STIM ON
  times (s) 3.26 rates (Hz) [6.76, 9.31]
  times (s) 3.49 rates (Hz) [5.86, 8.66]
  times (s) 3.72 rates (Hz) [5.16, 7.47]
  times (s) 3.95 rates (Hz) [4.67, 7.05]
  STIM OFF
  times (s) 4.19 rates (Hz) [4.37, 6.79]
  times (s) 4.42 rates (Hz) [4.09, 6.52]
  times (s) 4.65 rates (Hz) [3.94, 6.11]
  times (s) 4.88 rates (Hz) [3.65, 5.94]
  STIM ON
  times (s) 5.12 rates (Hz) [3.66, 5.99]
  times (s) 5.35 rates (Hz) [3.56, 6.09]
  STIM OFF
  times (s) 5.58 rates (Hz) [3.43, 5.76]
  times (s) 5.81 rates (Hz) [3.19, 5.88]
  times (s) 6.05 rates (Hz) [3.21, 5.43]
  times (s) 6.28 rates (Hz) [3.11, 5.4]
  times (s) 6.51 rates (Hz) [3.1, 5.61]
  times (s) 6.74 rates (Hz) [3.03, 5.15]
  times (s) 6.98 rates (Hz) [2.97, 5.36]
  times (s) 7.21 rates (Hz) [3.0, 5.2]
  times (s) 7.44 rates (Hz) [2.9, 5.24]
  times (s) 7.67 rates (Hz) [2.89, 5.17]
  times (s) 7.91 rates (Hz) [2.8, 5.26]
  times (s) 8.14 rates (Hz) [2.76, 5.28]
  times (s) 8.37 rates (Hz) [2.68, 5.24]
  times (s) 8.6 rates (Hz) [2.64, 5.31]
  times (s) 8.84 rates (Hz) [2.64, 5.04]
  times (s) 9.07 rates (Hz) [2.65, 5.18]
  times (s) 9.3 rates (Hz) [2.66, 5.09]
  Elapsed (with compilation) = 21.75301519781351s
#+end_example

*** Analysis

#+begin_src ipython
  rates = rates[:, 0]
  print(rates.shape)
#+end_src

#+RESULTS:
: (41, 20000)

#+begin_src ipython
  print(rates.shape)
  r_max = 5 # * np.max(rates[-1, :15000])
  plt.imshow(rates.T[:15000], aspect='auto', cmap='jet', vmin=0, vmax=r_max, origin='lower')
  plt.colorbar()
  plt.show()
#+end_src

#+RESULTS:
:RESULTS:
: (41, 20000)
[[file:./.ob-jupyter/ee22e9ea1fbb69ddd196ef26ffadfa0391c94d14.png]]
:END:

#+RESULTS:

#+begin_src ipython
  ksi = model.ksi.cpu().detach().numpy()
  idx = np.arange(0, len(ksi[0]))
  # theta = sort_by_angle(idx, ksi[1], ksi[0])
  # print(theta.shape)
  theta = get_theta(ksi[0], ksi[1], GM=0, IF_NORM=1)
  # theta = np.arctan2(ksi[1], ksi[0])
  index_order = theta.argsort()
  # print(index_order)
  rates_ordered = rates[:, index_order]
#+end_src

#+RESULTS:

#+begin_src ipython
  plt.imshow(rates_ordered.T, aspect='auto', cmap='jet', vmin=0, vmax=2)
  plt.ylabel('Pref. Location (°)')
  plt.xlabel('Time (au)')
  plt.yticks(np.linspace(0, 15000, 5), np.linspace(0, 360, 5).astype(int))
  plt.colorbar()
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/e1d6f4e62523b316ff4cb3ef80039adb7fe794f3.png]]

#+begin_src ipython
  m0, m1, phi = decode_bump(rates_ordered, axis=-1)
#+end_src

#+RESULTS:

#+begin_src ipython
  plt.plot((phi * 180 / np.pi))
  plt.yticks(np.linspace(-180, 180, 5).astype(int), np.linspace(0, 360, 5).astype(int))  
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/6366479e14ecf5186128185083add8be90056d97.png]]

*** Connectivity

#+begin_src ipython
  print(model.Wab)
#+end_src

#+begin_src ipython
  Cij = model.Wab.weight.data.cpu().detach().numpy()
  plot_con(Cij.T)
#+end_src

#+begin_src ipython
  
#+end_src

#+RESULTS:

** Multiple Trials
*** Parameters

#+begin_src ipython
  REPO_ROOT = "/home/leon/models/NeuroTorch"
  conf_name = "config_EI.yml"
  name = "low_rank_ini"
#+end_src

#+RESULTS:

*** Simulation

#+begin_src ipython
  ini_list = np.arange(0, 10)

  start = perf_counter()
  model = Network(conf_name, name, REPO_ROOT, VERBOSE=0, DEVICE='cuda:1')
  rates = model.forward(ini_list=ini_list)
  end = perf_counter()
  print("Elapsed (with compilation) = %dh %dm %ds" % convert_seconds(end - start))
  print('rates', rates.shape)

#+end_src

#+RESULTS:
: Elapsed (with compilation) = 0h 0m 5s
: rates (5, 10, 20000)

*** Analysis

#+begin_src ipython
  ksi = model.ksi.cpu().detach().numpy()

  idx = np.arange(0, len(ksi[0]))
  theta = get_theta(ksi[1], ksi[0], GM=0, IF_NORM=0)

  index_order = theta.argsort()
  rates_ordered = rates[..., index_order]
  print(rates_ordered.shape)
#+end_src

#+RESULTS:
: (5, 10, 15000)

#+begin_src ipython
  m0, m1, phi = decode_bump(rates_ordered, axis=-1)
  print(m0.shape)
#+end_src

#+RESULTS:
: (5, 10)

#+begin_src ipython
  plt.plot(phi * 180 / np.pi + 180)
  plt.ylim([0, 180])
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/5f375931193568f18b00b547b5035828b16cfba1.png]]

#+begin_src ipython
  plt.imshow(rates_ordered[:, 3].T, aspect='auto', cmap='jet', vmin=0, vmax=4)
  plt.ylabel('Pref. Location (°)')
  plt.xlabel('Time (au)')
  plt.yticks(np.linspace(0, 15000, 5), np.linspace(-180, 180, 5).astype(int))
  plt.colorbar()
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/d2ebd4ef0a9298b1c230bdf8e9e58f4d520e19b8.png]]

#+begin_src ipython

#+end_src

*** Realizations

#+begin_src ipython
  def run_X(conf_name, name, real_list, ini_list, device='cuda:0', **kwargs):
      start = perf_counter()

      rates = []
      ksi = []
      for real in real_list:

          model = Network(conf_name, '%s_real_%d' % (name, real),
                          REPO_ROOT, DEVICE=device,  VERBOSE=0, SEED=0, **kwargs)

          ksi.append(model.ksi.cpu().detach().numpy())
          rates.append(model.forward(ini_list=ini_list))

          del model

      end = perf_counter()
      
      print("Elapsed (with compilation) = %dh %dm %ds" % convert_seconds(end - start))      

      return np.array(rates), np.array(ksi)
#+end_src

#+RESULTS:

#+begin_src ipython
  real_list = np.arange(0, 100)
  ini_list = np.arange(0, 1)
#+end_src

#+RESULTS:

#+begin_src ipython
  rates, ksi = run_X(conf_name, name, real_list, ini_list, device='cuda:0')
#+end_src

#+RESULTS:
: Elapsed (with compilation) = 0h 6m 21s

#+begin_src ipython
  print(rates.shape, ksi.shape)
#+end_src

#+RESULTS:
: (100, 5, 1, 20000) (100, 2, 15000)

#+begin_src ipython
  rates_ordered = rates[..., :15000]
  
  for i in real_list:
      idx = np.arange(0, len(ksi[i][0]))
      theta = get_theta(ksi[i][1], ksi[i][0], GM=0, IF_NORM=0)

      index_order = theta.argsort()
      rates_ordered[i] = rates[i][..., index_order]
  print(rates_ordered.shape)
#+end_src

n#+RESULTS:
: (100, 5, 1, 15000)

#+begin_src ipython
  m0, m1, phi = decode_bump(rates_ordered, axis=-1)
#+end_src

#+RESULTS:

#+begin_src ipython
  print(phi.shape)
  plt.plot(phi[...,0].T)
  plt.show()
#+end_src

#+RESULTS:
:RESULTS:
: (100, 5, 1)
[[file:./.ob-jupyter/4b908ead2c411f541a47fa2b6914fd0f7c81568e.png]]
:END:

#+begin_src ipython
  x = np.cos(phi)
  y = np.sin(phi)

  plt.plot(x[:, -1, 0], y[:, -1, 0], 'o')
  plt.show()
#+end_src

#+RESULTS:



[[file:./.ob-jupyter/a1c853e229b8d473c2795a5628ac49657141c18c.png]]

#+begin_src ipython
  rates_ortho = rates.copy()
#+end_src

#+RESULTS:

*** Behavior

#+begin_src ipython
  ini_list = np.arange(0, 10)
  phi_list = np.array([-1, 1])

  start = perf_counter()
  model = Network(conf_name, name, REPO_ROOT, VERBOSE=0, DEVICE='cuda:1')
  rates = model.forward(ini_list=ini_list, phi_list=phi_list)
  end = perf_counter()
  
  print("Elapsed (with compilation) = %dh %dm %ds" % convert_seconds(end - start))
  print('rates', rates.shape)
#+end_src

#+RESULTS:
: Elapsed (with compilation) = 0h 0m 39s
: rates (41, 20, 20000)

#+begin_src ipython
  rates = rates.reshape(rates.shape[0], len(ini_list), len(phi_list), -1)
  print(rates.shape)
#+end_src

#+RESULTS:
: (41, 10, 2, 20000)

#+begin_src ipython
  ksi = model.ksi.cpu().detach().numpy()
  idx = np.arange(0, len(ksi[0]))
  # theta = sort_by_angle(idx, ksi[1], ksi[0])
  # print(theta.shape)
  theta = get_theta(ksi[0], ksi[1], GM=0, IF_NORM=1)
  # theta = np.arctan2(ksi[1], ksi[0])
  index_order = theta.argsort()
  # print(index_order)
  rates_ordered = rates[..., index_order]
  print(rates_ordered.shape)
#+end_src

#+RESULTS:
: (41, 10, 2, 15000)

#+begin_src ipython
  m0, m1, phi = decode_bump(rates_ordered, axis=-1)
  print(m0.shape)
#+end_src

#+RESULTS:
: (41, 10, 2)

#+begin_src ipython
  plt.plot(phi[..., 0] * 180/np.pi)
  plt.plot(phi[..., 1] * 180/np.pi)
  plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/f5f9d0940c0e022eb509cf351bb6356892c29235.png]]
