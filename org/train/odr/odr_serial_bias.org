#+STARTUP: fold
#+TITLE: ODR serial bias
#+PROPERTY: header-args:ipython :results both :exports both :async yes :session odr_sb :kernel torch :exports results :output-dir ./figures/odr_sb :file (lc/org-babel-tangle-figure-filename)

* Notebook Settings

#+begin_src ipython
  %load_ext autoreload
  %autoreload 2
  %reload_ext autoreload

  %run ../../../notebooks/setup.py
  %matplotlib inline
  %config InlineBackend.figure_format = 'png'

  REPO_ROOT = "/home/leon/models/NeuroFlame"
  pal = sns.color_palette("tab10")
#+end_src

#+RESULTS:
: The autoreload extension is already loaded. To reload it, use:
:   %reload_ext autoreload
: Python exe
: /home/leon/mambaforge/envs/torch/bin/python

* Imports

#+begin_src ipython
  import torch
  import torch.nn as nn
  import torch.optim as optim
  import torch.nn.functional as F
  from torch.utils.data import Dataset, TensorDataset, DataLoader
  from scipy.stats import binned_statistic
#+end_src

#+RESULTS:

#+begin_src ipython
  import sys
  sys.path.insert(0, '../../../')

  import pandas as pd
  import torch.nn as nn
  from time import perf_counter
  from scipy.stats import circmean

  from src.network import Network
  from src.plot_utils import plot_con
  from src.decode import decode_bump, circcvl, decode_bump_torch
  from src.lr_utils import masked_normalize, clamp_tensor, normalize_tensor
#+end_src

#+RESULTS:

#+begin_src ipython :tangle ../src/torch/utils.py
  import pickle as pkl
  import os

  def pkl_save(obj, name, path="."):
      os.makedirs(path, exist_ok=True)
      destination = path + "/" + name + ".pkl"
      print("saving to", destination)
      pkl.dump(obj, open(destination, "wb"))


  def pkl_load(name, path="."):
      source = path + "/" + name + '.pkl'
      print('loading from', source)
      return pkl.load(open( source, "rb"))

#+end_src

#+RESULTS:

* Helpers


#+begin_src ipython
def map2center(angles):
    """Map angles from [0, 2π] to [-π, π] using PyTorch tensors."""
    return np.where(angles > np.pi, angles - 2 * np.pi, angles)

def map2pos(angles):
    """Map angles from [-π, π] to [0, 2π] using PyTorch tensors."""
    return np.where(angles < 0, angles + 2 * np.pi, angles)
#+end_src

#+RESULTS:

#+begin_src ipython
def maptens2center(angles):
    """Map angles from [0, 2π] to [-π, π] using PyTorch tensors."""
    return torch.where(angles > torch.pi, angles - 2 * torch.pi, angles)

def maptens2pos(angles):
    """Map angles from [-π, π] to [0, 2π] using PyTorch tensors."""
    return torch.where(angles < 0, angles + 2 * torch.pi, angles)
#+end_src

#+RESULTS:

#+begin_src ipython
def add_vlines(model, ax=None):

    if ax is None:
        for i in range(len(model.T_STIM_ON)):
            plt.axvspan(model.T_STIM_ON[i], model.T_STIM_OFF[i], alpha=0.25)
    else:
        for i in range(len(model.T_STIM_ON)):
            ax.axvspan(model.T_STIM_ON[i], model.T_STIM_OFF[i], alpha=0.25)

#+end_src

#+RESULTS:

* Model

#+begin_src ipython
kwargs = {
    'GAIN': 1.0,
    'DURATION': 12.0,
    'T_STEADY': 4,
    'T_STIM_ON': [1.0, 4.0, 6.0, 10.0],
    'T_STIM_OFF': [2.0, 5.0, 7.0, 12.0],
    'I0': [1.0, -2.0, 1.0, -2.0],
    'PHI0': [180.0, 180, 180, 180],
    'SIGMA0': [1.0, 0.0, 1.0, 0.0],
    'RANDOM_DELAY': 0,
    'MIN_DELAY': 2,
    'MAX_DELAY': 5,
    'USE': 0.03,
    'TAU_FAC': 2.0,
    'TAU_REC': 0.2,
    'IF_ADAPT': 0,
    'A_ADAPT': 0.25,
    'TAU_ADAPT': 5.0,
    'IF_FF_ADAPT': 1,
    'A_FF_ADAPT': 0.15,
    'TAU_FF_ADAPT': 10.0,
    'RATE_NOISE': 0,
    'VAR_RATE': 10.0,
    'REP_BIAS': 0.0,
    'REP_VAR': 2.5,
}
#+end_src

#+RESULTS:

#+begin_src ipython
REPO_ROOT = "/home/leon/models/NeuroFlame"
conf_name = "train_odr_EI.yml"
DEVICE = 'cuda'
seed = np.random.randint(0, 1e6)

seed = 3
print('seed', seed)
#+end_src

#+RESULTS:
: seed 3

#+begin_src ipython
N_BATCH = 128*6
model = Network(conf_name, REPO_ROOT, VERBOSE=0, DEVICE=DEVICE, SEED=seed, N_BATCH=N_BATCH, **kwargs)
#+end_src

#+RESULTS:

#+begin_src ipython
model_state_dict = torch.load('../models/odr/odr_%d.pth' % seed)
model.load_state_dict(model_state_dict);
model.eval();
#+end_src

#+RESULTS:

#+begin_src ipython
print(model.J_STP.item())
# model.J_STP = nn.Parameter(0.98 * model.J_STP)
print(model.J_STP.item())
#+end_src

#+RESULTS:
: 2.5643415451049805
: 2.5643415451049805

* Simulations

#+begin_src ipython
def shifted_phase(phase1, phase2, bias_strength, bias_var, direction=-1):
    """
    shift phase2_original away from phase1 by bias_strength (in radians)
    direction='repulsive' for away, 'attractive' for toward
    All phases in radians
    """
    delta = (phase1 - phase2) * torch.pi / 180.0
    # - for repulsion, + for attraction
    phase2_biased = phase2 + direction * bias_strength * torch.sin(delta + bias_var * torch.randn_like(phase2))  + bias_var * torch.randn_like(phase2)
    return torch.remainder(phase2_biased, 360.0)
#+end_src

#+RESULTS:

#+begin_src ipython
model.N_BATCH = N_BATCH
model.PHI0 = torch.randint(low=0, high=360, size=(N_BATCH, len(model.I0), 1), device=DEVICE, dtype=torch.float)

# model.PHI0_UNBIASED = model.PHI0.clone() * torch.pi / 180.0

# model.PHI0[:, 2] = shifted_phase(model.PHI0[:, 0], model.PHI0[:, 2], model.REP_BIAS, model.REP_VAR)
# model.PHI0[:, 1] = model.PHI0[:, 0]
# model.PHI0[:, 3] = model.PHI0[:, 2]
#+end_src

#+RESULTS:

#+begin_src ipython
with torch.no_grad():
    ff_input = model.init_ff_input()
    rates_tensor = model.forward(ff_input=ff_input, RET_STP=1)
rates = rates_tensor.cpu().detach().numpy()
print('rates', rates.shape)
#+end_src

#+RESULTS:
: rates (768, 121, 750)

#+begin_src ipython
m0, m1, phi = decode_bump_torch(rates, axis=-1, RET_TENSOR=0)
#+end_src

#+RESULTS:

#+begin_src ipython
rel_loc = (model.PHI0_UNBIASED[:, 2, 0] - model.PHI0[:, 0, 0]) * 180.0 / torch.pi
rel_loc = (rel_loc + 180) % (360) - 180

error = (model.PHI0_UNBIASED[:, 2, 0] - model.PHI0[:, 2, 0]) * 180 / torch.pi
error = (error + 180) % (360) - 180

plt.plot(rel_loc.cpu(), error.cpu(), 'o')
plt.xlabel('Rel. Loc.')
plt.ylabel('Input Bias (°)')
plt.show()
#+end_src

#+RESULTS:
[[./figures/odr_sb/figure_16.png]]

* Dynamics

#+begin_src ipython
fig, ax = plt.subplots(1, 3, figsize=[2.5*width, height])

idx = np.random.randint(0, model.N_BATCH)
ax[0].imshow(rates[idx].T, aspect='auto', cmap='jet', vmin=0, vmax=2, origin='lower', extent=[0, model.DURATION, 0, model.Na[0].cpu()])
ax[0].set_ylabel('Pref. Location (°)')
ax[0].set_yticks(np.linspace(0, model.Na[0].cpu(), 5), np.linspace(0, 360, 5).astype(int))
ax[0].set_xlabel('Time (s)')

xtime = np.linspace(0, model.DURATION, phi.shape[-1])
idx = np.random.randint(0, model.N_BATCH, 8)
ax[1].plot(xtime, m1[idx].T)
ax[1].set_ylabel('$\mathcal{F}_1$ (Hz)')
ax[1].set_xlabel('Time (s)')
add_vlines(model, ax[1])

ax[2].plot(xtime, phi[idx].T * 180 / np.pi, alpha=0.5)
ax[2].set_yticks(np.linspace(0, 360, 5).astype(int), np.linspace(0, 360, 5).astype(int))
ax[2].set_ylabel('Bump Center (°)')
ax[2].set_xlabel('Time (s)')
add_vlines(model, ax[2])
plt.show()
#+end_src

#+RESULTS:
[[./figures/odr_sb/figure_17.png]]


#+begin_src ipython
fig, ax = plt.subplots(1, 2, figsize=[2*width, height])

idx = np.random.randint(0, model.N_BATCH)

ax[1].imshow(model.x_list.cpu()[idx].T, aspect='auto', cmap='jet', vmin=0.5, vmax=1, origin='lower', extent=[0, model.DURATION, 0, model.Na[0].cpu()])

ax[0].imshow(model.u_list.cpu()[idx].T, aspect='auto', cmap='jet', vmin=0, vmax=0.5, origin='lower', extent=[0, model.DURATION, 0, model.Na[0].cpu()])

plt.show()
#+end_src

#+RESULTS:
[[./figures/odr_sb/figure_18.png]]


#+begin_src ipython
fig, ax = plt.subplots(1, 2, figsize=[2*width, height])

idx = np.random.randint(0, model.N_BATCH, 5)

for i in idx:
    ax[1].plot(xtime, model.x_list.cpu()[i, :, 0])
    ax[0].plot(xtime, model.u_list.cpu()[i, :, 0])

ax[0].set_xlabel('Time (s)')
ax[1].set_xlabel('Time (s)')

add_vlines(model, ax[1])
add_vlines(model, ax[0])

ax[1].set_ylabel('x')
ax[0].set_ylabel('u')
plt.show()
#+end_src

#+RESULTS:
[[./figures/odr_sb/figure_19.png]]

#+begin_src ipython
fig, ax = plt.subplots(1, 2, figsize=[2*width, height])

m0_x, m1_x, phi_x = decode_bump_torch(model.x_list, axis=-1, RET_TENSOR=0)

idx = np.random.randint(0, model.N_BATCH, 5)

for i in idx:
    ax[0].plot(xtime, m1_x[i])
    ax[1].plot(xtime, phi_x[i])

ax[0].set_xlabel('Time (s)')
ax[1].set_xlabel('Time (s)')

add_vlines(model, ax[0])
add_vlines(model, ax[1])

ax[0].set_ylabel('$\mathcal{F}_1(x)$')
ax[1].set_ylabel('$\\theta_x$')

plt.show()
#+end_src

#+RESULTS:
[[./figures/odr_sb/figure_20.png]]


#+begin_src ipython
fig, ax = plt.subplots(1, 2, figsize=[2*width, height])

m0_u, m1_u, phi_u = decode_bump_torch(model.u_list, axis=-1, RET_TENSOR=0)

idx = np.random.randint(0, model.N_BATCH, 5)

for i in idx:
    ax[0].plot(xtime, m1_u[i])
    ax[1].plot(xtime, phi_u[i])

ax[0].set_xlabel('Time (s)')
ax[1].set_xlabel('Time (s)')

add_vlines(model, ax[0])
add_vlines(model, ax[1])

ax[0].set_ylabel('$\mathcal{F}_1(u)$')
ax[1].set_ylabel('$\\theta_u$')

plt.show()
#+end_src

#+RESULTS:
[[./figures/odr_sb/figure_21.png]]

#+begin_src ipython

#+end_src

#+RESULTS:

* Errors

#+begin_src ipython
print(model.PHI0[:5, 0, 0])
#+end_src

#+RESULTS:
: tensor([5.6025, 5.5851, 5.8294, 6.0737, 2.8623], device='cuda:0')

#+begin_src ipython
PHI0 = model.PHI0_UNBIASED.cpu().detach().numpy()
# PHI0 = model.PHI0.cpu().detach().numpy()

target_loc = PHI0[:, 2] * 180 / np.pi

rel_loc = (PHI0[:, 0] - PHI0[:, 2])
rel_loc = (rel_loc + np.pi) % (2 * np.pi) - np.pi
rel_loc *= 180 / np.pi

error_curr = (phi - PHI0[:, 2])
error_curr = (error_curr + np.pi) % (2 * np.pi) - np.pi
error_curr *= 180 / np.pi

error_prev = (phi - PHI0[:, 0])
error_prev = (error_prev + np.pi) % (2 * np.pi) - np.pi
error_prev *= 180 / np.pi

errors = np.stack((error_prev, error_curr))
print(errors.shape, target_loc.shape, rel_loc.shape)
#+end_src

#+RESULTS:
: (2, 768, 121) (768, 1) (768, 1)

#+begin_src ipython
time_points = np.linspace(0, model.DURATION, errors.shape[-1])
idx = np.random.randint(errors.shape[1], size=100)

fig, ax = plt.subplots(1, 2, figsize=[2*width, height])
ax[0].plot(time_points, errors[0][idx].T, alpha=.4)
add_vlines(model, ax[0])

ax[0].set_xlabel('t')
ax[0].set_ylabel('prev. error (°)')

ax[1].plot(time_points, errors[1][idx].T, alpha=.4)
add_vlines(model, ax[1])

ax[1].set_xlabel('t')
ax[1].set_ylabel('curr. error (°)')
plt.show()
#+end_src

#+RESULTS:
[[./figures/odr_sb/figure_25.png]]


#+begin_src ipython
print(phi.shape, PHI0.shape, model.start_indices.shape, errors.shape)
stim_start = (model.DT * (model.start_indices - model.N_STEADY)).cpu().numpy()
stim_end = (model.DT * (model.end_indices - model.N_STEADY)).cpu().numpy()

stim_start_idx = ((model.start_indices - model.N_STEADY) / model.N_WINDOW - 1).to(int).cpu().numpy()
stim_end_idx = ((model.end_indices - model.N_STEADY) / model.N_WINDOW - 1).to(int).cpu().numpy()

print(stim_start_idx.shape)
#+end_src

#+RESULTS:
: (768, 121) (768, 4, 1) torch.Size([4, 768]) (2, 768, 121)
: (4, 768)

#+begin_src ipython
idx_half = np.array([stim_end_idx[0] + (stim_start_idx[1] - stim_end_idx[0]) / 2.0,stim_end_idx[-2] + (stim_start_idx[-1] - stim_end_idx[-2]) / 2.0], dtype=int)
t_half = np.array([stim_end[0] + (stim_start[1] - stim_end[0]) / 2.0, stim_end[1] + (stim_start[2] - stim_end[1]) / 2.0], dtype=int)
print(t_half+2)
#+end_src

#+RESULTS:
: [[5 5 5 ... 5 5 5]
:  [7 7 7 ... 7 7 7]]

#+begin_src ipython
end_point = []
for i, j in enumerate([1, 3]):
    end_ = []
    for k in range(errors.shape[1]):
        idx = stim_start_idx[j][k]
        end_.append(errors[i][k][idx])

    end_point.append(end_)

end_point = np.array(end_point)
print(end_point.shape)
#+end_src

#+RESULTS:
: (2, 768)

#+begin_src ipython
end_point_half = []
for i, j in enumerate([1, 3]):
    end_ = []
    for k in range(errors.shape[1]):
        idx = idx_half[i][k]
        end_.append(errors[i][k][idx])

    end_point_half.append(end_)

end_point_half = np.array(end_point_half)
print(end_point_half.shape)
#+end_src

#+RESULTS:
: (2, 768)

#+begin_src ipython
end_point_zero = []
for i, j in enumerate([0, 2]):
    end_ = []
    for k in range(errors.shape[1]):
        idx = stim_end_idx[j][k]
        end_.append(errors[i][k][idx])

    end_point_zero.append(end_)

end_point_zero = np.array(end_point_zero)
print(end_point_zero.shape)
#+end_src

#+RESULTS:
: (2, 768)

#+begin_src ipython
delay_duration = np.array([stim_start[1, 0] - stim_end[0, 0], stim_start[3, 0] - stim_end[2, 0]])

fig, ax = plt.subplots(1, 2, figsize=[2*width, height])

ax[0].hist(end_point[0], bins='auto', color='r', histtype='step', label='%.1f s' % delay_duration[0])
ax[0].hist(end_point_half[0], bins='auto', color='g', histtype='step', label='%.1f s' % (delay_duration[0] / 2))
ax[0].hist(end_point_zero[0], bins='auto', color='b', histtype='step', label='0s')

ax[0].set_xlabel('Prev. Errors (°)')
ax[0].legend(fontsize=12)

ax[1].hist(end_point[1], bins='auto', color='r', histtype='step', label='%.1f s' % delay_duration[1])
ax[1].hist(end_point_half[1], bins='auto', color='g', histtype='step', label='%.1f s' % (delay_duration[1] / 2))
ax[1].hist(end_point_zero[1], bins='auto', color='b', histtype='step', label='0s')

ax[1].set_xlabel('Curr. Errors (°)')
ax[1].legend(fontsize=12)

plt.show()
#+end_src

#+RESULTS:
[[./figures/odr_sb/figure_31.png]]

#+begin_src ipython

#+end_src

#+RESULTS:

* Serial Bias
** Serial Curves

#+begin_src ipython
def get_correct_error(nbins, df, thresh=25):
    if thresh is not None:
        data = df[(df['errors'] >= -thresh) & (df['errors'] <= thresh)].copy()
    else:
        data = df.copy()

    # 1. Bias-correct both error and error_half
    bin_edges = np.linspace(0, 360, n_bins + 1)
    data['bin_target'] = pd.cut(data['target_loc'], bins=bin_edges, include_lowest=True)
    mean_errors_per_bin = data.groupby('bin_target')['errors'].mean()
    data['adjusted_errors'] = data['errors'] - data['bin_target'].map(mean_errors_per_bin).astype(float)

    # 2. Bin by relative location for both sessions (full version, [-180, 180])
    data['bin_rel'] = pd.cut(data['rel_loc'], bins=n_bins)
    bin_rel = data.groupby('bin_rel')['adjusted_errors'].agg(['mean', 'sem']).reset_index()
    edges = bin_rel['bin_rel'].cat.categories
    centers = (edges.left + edges.right) / 2

    # 3. FLIP SIGN for abs(rel_loc): defects on the left (-) are flipped so all bins reflect the same "direction"
    data['rel_loc_abs'] = np.abs(data['rel_loc'])
    data['bin_rel_abs'] = pd.cut(data['rel_loc_abs'], bins=n_bins, include_lowest=True)

    # Flip errors for abs plot:
    data['adjusted_errors_abs'] = data['adjusted_errors'] * np.sign(data['rel_loc'])

    bin_rel_abs = data.groupby('bin_rel_abs')['adjusted_errors_abs'].agg(['mean', 'sem']).reset_index()
    edges_abs = bin_rel_abs['bin_rel_abs'].cat.categories
    centers_abs = (edges_abs.left + edges_abs.right) / 2

    # 4. Bin by target location for target-centered analysis (optional)
    bin_target = data.groupby('bin_target')['adjusted_errors'].agg(['mean', 'sem']).reset_index()
    edges_target = bin_target['bin_target'].cat.categories
    target_centers = (edges_target.left + edges_target.right) / 2

    return centers, bin_rel, centers_abs, bin_rel_abs
#+end_src

#+RESULTS:

#+begin_src ipython
n_bins = 8
data = pd.DataFrame({'target_loc': target_loc[:, -1], 'rel_loc': rel_loc[:, -1], 'errors': end_point[1]})
#+end_src

#+RESULTS:

#+begin_src ipython
fig, ax = plt.subplots(1, 3, figsize=[3*width, height])

ax[0].plot(data['target_loc'], data['errors'], 'o', alpha=.1)
ax[0].set_xlabel('Target Loc. (°)')
ax[0].set_ylabel('Error (°)')

stt = binned_statistic(data['target_loc'], data['errors'], statistic='mean', bins=n_bins, range=[0, 360])
dstt = np.mean(np.diff(stt.bin_edges))
ax[0].plot(stt.bin_edges[:-1]+dstt/2,stt.statistic,'r')

ax[0].axhline(color='k', linestyle=":")

ax[1].plot(data['rel_loc'], data['errors'], 'o', alpha=.1)
ax[1].set_xlabel('Rel. Loc. (°)')
ax[1].set_ylabel('Error (°)')

stt = binned_statistic(data['rel_loc'], data['errors'], statistic='mean', bins=n_bins, range=[-180, 180])
dstt = np.mean(np.diff(stt.bin_edges))
ax[1].plot(stt.bin_edges[:-1]+dstt/2, stt.statistic, 'b')

data['rel_loc_abs'] = np.abs(data['rel_loc'])             # Map -180..180 -> 0..180
data['errors_signed'] = data['errors'] * np.sign(data['rel_loc']) # error "toward/away": flip sign for >0

ax[2].plot(data['rel_loc_abs'], data['errors_signed'], 'o', alpha=0.1)
ax[2].set_xlabel('|Rel. Loc.| (°)')
ax[2].set_ylabel('Error (°)')

bin_stat = binned_statistic(data['rel_loc_abs'], data['errors_signed'], statistic='mean', bins=n_bins, range=[0, 180])
dstt = np.mean(np.diff(bin_stat.bin_edges))
ax[2].plot(bin_stat.bin_edges[:-1] + dstt/2, bin_stat.statistic, 'b')
ax[2].axhline(color='k', linestyle=":")

# plt.savefig('../figures/figs/christos/uncorr_biases.svg', dpi=300)
plt.show()
#+end_src

#+RESULTS:
[[./figures/odr_sb/figure_35.png]]


#+begin_src ipython
data = pd.DataFrame({'target_loc': target_loc[:, -1], 'rel_loc': rel_loc[:, -1], 'errors': end_point[1]})
centers, bin_rel, centers_abs, bin_rel_abs = get_correct_error(n_bins, data)
#+end_src

#+RESULTS:

#+begin_src ipython
data = pd.DataFrame({'target_loc': target_loc[:, -1], 'rel_loc': rel_loc[:, -1], 'errors': end_point_half[1]})
centers_half, bin_rel_half, centers_abs_half, bin_rel_abs_half = get_correct_error(n_bins, data)
#+end_src

#+RESULTS:

#+begin_src ipython
data = pd.DataFrame({'target_loc': target_loc[:, -1], 'rel_loc': rel_loc[:, -1], 'errors': end_point_zero[1]})
centers_zero, bin_rel_zero, centers_abs_zero, bin_rel_abs_zero = get_correct_error(n_bins, data)
#+end_src

#+RESULTS:

#+begin_src ipython
delay_duration = stim_start[-1] - stim_end[-2]

fig, ax = plt.subplots(1, 2, figsize=[2*width, height])

ax[0].plot(centers, bin_rel['mean'], 'r', label='full')
ax[0].fill_between(centers, bin_rel['mean'] - bin_rel['sem'], bin_rel['mean'] + bin_rel['sem'], color='r', alpha=0.2)

ax[0].plot(centers, bin_rel_half['mean'], 'g', label='half')
ax[0].fill_between(centers, bin_rel_half['mean'] - bin_rel_half['sem'], bin_rel_half['mean'] + bin_rel_half['sem'], color='g', alpha=0.2)

ax[0].plot(centers, bin_rel_zero['mean'], 'b', label='zero')
ax[0].fill_between(centers, bin_rel_zero['mean'] - bin_rel_zero['sem'], bin_rel_zero['mean'] + bin_rel_zero['sem'], color='b', alpha=0.2)

ax[0].axhline(0, color='k', linestyle=":")
ax[0].set_xlabel('Rel. Loc. (°)')
ax[0].set_ylabel('Error (°)')

ax[0].set_xticks(np.linspace(-180, 180, 5))

ax[1].plot(centers_abs, bin_rel_abs['mean'], 'r', label='%.1f s' % delay_duration[1])
ax[1].fill_between(centers_abs, bin_rel_abs['mean'] - bin_rel_abs['sem'], bin_rel_abs['mean'] + bin_rel_abs['sem'], color='r', alpha=0.2)

ax[1].plot(centers_abs, bin_rel_abs_half['mean'], 'g', label='%.1f s' % (delay_duration[1] / 2.0))
ax[1].fill_between(centers_abs, bin_rel_abs_half['mean'] - bin_rel_abs_half['sem'], bin_rel_abs_half['mean'] + bin_rel_abs_half['sem'], color='g', alpha=0.2)

ax[1].plot(centers_abs, bin_rel_abs_zero['mean'], 'b', label='0s' )
ax[1].fill_between(centers_abs, bin_rel_abs_zero['mean'] - bin_rel_abs_zero['sem'], bin_rel_abs_zero['mean'] + bin_rel_abs_zero['sem'], color='b', alpha=0.2)

ax[1].axhline(0, color='k', linestyle=":")
ax[1].set_xlabel('Rel. Loc. (°)')
ax[1].set_ylabel('Flip. Error (°)')

ax[1].legend(fontsize=12, title='Delay', title_fontsize=12)
ax[1].set_xticks(np.linspace(0, 180, 3))

plt.tight_layout()
plt.show()
#+end_src

#+RESULTS:
[[./figures/odr_sb/figure_39.png]]

#+begin_src ipython

#+end_src

#+RESULTS:

** Delay Dependency

#+begin_src ipython
delay_point = []
for i in range(errors.shape[1]):
        idx_start = stim_end_idx[2][i]+1
        idx_end = stim_start_idx[3][i]

        end_ = []
        for idx in range(idx_start, idx_end):
                end_.append(errors[1][i][idx])

        delay_point.append(end_)

delay_point = np.array(delay_point)
print(delay_point.shape, errors.shape)
#+end_src

#+RESULTS:
: (768, 29) (2, 768, 121)

#+begin_src ipython
import numpy as np
from scipy.optimize import curve_fit

def fit_deriv_gaussian_circular(df, n_bins, target_col='target_loc', error_col='errors', rel_col='rel_loc', n_tries=10, thresh=25):
    if thresh is not None:
        data = df[(df['errors'] >= -thresh) & (df['errors'] <= thresh)].copy()
    else:
        data = df.copy()

    # 1. Compute "adjusted_errors"
    bin_edges = np.linspace(0, 360, n_bins + 1)
    data = data.copy()
    data['bin_target'] = pd.cut(
        data[target_col], bins=bin_edges, include_lowest=True, right=False)
    mean_errors_per_bin = data.groupby('bin_target', observed=False)[error_col].mean()

    data['adjusted_errors'] = (
        data[error_col] - data['bin_target'].map(mean_errors_per_bin).astype(float)
    )

    # 2. Circular binning for kernel fitting
    x = data[rel_col].values
    y = data['adjusted_errors'].values
    bins = np.linspace(-180, 180, n_bins + 1)
    bin_indices = np.digitize(x, bins, right=False) - 1
    bin_indices[bin_indices == n_bins] = 0

    bin_centers = (bins[:-1] + bins[1:]) / 2
    bin_means = np.array([
        y[bin_indices == i].mean() if np.any(bin_indices == i) else np.nan
        for i in range(n_bins)
    ])

    # Guess parameters from the data
    ampl_guess = (np.nanmax(bin_means) - np.nanmin(bin_means)) / 2
    sigma_guess = (np.nanmax(bin_centers) - np.nanmin(bin_centers)) / 4

    # Model
    def deriv_gaussian(x, A, sigma, mu=0):
        return -A * (x - mu) * np.exp(-((x - mu) ** 2) / (2 * sigma ** 2)) / (sigma ** 2)

    mask = np.isfinite(bin_means)
    fit_centers = bin_centers[mask]
    fit_means = bin_means[mask]

    best_loss = np.inf
    best_popt = None

    for _ in range(n_tries):
        # Vary around data-driven guess
        p0 = [
            ampl_guess * np.random.uniform(0.0, 10.0),
            sigma_guess * np.random.uniform(1.0, 10.0),
        ]
        try:
            popt, _ = curve_fit(
                deriv_gaussian, fit_centers, fit_means, p0=p0, maxfev=5000)
            residuals = fit_means - deriv_gaussian(fit_centers, *popt)
            loss = np.sum(residuals**2)
            if loss < best_loss:
                best_loss = loss
                best_popt = popt
        except RuntimeError:
            continue

    if best_popt is None:
        raise RuntimeError("Fit did not converge in any of the tries.")

    result = {
        'amplitude_at_90': -best_popt[0] * (90 - 0) * np.exp(-((90 - 0) ** 2) / (2 * best_popt[1] ** 2)) / (best_popt[1] ** 2),
        'bin_centers': bin_centers,
        'bin_means': bin_means,
        'fit': lambda x: deriv_gaussian(x, *best_popt),
        'data': data
    }

    return result

#+end_src

#+RESULTS:

#+begin_src ipython
from joblib import Parallel, delayed
import numpy as np

def bootstrap_amplitude_at_90(
    data, n_bins, n_boot=100, n_jobs=-1, random_state=None, fit_kwargs=None
):
    # fit_kwargs: dict for extra arguments to fit_deriv_gaussian_circular
    if fit_kwargs is None:
        fit_kwargs = {}
    rng = np.random.RandomState(random_state)

    def _single_boot(random_seed):
        import warnings
        from scipy.optimize import OptimizeWarning
        warnings.simplefilter("ignore", OptimizeWarning)
        np.random.seed(random_seed)
        d_samp = data.sample(frac=1, replace=True, random_state=np.random.randint(0, 2**32))
        try:
            res = fit_deriv_gaussian_circular(d_samp, n_bins, **fit_kwargs)
            return res['amplitude_at_90']
        except Exception:
            return np.nan

    seeds = rng.randint(0, 2**32, size=n_boot)
    results = Parallel(n_jobs=n_jobs)(
        delayed(_single_boot)(s) for s in seeds
    )
    results = np.array([r for r in results if np.isfinite(r)])
    ci = np.percentile(results, [2.5, 97.5])
    return ci
#+end_src

#+RESULTS:

#+begin_src ipython
import warnings
from scipy.ndimage import gaussian_filter1d
from scipy.optimize import OptimizeWarning

n_bins = 16

cmap = plt.get_cmap('Blues')
colors = [cmap((i+1)/ delay_point.shape[1]) for i in range(delay_point.shape[1])]

serial_list = []
serial_ci = []
for i in range(delay_point.shape[1]):
    data = pd.DataFrame({'target_loc': target_loc[:, -1], 'rel_loc': rel_loc[:, -1], 'errors': delay_point[:, i]})

    result = fit_deriv_gaussian_circular(data, n_bins=n_bins)
    ci = bootstrap_amplitude_at_90(data.copy(), n_bins=n_bins, n_boot=100)

    plt.plot(result['bin_centers'], result['fit'](result['bin_centers']), alpha=1, color=colors[i])

    serial_list.append(result['amplitude_at_90'])
    serial_ci.append(ci)

serial_list = np.array(serial_list)
serial_ci = np.array(serial_ci)

plt.xlabel('Rel. Loc. (°)')
plt.ylabel('Error (°)')
plt.show()
#+end_src

#+RESULTS:

#+begin_src ipython
print(serial_list.shape, serial_ci.shape)
#+end_src

#+RESULTS:
: (29,) (29, 2)

#+begin_src ipython
delay_duration = stim_start[3, 0] - stim_end[2, 0]
xdelay = np.linspace(0, delay_duration, serial_list.shape[0])

plt.plot(xdelay, serial_list, '-')
plt.fill_between(xdelay, serial_ci[:,0], serial_ci[:,1], color='gray', alpha=0.3, label='95% CI')

plt.xlabel('Delay Length (s)')
plt.ylabel('Serial Bias (°)')

plt.show()
#+end_src

#+RESULTS:
[[./figures/odr_sb/figure_46.png]]

#+begin_src ipython

#+end_src

#+RESULTS:

#+begin_src ipython
from scipy.ndimage import gaussian_filter1d
n_bins = 8

serial_bias = []
for i in range(delay_point.shape[1]):
    data = pd.DataFrame({'target_loc': target_loc[:, -1], 'rel_loc': rel_loc[:, -1], 'errors': delay_point[:, i]})

    centers, bin_rel, centers_abs, bin_rel_abs = get_correct_error(n_bins, data, thresh=25)

    plt.plot(centers_abs, gaussian_filter1d(bin_rel['mean'], sigma=1), color=colors[i])

    idx_max = np.argmax(abs(gaussian_filter1d(bin_rel_abs['mean'], sigma=1)))
    serial_max = bin_rel_abs['mean'][idx_max]
    serial_std = bin_rel_abs['sem'][idx_max]

    serial_bias.append([serial_max, serial_std])

serial_bias = np.array(serial_bias).T
# print(serial_list.shape)
#+end_src

#+RESULTS:
[[./figures/odr_sb/figure_48.png]]

#+begin_src ipython
print(serial_bias[0])
#+end_src

#+RESULTS:
: [ 6.18442998  6.20300193  6.3715836   6.65126451  6.94800888  7.32795275
:   7.80061426  8.21611374  8.58866941  8.95796997  8.87249101  8.74742165
:   9.08752679  9.50149513  9.50477639  9.36133275  9.35032102 10.38673874
:  10.16915297  9.70943668  9.39849043  9.76956878  9.87906549  8.69065653
:   7.9596168   7.10092074  7.24608198  7.73090408  5.57673811]

#+begin_src ipython
delay_duration = stim_start[3, 0] - stim_end[2, 0]
xdelay = np.linspace(0, delay_duration, serial_bias.shape[1])

plt.plot(xdelay, serial_bias[0], '-')
plt.fill_between(xdelay, serial_bias[0] - serial_bias[1], serial_bias[0] + serial_bias[1], color='b', alpha=0.2)
plt.xlabel('Delay Length (s)')
plt.ylabel('Serial Bias (°)')
plt.show()

#+end_src

#+RESULTS:
[[./figures/odr_sb/figure_50.png]]

#+begin_src ipython

#+end_src

#+RESULTS:
