#+STARTUP: fold
#+TITLE: ODR serial bias
#+PROPERTY: header-args:ipython :results both :exports both :async yes :session odr_sb :kernel torch :exports results :output-dir ./figures/odr_sb :file (lc/org-babel-tangle-figure-filename)

* Notebook Settings

#+begin_src ipython
  %load_ext autoreload
  %autoreload 2
  %reload_ext autoreload

  %run ../../../notebooks/setup.py
  %matplotlib inline
  %config InlineBackend.figure_format = 'png'

  REPO_ROOT = "/home/leon/models/NeuroFlame"
  pal = sns.color_palette("tab10")
#+end_src

#+RESULTS:
: The autoreload extension is already loaded. To reload it, use:
:   %reload_ext autoreload
: Python exe
: /home/leon/mambaforge/envs/torch/bin/python

* Imports

#+begin_src ipython
  import torch
  import torch.nn as nn
  import torch.optim as optim
  import torch.nn.functional as F
  from torch.utils.data import Dataset, TensorDataset, DataLoader
  from scipy.stats import binned_statistic
#+end_src

#+RESULTS:

#+begin_src ipython
  import sys
  sys.path.insert(0, '../../../')

  import pandas as pd
  import torch.nn as nn
  from time import perf_counter
  from scipy.stats import circmean

  from src.network import Network
  from src.plot_utils import plot_con
  from src.decode import decode_bump, circcvl, decode_bump_torch
  from src.lr_utils import masked_normalize, clamp_tensor, normalize_tensor
#+end_src

#+RESULTS:

#+begin_src ipython :tangle ../src/torch/utils.py
  import pickle as pkl
  import os

  def pkl_save(obj, name, path="."):
      os.makedirs(path, exist_ok=True)
      destination = path + "/" + name + ".pkl"
      print("saving to", destination)
      pkl.dump(obj, open(destination, "wb"))


  def pkl_load(name, path="."):
      source = path + "/" + name + '.pkl'
      print('loading from', source)
      return pkl.load(open( source, "rb"))

#+end_src

#+RESULTS:

* Helpers

#+begin_src ipython
def map2center(angles):
    """Map angles from [0, 2π] to [-π, π] using PyTorch tensors."""
    return np.where(angles > np.pi, angles - 2 * np.pi, angles)

def map2pos(angles):
    """Map angles from [-π, π] to [0, 2π] using PyTorch tensors."""
    return np.where(angles < 0, angles + 2 * np.pi, angles)
#+end_src

#+RESULTS:

#+begin_src ipython
def maptens2center(angles):
    """Map angles from [0, 2π] to [-π, π] using PyTorch tensors."""
    return torch.where(angles > torch.pi, angles - 2 * torch.pi, angles)

def maptens2pos(angles):
    """Map angles from [-π, π] to [0, 2π] using PyTorch tensors."""
    return torch.where(angles < 0, angles + 2 * torch.pi, angles)
#+end_src

#+RESULTS:

#+begin_src ipython
def add_vlines(model, ax=None):

    if ax is None:
        for i in range(len(model.T_STIM_ON)):
            plt.axvspan(model.T_STIM_ON[i], model.T_STIM_OFF[i], alpha=0.25)
    else:
        for i in range(len(model.T_STIM_ON)):
            ax.axvspan(model.T_STIM_ON[i], model.T_STIM_OFF[i], alpha=0.25)

#+end_src

#+RESULTS:

* Model

#+begin_src ipython
kwargs = {
    'GAIN': 1.0,
    'DURATION': 10.0,
    'T_STEADY': 2,
    'T_STIM_ON': [1.0, 3.0, 5.0, 9.0],
    'T_STIM_OFF': [2.0, 4.0, 6.0, 10.0],
    'I0': [1.0, -2.0, 1.0, -2.0],
    'PHI0': [180.0, 180, 180, 180],
    'SIGMA0': [1.0, 0.0, 1.0, 0.0],
    'RANDOM_DELAY': 0,
    'MIN_DELAY': 2,
    'MAX_DELAY': 5,
    'IF_ADAPT': 0,
    'A_ADAPT': .3,
    'TAU_ADAPT': [150.0, 150.0],
}
#+end_src

#+RESULTS:

#+begin_src ipython
REPO_ROOT = "/home/leon/models/NeuroFlame"
conf_name = "train_odr_EI.yml"
DEVICE = 'cuda:1'
seed = np.random.randint(0, 1e6)

seed = 1
print('seed', seed)
#+end_src

#+RESULTS:
: seed 1

#+begin_src ipython
N_BATCH = 128*6
model = Network(conf_name, REPO_ROOT, VERBOSE=0, DEVICE=DEVICE, SEED=seed, N_BATCH=N_BATCH, **kwargs)
#+end_src

#+RESULTS:

#+begin_src ipython
model_state_dict = torch.load('../models/odr/odr_%d.pth' % seed)
model.load_state_dict(model_state_dict);
model.eval();
#+end_src

#+RESULTS:

#+begin_src ipython
print(model.J_STP)
#+end_src

#+RESULTS:
: Parameter containing:
: tensor(3.1004, device='cuda:1', requires_grad=True)

* Batching Inputs

#+begin_src ipython
model.N_BATCH = N_BATCH
model.PHI0 = torch.randint(low=0, high=360, size=(N_BATCH, len(model.I0), 1), device=DEVICE, dtype=torch.float)
#+end_src

#+RESULTS:

#+begin_src ipython
with torch.no_grad():
    ff_input = model.init_ff_input()
    rates_tensor = model.forward(ff_input=ff_input)
rates = rates_tensor.cpu().detach().numpy()
print('rates', rates.shape)
#+end_src

#+RESULTS:
: rates (768, 101, 750)

#+begin_src ipython
m0, m1, phi = decode_bump_torch(rates, axis=-1, RET_TENSOR=0)
#+end_src

#+RESULTS:

* Results
** Rates

#+begin_src ipython
fig, ax = plt.subplots(1, 3, figsize=[2.5*width, height])

idx = np.random.randint(0, model.N_BATCH)
ax[0].imshow(rates[idx].T, aspect='auto', cmap='jet', vmin=0, vmax=2, origin='lower', extent=[0, model.DURATION, 0, model.Na[0].cpu()])
ax[0].set_ylabel('Pref. Location (°)')
ax[0].set_yticks(np.linspace(0, model.Na[0].cpu(), 5), np.linspace(0, 360, 5).astype(int))
ax[0].set_xlabel('Time (s)')

xtime = np.linspace(0, model.DURATION, phi.shape[-1])
idx = np.random.randint(0, model.N_BATCH, 8)
ax[1].plot(xtime, m1[idx].T)
ax[1].set_ylabel('m1 (Hz)')
ax[1].set_xlabel('Time (s)')
add_vlines(model, ax[1])

ax[2].plot(xtime, phi[idx].T * 180 / np.pi, alpha=0.5)
ax[2].set_yticks(np.linspace(0, 360, 5).astype(int), np.linspace(0, 360, 5).astype(int))
ax[2].set_ylabel('Bump Center (°)')
ax[2].set_xlabel('Time (s)')
add_vlines(model, ax[2])
plt.show()
#+end_src

#+RESULTS:
[[./figures/odr_sb/figure_15.png]]

** errors

#+begin_src ipython
PHI0 = model.PHI0.cpu().detach().numpy() * 180.0 / np.pi
target_loc = PHI0[:, 2]

rel_loc = (PHI0[:, 0] - PHI0[:, 2]) * np.pi / 180.0
rel_loc = (rel_loc + np.pi) % (2 * np.pi) - np.pi
rel_loc *= 180 / np.pi

error_curr = (phi - PHI0[:, 2] * np.pi / 180.0)
error_curr = (error_curr + np.pi) % (2 * np.pi) - np.pi
error_curr *= 180 / np.pi

error_prev = ((phi - PHI0[:, 0] * np.pi / 180.0))
error_prev = (error_prev + np.pi) % (2 * np.pi) - np.pi
error_prev *= 180 / np.pi

errors = np.stack((error_prev, error_curr))
print(errors.shape, target_loc.shape, rel_loc.shape)
#+end_src

#+RESULTS:
: (2, 768, 101) (768, 1) (768, 1)

#+begin_src ipython
time_points = np.linspace(0, model.DURATION, errors.shape[-1])
idx = np.random.randint(errors.shape[1], size=100)

fig, ax = plt.subplots(1, 2, figsize=[2*width, height])
ax[0].plot(time_points, errors[0][idx].T, alpha=.4)
add_vlines(model, ax[0])

ax[0].set_xlabel('t')
ax[0].set_ylabel('prev. error (°)')

ax[1].plot(time_points, errors[1][idx].T, alpha=.4)
add_vlines(model, ax[1])

ax[1].set_xlabel('t')
ax[1].set_ylabel('curr. error (°)')
plt.show()
#+end_src

#+RESULTS:
[[./figures/odr_sb/figure_17.png]]

#+begin_src ipython
print(phi.shape, PHI0.shape, model.start_indices.shape, errors.shape)
stim_start = (model.DT * (model.start_indices - model.N_STEADY)).cpu().numpy()
stim_start_idx = ((model.start_indices - model.N_STEADY) / model.N_WINDOW - 1).to(int).cpu().numpy()

stim_start_idx_half = ((model.start_indices - 2 *model.N_STEADY) / model.N_WINDOW ).to(int).cpu().numpy()
print(stim_start[1][:5], model.T_STIM_ON)
print(stim_start_idx[1][:5])
#+end_src

#+RESULTS:
: (768, 101) (768, 4, 1) torch.Size([4, 768]) (2, 768, 101)
: [3. 3. 3. 3. 3.] [1.0, 3.0, 5.0, 9.0]
: [29 29 29 29 29]

#+begin_src ipython
time_points = np.linspace(0, model.DURATION, errors.shape[-1])
idx = np.random.randint(errors.shape[1], size=(1,))

fig, ax = plt.subplots(1, 2, figsize=[2*width, height])
ax[0].plot(errors[0][idx].T, '-')
ax[0].set_xlabel('t')
ax[0].set_ylabel('prev. error (°)')

ax[0].axvline(stim_start_idx[0][idx], ls='--', c='k')
ax[0].axvline(stim_start_idx[1][idx], ls='--', c='k')
ax[0].axvline(stim_start_idx[2][idx], ls='--', c='k')
ax[0].axvline(stim_start_idx[3][idx], ls='--', c='k')

ax[1].plot(errors[1][idx].T)

ax[1].axhline((-PHI0[idx, 0, 0])%360, ls='--', c='k')

ax[1].axvline(stim_start_idx[0][idx], ls='--', c='k')
ax[1].axvline(stim_start_idx[1][idx], ls='--', c='k')
ax[1].axvline(stim_start_idx[2][idx], ls='--', c='k')
ax[1].axvline(stim_start_idx[3][idx], ls='--', c='k')

ax[1].axvline(stim_start_idx_half[0][idx], ls='--', c='r')
ax[1].axvline(stim_start_idx_half[1][idx], ls='--', c='r')
ax[1].axvline(stim_start_idx_half[2][idx], ls='--', c='r')
ax[1].axvline(stim_start_idx_half[3][idx], ls='--', c='r')

ax[1].set_xlabel('t')
ax[1].set_ylabel('curr. error (°)')
plt.show()
#+end_src

#+RESULTS:
[[./figures/odr_sb/figure_19.png]]

#+begin_src ipython
time_points = np.linspace(0, model.DURATION, errors.shape[-1])
idx = np.random.randint(errors.shape[1])

fig, ax = plt.subplots(1, 2, figsize=[2*width, height])
ax[0].plot(time_points, errors[0][idx].T)
ax[0].set_xlabel('t')
ax[0].set_ylabel('prev. error (°)')

ax[0].axvline(stim_start[0][idx], ls='--', c='k')
ax[0].axvline(stim_start[1][idx], ls='--', c='k')
ax[0].axvline(stim_start[2][idx], ls='--', c='k')
ax[0].axvline(stim_start[3][idx], ls='--', c='k')

ax[1].plot(time_points, errors[1][idx].T)

ax[1].axvline(stim_start[0][idx], ls='--', c='k')
ax[1].axvline(stim_start[1][idx], ls='--', c='k')
ax[1].axvline(stim_start[2][idx], ls='--', c='k')
ax[1].axvline(stim_start[3][idx], ls='--', c='k')

ax[1].set_xlabel('t')
ax[1].set_ylabel('curr. error (°)')
plt.show()
#+end_src

#+RESULTS:
[[./figures/odr_sb/figure_20.png]]

#+begin_src ipython
end_point = []
for i, j in enumerate([1, 3]):
    end_ = []
    for k in range(errors.shape[1]):
        idx = stim_start_idx[j][k]
        end_.append(errors[i][k][idx])

    end_point.append(end_)

end_point = np.array(end_point)
print(end_point.shape)
#+end_src

#+RESULTS:
: (2, 768)

#+begin_src ipython
end_point_half = []
for i, j in enumerate([1, 3]):
    end_ = []
    for k in range(errors.shape[1]):
        idx = stim_start_idx_half[j][k]
        end_.append(errors[i][k][idx])

    end_point_half.append(end_)

end_point_half = np.array(end_point_half)
print(end_point_half.shape)
#+end_src

#+RESULTS:
: (2, 768)

#+begin_src ipython
fig, ax = plt.subplots(1, 3, figsize=[3*width, height])
ax[0].hist(target_loc, bins='auto')
ax[0].set_xlabel('Targets (°)')

ax[1].hist(end_point[0], bins='auto')
ax[1].hist(end_point_half[0], bins='auto', color='r', histtype='step')
ax[1].set_xlabel('Prev. Errors (°)')

ax[2].hist(end_point[1], bins='auto')
ax[2].hist(end_point_half[1], bins='auto', color='r', histtype='step')
ax[2].set_xlabel('Curr. Errors (°)')
plt.show()
#+end_src

#+RESULTS:
[[./figures/odr_sb/figure_23.png]]

#+begin_src ipython

#+end_src

#+RESULTS:

** biases

#+begin_src ipython
def get_correct_error(nbins, df, thresh=None):
    if thresh is not None:
        data = df[(df['errors'] >= -thresh) & (df['errors'] <= thresh)].copy()
    else:
        data = df.copy()

    # 1. Bias-correct both error and error_half
    bin_edges = np.linspace(0, 360, n_bins + 1)
    data['bin_target'] = pd.cut(data['target_loc'], bins=bin_edges, include_lowest=True)
    mean_errors_per_bin = data.groupby('bin_target')['errors'].mean()
    data['adjusted_errors'] = data['errors'] - data['bin_target'].map(mean_errors_per_bin).astype(float)

    # 2. Bin by relative location for both sessions (full version, [-180, 180])
    data['bin_rel'] = pd.cut(data['rel_loc'], bins=n_bins)
    bin_rel = data.groupby('bin_rel')['adjusted_errors'].agg(['mean', 'sem']).reset_index()
    edges = bin_rel['bin_rel'].cat.categories
    centers = (edges.left + edges.right) / 2

    # 3. FLIP SIGN for abs(rel_loc): defects on the left (-) are flipped so all bins reflect the same "direction"
    data['rel_loc_abs'] = np.abs(data['rel_loc'])
    data['bin_rel_abs'] = pd.cut(data['rel_loc_abs'], bins=n_bins, include_lowest=True)

    # Flip errors for abs plot:
    data['adjusted_errors_abs'] = data['adjusted_errors'] * np.sign(data['rel_loc'])

    bin_rel_abs = data.groupby('bin_rel_abs')['adjusted_errors_abs'].agg(['mean', 'sem']).reset_index()
    edges_abs = bin_rel_abs['bin_rel_abs'].cat.categories
    centers_abs = (edges_abs.left + edges_abs.right) / 2

    # 4. Bin by target location for target-centered analysis (optional)
    bin_target = data.groupby('bin_target')['adjusted_errors'].agg(['mean', 'sem']).reset_index()
    edges_target = bin_target['bin_target'].cat.categories
    target_centers = (edges_target.left + edges_target.right) / 2

    return centers, bin_rel, centers_abs, bin_rel_abs
#+end_src

#+RESULTS:

#+begin_src ipython
n_bins = 8
data = pd.DataFrame({'target_loc': target_loc[:, -1], 'rel_loc': rel_loc[:, -1], 'errors': end_point[1], 'errors_half': end_point_half[1]})
#+end_src

#+RESULTS:

#+begin_src ipython
fig, ax = plt.subplots(1, 3, figsize=[3*width, height])

ax[0].plot(data['target_loc'], data['errors'], 'o', alpha=.1)
ax[0].set_xlabel('Target Loc. (°)')
ax[0].set_ylabel('Error (°)')

stt = binned_statistic(data['target_loc'], data['errors'], statistic='mean', bins=n_bins, range=[0, 360])
dstt = np.mean(np.diff(stt.bin_edges))
ax[0].plot(stt.bin_edges[:-1]+dstt/2,stt.statistic,'r')

ax[0].axhline(color='k', linestyle=":")

ax[1].plot(data['rel_loc'], data['errors'], 'o', alpha=.1)
ax[1].set_xlabel('Rel. Loc. (°)')
ax[1].set_ylabel('Error (°)')

stt = binned_statistic(data['rel_loc'], data['errors'], statistic='mean', bins=n_bins, range=[-180, 180])
dstt = np.mean(np.diff(stt.bin_edges))
ax[1].plot(stt.bin_edges[:-1]+dstt/2, stt.statistic, 'b')

data['rel_loc_abs'] = np.abs(data['rel_loc'])             # Map -180..180 -> 0..180
data['errors_signed'] = data['errors'] * np.sign(data['rel_loc']) # error "toward/away": flip sign for >0

ax[2].plot(data['rel_loc_abs'], data['errors_signed'], 'o', alpha=0.1)
ax[2].set_xlabel('|Rel. Loc.| (°)')
ax[2].set_ylabel('Error (°)')

bin_stat = binned_statistic(data['rel_loc_abs'], data['errors_signed'], statistic='mean', bins=n_bins, range=[0, 180])
dstt = np.mean(np.diff(bin_stat.bin_edges))
ax[2].plot(bin_stat.bin_edges[:-1] + dstt/2, bin_stat.statistic, 'b')
ax[2].axhline(color='k', linestyle=":")

# plt.savefig('../figures/figs/christos/uncorr_biases.svg', dpi=300)
plt.show()
#+end_src

#+RESULTS:
[[./figures/odr_sb/figure_27.png]]

#+begin_src ipython
import numpy as np
import pandas as pd

thresh = 25
data = data[(data['errors'] >= -thresh) & (data['errors'] <= thresh)].copy()

# 1. Bias-correct both error and error_half
bin_edges = np.linspace(0, 360, n_bins + 1)
data['bin_target'] = pd.cut(data['target_loc'], bins=bin_edges, include_lowest=True)
mean_errors_per_bin        = data.groupby('bin_target')['errors'].mean()
mean_errors_half_per_bin   = data.groupby('bin_target')['errors_half'].mean()
data['adjusted_errors']        = data['errors']      - data['bin_target'].map(mean_errors_per_bin).astype(float)
data['adjusted_errors_half']   = data['errors_half'] - data['bin_target'].map(mean_errors_half_per_bin).astype(float)

# 2. Bin by relative location for both sessions (full version, [-180, 180])
data['bin_rel'] = pd.cut(data['rel_loc'], bins=n_bins)
bin_rel       = data.groupby('bin_rel')['adjusted_errors'].agg(['mean', 'sem']).reset_index()
bin_rel_half  = data.groupby('bin_rel')['adjusted_errors_half'].agg(['mean', 'sem']).reset_index()
edges  = bin_rel['bin_rel'].cat.categories
centers = (edges.left + edges.right) / 2

# 3. FLIP SIGN for abs(rel_loc): defects on the left (-) are flipped so all bins reflect the same "direction"
data['rel_loc_abs'] = np.abs(data['rel_loc'])
data['bin_rel_abs'] = pd.cut(data['rel_loc_abs'], bins=n_bins, include_lowest=True)

# Flip errors for abs plot:
data['adjusted_errors_abs']      = data['adjusted_errors'] * np.sign(data['rel_loc'])
data['adjusted_errors_half_abs'] = data['adjusted_errors_half'] * np.sign(data['rel_loc'])

bin_rel_abs      = data.groupby('bin_rel_abs')['adjusted_errors_abs'].agg(['mean', 'sem']).reset_index()
bin_rel_abs_half = data.groupby('bin_rel_abs')['adjusted_errors_half_abs'].agg(['mean', 'sem']).reset_index()
edges_abs = bin_rel_abs['bin_rel_abs'].cat.categories
centers_abs = (edges_abs.left + edges_abs.right) / 2

# 4. Bin by target location for target-centered analysis (optional)
bin_target      = data.groupby('bin_target')['adjusted_errors'].agg(['mean', 'sem']).reset_index()
bin_target_half = data.groupby('bin_target')['adjusted_errors_half'].agg(['mean', 'sem']).reset_index()
edges_target = bin_target['bin_target'].cat.categories
target_centers = (edges_target.left + edges_target.right) / 2

# Result: bin_rel, bin_rel_half, bin_rel_abs, bin_rel_abs_half, bin_target, bin_target_half, and centers for all.
#+end_src

#+RESULTS:

#+begin_src ipython
fig, ax = plt.subplots(1, 3, figsize=[3*width, height])

# Panel 1: By Target Location
ax[0].plot(target_centers, bin_target['mean'], 'b')
ax[0].fill_between(target_centers, bin_target['mean'] - bin_target['sem'], bin_target['mean'] + bin_target['sem'], color='b', alpha=0.2)
ax[0].axhline(0, color='k', linestyle=":")
ax[0].set_xlabel('Target Loc. (°)')
ax[0].set_ylabel('Corrected Error (°)')

# Panel 2: By Relative Location (Full vs Half session, -180..180)
ax[1].plot(centers, bin_rel['mean'], 'r', label='full')
ax[1].fill_between(centers, bin_rel['mean'] - bin_rel['sem'], bin_rel['mean'] + bin_rel['sem'], color='r', alpha=0.2)
ax[1].plot(centers, bin_rel_half['mean'], 'b', label='half')
ax[1].fill_between(centers, bin_rel_half['mean'] - bin_rel_half['sem'], bin_rel_half['mean'] + bin_rel_half['sem'], color='b', alpha=0.2)
ax[1].axhline(0, color='k', linestyle=":")
ax[1].set_xlabel('Rel. Loc. (°)')
ax[1].set_ylabel('Corrected Error (°)')
ax[1].legend(fontsize=12)

# Panel 3: By |Relative Location| (Full and Half)
ax[2].plot(centers_abs, bin_rel_abs['mean'], 'r', label='full')
ax[2].fill_between(centers_abs, bin_rel_abs['mean'] - bin_rel_abs['sem'], bin_rel_abs['mean'] + bin_rel_abs['sem'], color='r', alpha=0.2)
ax[2].plot(centers_abs, bin_rel_abs_half['mean'], 'b', label='half')
ax[2].fill_between(centers_abs, bin_rel_abs_half['mean'] - bin_rel_abs_half['sem'], bin_rel_abs_half['mean'] + bin_rel_abs_half['sem'], color='b', alpha=0.2)
ax[2].axhline(0, color='k', linestyle=":")
ax[2].set_xlabel('|Rel. Loc.| (°)')
ax[2].set_ylabel('Corrected Error (°)')
ax[2].legend(fontsize=12)

plt.tight_layout()
plt.show()
#+end_src

#+RESULTS:
[[./figures/odr_sb/figure_29.png]]

#+begin_src ipython

#+end_src

#+RESULTS:
